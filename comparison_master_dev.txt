diff --git a/Jenkinsfile b/Jenkinsfile
index d53618dc..42452df1 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -8,23 +8,11 @@ pipeline {
         ))
     }
     stages {
-        stage('Setup pypi credentials') {
-            steps {
-                script {
-                    withCredentials([
-                        string(credentialsId: 'om-pypi-index-url', variable: 'OM_PYPI_INDEX_URL'),
-                    ])
-                    {
-                        env.OM_PYPI_INDEX_URL = "${OM_PYPI_INDEX_URL}"
-                    }
-                }
-            }
-        }
         stage('Run mypy typechecks') {
             agent {
                 dockerfile {
                     filename 'docker/test/Dockerfile'
-                    additionalBuildArgs "--build-arg TAG=3.8-buster --build-arg OM_PYPI_INDEX_URL=${env.OM_PYPI_INDEX_URL}"
+                    additionalBuildArgs "--build-arg TAG=3.8-buster"
                 }
             }
             steps {
@@ -43,7 +31,7 @@ pipeline {
             agent {
                 dockerfile {
                     filename 'docker/test/Dockerfile'
-                    additionalBuildArgs "--build-arg TAG=3.8-buster --build-arg OM_PYPI_INDEX_URL=${env.OM_PYPI_INDEX_URL}"
+                    additionalBuildArgs "--build-arg TAG=3.8-buster"
                 }
             }
             steps {
@@ -96,7 +84,7 @@ pipeline {
             agent {
                 dockerfile {
                     filename 'docker/test/Dockerfile'
-                    additionalBuildArgs "--build-arg TAG=3.8-buster --build-arg OM_PYPI_INDEX_URL=${env.OM_PYPI_INDEX_URL}"
+                    additionalBuildArgs "--build-arg TAG=3.8-buster"
                 }
             }
             steps {
diff --git a/README.md b/README.md
index 0037b639..aacdf68a 100644
--- a/README.md
+++ b/README.md
@@ -8,6 +8,9 @@ It is the glue between the OpenMotics Master (microcontroller) and the rest of t
 
 Some parts of the code can be run locally using a dummy master implementation.
 
+### Installing NIX
+Install NIX by following the instruction on the website https://nixos.org/download.html (use recommended setup)
+
 ### Installing the requirements
 To run localy, the easiest method is via direnv.
 
@@ -66,6 +69,7 @@ cp ../example/master_fixture.json .
 openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout https.key -out https.crt -subj '/CN=om-developer'
 ```
 
+in etc/openmotics.conf you will be able to find settings such as ports etc
 
 ### Dummy master
 
@@ -107,6 +111,11 @@ some extra dependencies in order to function properly:
 ```sh
 pip install mypy types-all sqlalchemy-stubs
 ```
+Now run the type checking test
+
+```sh
+../gateway$ mypy src
+```
 
 
 ## Running the code
@@ -115,6 +124,12 @@ Start the necessary services using foreman
 ```sh
 foreman start
 ```
+### Local user
+When Running locally, you can disable the vpn service, open in the root directory:
+```
+vim ProcFile
+```
+and commend out the vpn service. Now start with foreman.
 
 ### Local user
 The gateway locally does not require authentication.
@@ -128,6 +143,22 @@ Otherwise the VPN service will fail because it cannot perform the check.
 vpn_check_url = http://127.0.0.1:8000/portal/check_vpn/?uuid=%%s 
 ```
 
+### obscure known problems
+* There might be symlink issues when trying to deploy on a mounted drive, deploying on the native drive will fix those issues. In my case the symlink issues caused installed packages to not be found.
+
+## Updating the database
+We use alembic to manage database migrations, general documentation: https://alembic.sqlalchemy.org/en/latest/tutorial.html#running-our-second-migration
+
+Building the migration after changes in the model:
+```
+alembic revision --autogenerate -m "comment"
+```
+
+Running the migrations:
+```
+alembic upgrade head
+```
+
 ## License
 
 This project is licensed under the AGPLv3 License - see the [LICENSE.md](LICENSE.md) file for details
@@ -135,3 +166,4 @@ This project is licensed under the AGPLv3 License - see the [LICENSE.md](LICENSE
 ## Acknowledgments
 
 * Thanks to everybody testing this code and providing feedback.
+
diff --git a/docker/test/Dockerfile b/docker/test/Dockerfile
index d6b7623c..2d18f699 100644
--- a/docker/test/Dockerfile
+++ b/docker/test/Dockerfile
@@ -21,11 +21,4 @@ RUN if command -v virtualenv; then\
     venv/bin/pip install -r requirements-py3.txt;\
   fi
 
-ARG OM_PYPI_INDEX_URL
-COPY requirements-openmotics-py3.txt /app/
-# install the openmotics requirements depending on the python version
-RUN if [ -n "$OM_PYPI_INDEX_URL" ]; then\
-    venv/bin/pip install --extra-index-url "$OM_PYPI_INDEX_URL" -r requirements-openmotics-py3.txt;\
-  fi
-
 ENV PATH="/app/venv/bin:${PATH}"
diff --git a/mypy.ini b/mypy.ini
index 6f795820..0a77aa7f 100644
--- a/mypy.ini
+++ b/mypy.ini
@@ -20,6 +20,8 @@ check_untyped_defs = False
 check_untyped_defs = False
 [mypy-gateway.metrics_controller]
 check_untyped_defs = False
+[mypy-gateway.hvac_controller]
+check_untyped_defs = False
 [mypy-gateway.metrics_collector]
 check_untyped_defs = False
 [mypy-gateway.module_controller]
diff --git a/requirements-dev.txt b/requirements-dev.txt
new file mode 100644
index 00000000..e5a5cded
--- /dev/null
+++ b/requirements-dev.txt
@@ -0,0 +1,12 @@
+sqlalchemy-stubs==0.4
+types-croniter==1.0.3
+types-cryptography==3.3.9
+types-decorator==5.1.0
+types-enum34==1.1.1
+types-ipaddress==1.0.1
+types-pyOpenSSL==21.0.1
+types-python-dateutil==2.8.3
+types-pytz==2021.3.1
+types-requests==2.26.0
+types-six==1.16.2
+types-ujson==4.2.0
diff --git a/requirements-for-dependencies.txt b/requirements-for-dependencies.txt
new file mode 100644
index 00000000..c080870f
--- /dev/null
+++ b/requirements-for-dependencies.txt
@@ -0,0 +1,69 @@
+APScheduler==3.6.3
+CherryPy==17.4.2
+Mako==1.2.0
+MarkupSafe==2.1.1
+PyJWT==2.3.0
+Pygments==2.5.2
+Routes==2.5.1
+SQLAlchemy==1.4.32
+alembic==1.6.5
+atomicwrites==1.4.0
+attrs==21.4.0
+backports.zoneinfo==0.2.1
+certifi==2021.10.8
+cffi==1.15.0
+charset-normalizer==2.0.12
+cheroot==8.6.0
+contextlib2==21.6.0
+coverage==6.3.2
+croniter==0.3.34
+cryptography==3.2.1
+decorator==4.4.2
+fakesleep==0.1
+freezegun==0.3.15
+greenlet==1.1.2
+hypothesis==4.57.1
+idna==3.3
+intelhex==2.2.1
+ipython==5.10.0
+jaraco.functools==3.5.0
+minimalmodbus==1.0.2
+mock==4.0.3
+more_itertools==8.12.0
+msgpack==0.6.2
+natsort==8.1.0
+nose==1.3.7
+pexpect==4.8.0
+pickleshare==0.7.5
+pip==22.0.3
+pluggy==0.13.1
+portend==3.1.0
+prompt-toolkit==1.0.18
+psutil==5.7.2
+ptyprocess==0.7.0
+py==1.11.0
+pyserial==3.5
+pytest-cov==2.10.1
+pytest==4.6.11
+python-dateutil==2.8.2
+python-editor==1.0.4
+pytz==2021.3
+pytz-deprecation-shim==0.1.0.post0
+repoze.lru==0.7
+requests==2.27.1
+setuptools==60.8.1
+simple_pid==0.2.4
+simplegeneric==0.8.1
+six==1.16.0
+sortedcontainers==2.4.0
+tempora==5.0.1
+traitlets==5.1.1
+typing==3.7.4.3
+tzdata==2021.5
+tzlocal==4.1
+ujson==5.1.0
+urllib3==1.26.8
+wcwidth==0.2.5
+ws4py==0.5.1
+xmlrunner==1.7.7
+zc.lockfile==2.0
diff --git a/requirements-openmotics-py3.txt b/requirements-openmotics-py3.txt
deleted file mode 100644
index d6302275..00000000
--- a/requirements-openmotics-py3.txt
+++ /dev/null
@@ -1 +0,0 @@
-openmotics_rebus == 0.0.2
diff --git a/requirements-py3.txt b/requirements-py3.txt
index 2a5af6f1..8075ce74 100644
--- a/requirements-py3.txt
+++ b/requirements-py3.txt
@@ -1,23 +1,28 @@
 # NOTE: packages that should be removed during deployment should be explicitly
 # uninstalled with pip in `post-update.sh`, otherwise they remain available.
 
-pip==22.0.3
 APScheduler==3.6.3
 CherryPy==17.4.2
+PyJWT == 1.7.1
+Routes==2.5.1
 SQLAlchemy==1.4.32
+alembic==1.6.5
 croniter==0.3.34
+cryptography==36.0.0
 decorator==4.4.2
-hypothesis==4.57.1
+fakesleep==0.1
 freezegun == 0.3.15
+hypothesis==4.57.1
 intelhex==2.2.1
 ipython==5.10.0
+minimalmodbus==1.0.2
 mock==3.0.5
 msgpack==0.6.2
+nose==1.3.7
 peewee-migrate==1.1.6
 peewee==3.13.3
+pip==22.0.3
 psutil==5.7.2
-PyJWT == 1.7.1
-cryptography==36.0.0
 pyserial==3.4
 pytest-cov==2.10.1
 pytest==4.6.11
@@ -28,8 +33,3 @@ typing==3.7.4.3
 ujson==2.0.3
 ws4py==0.5.1
 xmlrunner==1.7.7
-fakesleep==0.1
-Routes==2.5.1
-minimalmodbus==1.0.2
-nose==1.3.7
-alembic==1.6.5
diff --git a/requirements.txt b/requirements.txt
index 116cdf46..ed90c29a 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,34 +1,34 @@
 # NOTE: packages that should be removed during deployment should be explicitly
 # uninstalled with pip in `post-update.sh`, otherwise they remain available.
 
-pip == 19.3.1
+PyJWT == 1.7.1
+Routes==2.5.1
+SQLAlchemy==1.4.32
+alembic == 1.6.5
+apscheduler == 3.6.3
+cherrypy == 3.2.2
+croniter == 0.3.20
+decorator == 4.4.0
+fakesleep == 0.1
+freezegun == 0.3.15
 hypothesis == 4.57.1
+intelhex == 1.5
+minimalmodbus == 1.0.2
 mock == 2.0.0
+msgpack == 0.6.1
+nose == 1.3.7
+peewee == 3.13.1
+peewee-migrate == 1.1.6
+pip == 19.3.1
+psutil==5.6.7
+pyserial == 3.4.0
 pytest == 4.6.9
 pytest-cov == 2.8.1
-freezegun == 0.3.15
-cherrypy == 3.2.2
+python-dateutil == 2.8.1
+pytz == 2017.3
 requests == 2.24.0
-intelhex == 1.5
-xmlrunner == 1.7.7
-ws4py == 0.5.1
-msgpack == 0.6.1
-decorator == 4.4.0
-PyJWT == 1.7.1
-pyserial == 3.4.0
-psutil==5.6.7
 simple-pid==0.2.4
-croniter == 0.3.20
-pytz == 2017.3
-apscheduler == 3.6.3
-peewee == 3.13.1
-peewee-migrate == 1.1.6
-SQLAlchemy==1.4.32
 six == 1.13.0
-python-dateutil == 2.8.1
 ujson == 1.35
-fakesleep == 0.1
-Routes==2.5.1
-minimalmodbus == 1.0.2
-nose == 1.3.7
-alembic == 1.6.5
+ws4py == 0.5.1
+xmlrunner == 1.7.7
diff --git a/setup.cfg b/setup.cfg
deleted file mode 100644
index 330d0213..00000000
--- a/setup.cfg
+++ /dev/null
@@ -1,28 +0,0 @@
-[metadata]
-name = gateway
-version = attr:gateway.__version__
-description = OpenMotics Gateway (backend)
-url = https://github.com/openmotics/gateway
-license = AGPL3
-classifiers =
-    Development Status :: 5 - Production/Stable
-    License :: OSI Approved :: GNU Affero General Public License v3
-    Programming Language :: Python
-    Programming Language :: Python :: 2.7
-
-[options]
-zip_safe = False
-include_package_data = True
-packages = find:
-package_dir =
-    = src
-
-[options.packages.find]
-where = src
-
-[options.entry_points]
-console_scripts =
-    om-gateway=openmotics_cli:main
-
-[bdist_wheel]
-universal = true
diff --git a/setup.cfg b/setup.cfg
new file mode 120000
index 00000000..1661a94b
--- /dev/null
+++ b/setup.cfg
@@ -0,0 +1 @@
+src/setup.cfg
\ No newline at end of file
diff --git a/setup.py b/setup.py
deleted file mode 100644
index 8bf1ba93..00000000
--- a/setup.py
+++ /dev/null
@@ -1,2 +0,0 @@
-from setuptools import setup
-setup()
diff --git a/setup.py b/setup.py
new file mode 120000
index 00000000..4b122b3e
--- /dev/null
+++ b/setup.py
@@ -0,0 +1 @@
+src/setup.py
\ No newline at end of file
diff --git a/src/MANIFEST.in b/src/MANIFEST.in
new file mode 100644
index 00000000..6c9e6b40
--- /dev/null
+++ b/src/MANIFEST.in
@@ -0,0 +1 @@
+include *.py
diff --git a/src/cloud/cloud_api_client.py b/src/cloud/cloud_api_client.py
index 8565dacf..8e33ac11 100644
--- a/src/cloud/cloud_api_client.py
+++ b/src/cloud/cloud_api_client.py
@@ -77,12 +77,14 @@ class CloudAPIClient(object):
         # make request
         events_endpoint = self._get_endpoint(Config.get_entry('cloud_endpoint_events', '') or 'portal/events/')
         query_params = {'uuid': self._gateway_uuid}
+        logger.debug('Uploading %d events to cloud...', len(events))
+        logger.debug('events %s', events)
         try:
             response = self._session.post(events_endpoint,
                                           params=query_params,
                                           data={'events': json.dumps([event.serialize() for event in events])},
                                           timeout=5,
-                                          verify=System.get_operating_system().get('ID') != System.OS.ANGSTROM)
+                                          verify=System.verify_requests())
             if not response:
                 raise APIException('Error while sending events to {}. HTTP Status: {}'.format(self._hostname,
                                                                                               response.status_code))
@@ -97,12 +99,13 @@ class CloudAPIClient(object):
         metrics_endpoint = self._get_endpoint(Config.get_entry('cloud_endpoint_metrics', '') or 'portal/metrics/')
         query_params = {'uuid': self._gateway_uuid}
         logger.info('Uploading %d metrics to cloud...', len(metrics))
+        logger.debug('metrics %s', metrics)
         try:
             response = self._session.post(metrics_endpoint,
                                           params=query_params,
                                           data={'metrics': json.dumps(metrics)},
                                           timeout=30.0,
-                                          verify=System.get_operating_system().get('ID') != System.OS.ANGSTROM)
+                                          verify=System.verify_requests())
             if not response:
                 raise APIException('Error while sending metrics to {}. HTTP Status: {}'.format(self._hostname,
                                                                                                response.status_code))
diff --git a/src/constants.py b/src/constants.py
index d7fdafc5..64a594ea 100644
--- a/src/constants.py
+++ b/src/constants.py
@@ -32,9 +32,11 @@ def get_src_root_full_path():
     return os.path.abspath(os.path.join(__file__, '..'))
 
 
-def get_config_file():
+def get_config_file(prefix=None):
     """ Get the filename of the OpenMotics config file. This file is in ini format. """
-    return os.path.join(OPENMOTICS_PREFIX, 'etc/openmotics.conf')
+    if prefix is None:
+        prefix = get_openmotics_prefix()
+    return os.path.join(prefix, 'etc/openmotics.conf')
 
 
 def get_config_database_file():
diff --git a/src/etc/README.md b/src/etc/README.md
new file mode 100644
index 00000000..ec2a9a78
--- /dev/null
+++ b/src/etc/README.md
@@ -0,0 +1,11 @@
+This directory contains code specific non-python helper files such as:
+* `cacert.pem`:  CA certificates for the `requests` library in case the OS provided certs are outdated
+* `services/`:
+  * `supervisord/`:
+    * `openmotics.conf`: Service file for `openmotics_service`-service
+    * `vpn_service.conf`: Service file for `vpn_service`-service
+    * `watchdog.conf`: Service file for `watchdog`-service
+    * `sha256.json`: File containing the checksums of the above files, 
+      to prevent making fs changes if it's not needed
+  * `systemd/`:
+    * _These services are unsupported, and are only used on integration test systems_
diff --git a/src/etc/cacert.pem b/src/etc/cacert.pem
new file mode 100644
index 00000000..e48425d3
--- /dev/null
+++ b/src/etc/cacert.pem
@@ -0,0 +1,3489 @@
+ACCVRAIZ1
+-----BEGIN CERTIFICATE-----
+MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UE
+AwwJQUNDVlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQsw
+CQYDVQQGEwJFUzAeFw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQ
+BgNVBAMMCUFDQ1ZSQUlaMTEQMA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUND
+VjELMAkGA1UEBhMCRVMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCb
+qau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPfmt4ftVTdFXxpNRFvu8gMjmoY
+HtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM3802/J+Nq2DoLSRYWo
+G2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkXhBilyNpA
+lHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr
+IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/
+0KIV9VMJcRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eH
+k6fGioozl2A3ED6XPm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/47
+4KElB0iryYl0/wiPgL/AlmXz7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMO
+m3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE3fj5tItQo05iifCHJPqDQsGH+tUtKSpa
+cXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbhdQrqeWZ2iE9x6wQl1gpaepPl
+uUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQABo4ICyzCCAscwfQYI
+KwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3YuZXMvZmls
+ZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG
+AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2
+VuqB5TbMjB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeT
+VfZW6oHlNsyMHj+9MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIG
+CCsGAQUFBwICMIIBFB6CARAAQQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUA
+cgB0AGkAZgBpAGMAYQBjAGkA8wBuACAAUgBhAO0AegAgAGQAZQAgAGwAYQAgAEEA
+QwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUAIABUAGUAYwBuAG8AbABvAGcA
+7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4AIABFAGwAZQBjAHQA
+cgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUAKQAuACAA
+QwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA
+czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2Mu
+aHRtMFUGA1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRt
+aW4vQXJjaGl2b3MvY2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1Ud
+DwEB/wQEAwIBBjAXBgNVHREEEDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEF
+BQADggIBAJcxAp/n/UNnSEQU5CmH7UwoZtCPNdpNYbdKl02125DgBS4OxnnQ8pdp
+D70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTKFpV8M9xii6g3+CfYCS0b78gU
+JyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/+QEnWCzI7UiRfD+m
+AM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA9j9ajepD
+vV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms
+tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH
+7ehVRE2I9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5h
+I6zppSSMEYCUWqKiuUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szA
+h1xA2syVP1XgNce4hL60Xc16gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xF
+d3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2H
+pPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbRD0tVNEYqi4Y7
+-----END CERTIFICATE-----
+
+AC RAIZ FNMT-RCM
+-----BEGIN CERTIFICATE-----
+MIIFgzCCA2ugAwIBAgIPXZONMGc2yAYdGsdUhGkHMA0GCSqGSIb3DQEBCwUAMDsx
+CzAJBgNVBAYTAkVTMREwDwYDVQQKDAhGTk1ULVJDTTEZMBcGA1UECwwQQUMgUkFJ
+WiBGTk1ULVJDTTAeFw0wODEwMjkxNTU5NTZaFw0zMDAxMDEwMDAwMDBaMDsxCzAJ
+BgNVBAYTAkVTMREwDwYDVQQKDAhGTk1ULVJDTTEZMBcGA1UECwwQQUMgUkFJWiBG
+Tk1ULVJDTTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBALpxgHpMhm5/
+yBNtwMZ9HACXjywMI7sQmkCpGreHiPibVmr75nuOi5KOpyVdWRHbNi63URcfqQgf
+BBckWKo3Shjf5TnUV/3XwSyRAZHiItQDwFj8d0fsjz50Q7qsNI1NOHZnjrDIbzAz
+WHFctPVrbtQBULgTfmxKo0nRIBnuvMApGGWn3v7v3QqQIecaZ5JCEJhfTzC8PhxF
+tBDXaEAUwED653cXeuYLj2VbPNmaUtu1vZ5Gzz3rkQUCwJaydkxNEJY7kvqcfw+Z
+374jNUUeAlz+taibmSXaXvMiwzn15Cou08YfxGyqxRxqAQVKL9LFwag0Jl1mpdIC
+IfkYtwb1TplvqKtMUejPUBjFd8g5CSxJkjKZqLsXF3mwWsXmo8RZZUc1g16p6DUL
+mbvkzSDGm0oGObVo/CK67lWMK07q87Hj/LaZmtVC+nFNCM+HHmpxffnTtOmlcYF7
+wk5HlqX2doWjKI/pgG6BU6VtX7hI+cL5NqYuSf+4lsKMB7ObiFj86xsc3i1w4peS
+MKGJ47xVqCfWS+2QrYv6YyVZLag13cqXM7zlzced0ezvXg5KkAYmY6252TUtB7p2
+ZSysV4999AeU14ECll2jB0nVetBX+RvnU0Z1qrB5QstocQjpYL05ac70r8NWQMet
+UqIJ5G+GR4of6ygnXYMgrwTJbFaai0b1AgMBAAGjgYMwgYAwDwYDVR0TAQH/BAUw
+AwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFPd9xf3E6Jobd2Sn9R2gzL+H
+YJptMD4GA1UdIAQ3MDUwMwYEVR0gADArMCkGCCsGAQUFBwIBFh1odHRwOi8vd3d3
+LmNlcnQuZm5tdC5lcy9kcGNzLzANBgkqhkiG9w0BAQsFAAOCAgEAB5BK3/MjTvDD
+nFFlm5wioooMhfNzKWtN/gHiqQxjAb8EZ6WdmF/9ARP67Jpi6Yb+tmLSbkyU+8B1
+RXxlDPiyN8+sD8+Nb/kZ94/sHvJwnvDKuO+3/3Y3dlv2bojzr2IyIpMNOmqOFGYM
+LVN0V2Ue1bLdI4E7pWYjJ2cJj+F3qkPNZVEI7VFY/uY5+ctHhKQV8Xa7pO6kO8Rf
+77IzlhEYt8llvhjho6Tc+hj507wTmzl6NLrTQfv6MooqtyuGC2mDOL7Nii4LcK2N
+JpLuHvUBKwrZ1pebbuCoGRw6IYsMHkCtA+fdZn71uSANA+iW+YJF1DngoABd15jm
+fZ5nc8OaKveri6E6FO80vFIOiZiaBECEHX5FaZNXzuvO+FB8TxxuBEOb+dY7Ixjp
+6o7RTUaN8Tvkasq6+yO3m/qZASlaWFot4/nUbQ4mrcFuNLwy+AwF+mWj2zs3gyLp
+1txyM/1d8iC9djwj2ij3+RvrWWTV3F9yfiD8zYm1kGdNYno/Tq0dwzn+evQoFt9B
+9kiABdcPUXmsEKvU7ANm5mqwujGSQkBqvjrTcuFqN1W8rB2Vt2lh8kORdOag0wok
+RqEIr9baRRmW1FMdW4R58MD3R++Lj8UGrp1MYp3/RgT408m2ECVAdf4WqslKYIYv
+uu8wd+RU4riEmViAqhOLUTpPSPaLtrM=
+-----END CERTIFICATE-----
+
+AC RAIZ FNMT-RCM SERVIDORES SEGUROS
+-----BEGIN CERTIFICATE-----
+MIICbjCCAfOgAwIBAgIQYvYybOXE42hcG2LdnC6dlTAKBggqhkjOPQQDAzB4MQsw
+CQYDVQQGEwJFUzERMA8GA1UECgwIRk5NVC1SQ00xDjAMBgNVBAsMBUNlcmVzMRgw
+FgYDVQRhDA9WQVRFUy1RMjgyNjAwNEoxLDAqBgNVBAMMI0FDIFJBSVogRk5NVC1S
+Q00gU0VSVklET1JFUyBTRUdVUk9TMB4XDTE4MTIyMDA5MzczM1oXDTQzMTIyMDA5
+MzczM1oweDELMAkGA1UEBhMCRVMxETAPBgNVBAoMCEZOTVQtUkNNMQ4wDAYDVQQL
+DAVDZXJlczEYMBYGA1UEYQwPVkFURVMtUTI4MjYwMDRKMSwwKgYDVQQDDCNBQyBS
+QUlaIEZOTVQtUkNNIFNFUlZJRE9SRVMgU0VHVVJPUzB2MBAGByqGSM49AgEGBSuB
+BAAiA2IABPa6V1PIyqvfNkpSIeSX0oNnnvBlUdBeh8dHsVnyV0ebAAKTRBdp20LH
+sbI6GA60XYyzZl2hNPk2LEnb80b8s0RpRBNm/dfF/a82Tc4DTQdxz69qBdKiQ1oK
+Um8BA06Oi6NCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
+VR0OBBYEFAG5L++/EYZg8k/QQW6rcx/n0m5JMAoGCCqGSM49BAMDA2kAMGYCMQCu
+SuMrQMN0EfKVrRYj3k4MGuZdpSRea0R7/DjiT8ucRRcRTBQnJlU5dUoDzBOQn5IC
+MQD6SmxgiHPz7riYYqnOK8LZiqZwMR2vsJRM60/G49HzYqc8/5MuB1xJAWdpEgJy
+v+c=
+-----END CERTIFICATE-----
+
+ANF Secure Server Root CA
+-----BEGIN CERTIFICATE-----
+MIIF7zCCA9egAwIBAgIIDdPjvGz5a7EwDQYJKoZIhvcNAQELBQAwgYQxEjAQBgNV
+BAUTCUc2MzI4NzUxMDELMAkGA1UEBhMCRVMxJzAlBgNVBAoTHkFORiBBdXRvcmlk
+YWQgZGUgQ2VydGlmaWNhY2lvbjEUMBIGA1UECxMLQU5GIENBIFJhaXoxIjAgBgNV
+BAMTGUFORiBTZWN1cmUgU2VydmVyIFJvb3QgQ0EwHhcNMTkwOTA0MTAwMDM4WhcN
+MzkwODMwMTAwMDM4WjCBhDESMBAGA1UEBRMJRzYzMjg3NTEwMQswCQYDVQQGEwJF
+UzEnMCUGA1UEChMeQU5GIEF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uMRQwEgYD
+VQQLEwtBTkYgQ0EgUmFpejEiMCAGA1UEAxMZQU5GIFNlY3VyZSBTZXJ2ZXIgUm9v
+dCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANvrayvmZFSVgpCj
+cqQZAZ2cC4Ffc0m6p6zzBE57lgvsEeBbphzOG9INgxwruJ4dfkUyYA8H6XdYfp9q
+yGFOtibBTI3/TO80sh9l2Ll49a2pcbnvT1gdpd50IJeh7WhM3pIXS7yr/2WanvtH
+2Vdy8wmhrnZEE26cLUQ5vPnHO6RYPUG9tMJJo8gN0pcvB2VSAKduyK9o7PQUlrZX
+H1bDOZ8rbeTzPvY1ZNoMHKGESy9LS+IsJJ1tk0DrtSOOMspvRdOoiXsezx76W0OL
+zc2oD2rKDF65nkeP8Nm2CgtYZRczuSPkdxl9y0oukntPLxB3sY0vaJxizOBQ+OyR
+p1RMVwnVdmPF6GUe7m1qzwmd+nxPrWAI/VaZDxUse6mAq4xhj0oHdkLePfTdsiQz
+W7i1o0TJrH93PB0j7IKppuLIBkwC/qxcmZkLLxCKpvR/1Yd0DVlJRfbwcVw5Kda/
+SiOL9V8BY9KHcyi1Swr1+KuCLH5zJTIdC2MKF4EA/7Z2Xue0sUDKIbvVgFHlSFJn
+LNJhiQcND85Cd8BEc5xEUKDbEAotlRyBr+Qc5RQe8TZBAQIvfXOn3kLMTOmJDVb3
+n5HUA8ZsyY/b2BzgQJhdZpmYgG4t/wHFzstGH6wCxkPmrqKEPMVOHj1tyRRM4y5B
+u8o5vzY8KhmqQYdOpc5LMnndkEl/AgMBAAGjYzBhMB8GA1UdIwQYMBaAFJxf0Gxj
+o1+TypOYCK2Mh6UsXME3MB0GA1UdDgQWBBScX9BsY6Nfk8qTmAitjIelLFzBNzAO
+BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOC
+AgEATh65isagmD9uw2nAalxJUqzLK114OMHVVISfk/CHGT0sZonrDUL8zPB1hT+L
+9IBdeeUXZ701guLyPI59WzbLWoAAKfLOKyzxj6ptBZNscsdW699QIyjlRRA96Gej
+rw5VD5AJYu9LWaL2U/HANeQvwSS9eS9OICI7/RogsKQOLHDtdD+4E5UGUcjohybK
+pFtqFiGS3XNgnhAY3jyB6ugYw3yJ8otQPr0R4hUDqDZ9MwFsSBXXiJCZBMXM5gf0
+vPSQ7RPi6ovDj6MzD8EpTBNO2hVWcXNyglD2mjN8orGoGjR0ZVzO0eurU+AagNjq
+OknkJjCb5RyKqKkVMoaZkgoQI1YS4PbOTOK7vtuNknMBZi9iPrJyJ0U27U1W45eZ
+/zo1PqVUSlJZS2Db7v54EX9K3BR5YLZrZAPbFYPhor72I5dQ8AkzNqdxliXzuUJ9
+2zg/LFis6ELhDtjTO0wugumDLmsx2d1Hhk9tl5EuT+IocTUW0fJz/iUrB0ckYyfI
++PbZa/wSMVYIwFNCr5zQM378BvAxRAMU8Vjq8moNqRGyg77FGr8H6lnco4g175x2
+MjxNBiLOFeXdntiP2t7SxDnlF4HPOEfrf4htWRvfn0IUrn7PqLBmZdo3r5+qPeoo
+tt7VMVgWglvquxl1AnMaykgaIZOQCo6ThKd9OyMYkomgjaw=
+-----END CERTIFICATE-----
+
+Actalis Authentication Root CA
+-----BEGIN CERTIFICATE-----
+MIIFuzCCA6OgAwIBAgIIVwoRl0LE48wwDQYJKoZIhvcNAQELBQAwazELMAkGA1UE
+BhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8w
+MzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290
+IENBMB4XDTExMDkyMjExMjIwMloXDTMwMDkyMjExMjIwMlowazELMAkGA1UEBhMC
+SVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1
+ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290IENB
+MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAp8bEpSmkLO/lGMWwUKNv
+UTufClrJwkg4CsIcoBh/kbWHuUA/3R1oHwiD1S0eiKD4j1aPbZkCkpAW1V8IbInX
+4ay8IMKx4INRimlNAJZaby/ARH6jDuSRzVju3PvHHkVH3Se5CAGfpiEd9UEtL0z9
+KK3giq0itFZljoZUj5NDKd45RnijMCO6zfB9E1fAXdKDa0hMxKufgFpbOr3JpyI/
+gCczWw63igxdBzcIy2zSekciRDXFzMwujt0q7bd9Zg1fYVEiVRvjRuPjPdA1Yprb
+rxTIW6HMiRvhMCb8oJsfgadHHwTrozmSBp+Z07/T6k9QnBn+locePGX2oxgkg4YQ
+51Q+qDp2JE+BIcXjDwL4k5RHILv+1A7TaLndxHqEguNTVHnd25zS8gebLra8Pu2F
+be8lEfKXGkJh90qX6IuxEAf6ZYGyojnP9zz/GPvG8VqLWeICrHuS0E4UT1lF9gxe
+KF+w6D9Fz8+vm2/7hNN3WpVvrJSEnu68wEqPSpP4RCHiMUVhUE4Q2OM1fEwZtN4F
+v6MGn8i1zeQf1xcGDXqVdFUNaBr8EBtiZJ1t4JWgw5QHVw0U5r0F+7if5t+L4sbn
+fpb2U8WANFAoWPASUHEXMLrmeGO89LKtmyuy/uE5jF66CyCU3nuDuP/jVo23Eek7
+jPKxwV2dpAtMK9myGPW1n0sCAwEAAaNjMGEwHQYDVR0OBBYEFFLYiDrIn3hm7Ynz
+ezhwlMkCAjbQMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbt
+ifN7OHCUyQICNtAwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAL
+e3KHwGCmSUyIWOYdiPcUZEim2FgKDk8TNd81HdTtBjHIgT5q1d07GjLukD0R0i70
+jsNjLiNmsGe+b7bAEzlgqqI0JZN1Ut6nna0Oh4lScWoWPBkdg/iaKWW+9D+a2fDz
+WochcYBNy+A4mz+7+uAwTc+G02UQGRjRlwKxK3JCaKygvU5a2hi/a5iB0P2avl4V
+SM0RFbnAKVy06Ij3Pjaut2L9HmLecHgQHEhb2rykOLpn7VU+Xlff1ANATIGk0k9j
+pwlCCRT8AKnCgHNPLsBA2RF7SOp6AsDT6ygBJlh0wcBzIm2Tlf05fbsq4/aC4yyX
+X04fkZT6/iyj2HYauE2yOE+b+h1IYHkm4vP9qdCa6HCPSXrW5b0KDtst842/6+Ok
+fcvHlXHo2qN8xcL4dJIEG4aspCJTQLas/kx2z/uUMsA1n3Y/buWQbqCmJqK4LL7R
+K4X9p2jIugErsWx0Hbhzlefut8cl8ABMALJ+tguLHPPAUJ4lueAI3jZm/zel0btU
+ZCzJJ7VLkn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJU
+LysRJyU3eExRarDzzFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaT
+LnPqZih4zR0Uv6CPLy64Lo7yFIrM6bV8+2ydDKXhlg==
+-----END CERTIFICATE-----
+
+AffirmTrust Commercial
+-----BEGIN CERTIFICATE-----
+MIIDTDCCAjSgAwIBAgIId3cGJyapsXwwDQYJKoZIhvcNAQELBQAwRDELMAkGA1UE
+BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
+dCBDb21tZXJjaWFsMB4XDTEwMDEyOTE0MDYwNloXDTMwMTIzMTE0MDYwNlowRDEL
+MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
+cm1UcnVzdCBDb21tZXJjaWFsMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEA9htPZwcroRX1BiLLHwGy43NFBkRJLLtJJRTWzsO3qyxPxkEylFf6EqdbDuKP
+Hx6GGaeqtS25Xw2Kwq+FNXkyLbscYjfysVtKPcrNcV/pQr6U6Mje+SJIZMblq8Yr
+ba0F8PrVC8+a5fBQpIs7R6UjW3p6+DM/uO+Zl+MgwdYoic+U+7lF7eNAFxHUdPAL
+MeIrJmqbTFeurCA+ukV6BfO9m2kVrn1OIGPENXY6BwLJN/3HR+7o8XYdcxXyl6S1
+yHp52UKqK39c/s4mT6NmgTWvRLpUHhwwMmWd5jyTXlBOeuM61G7MGvv50jeuJCqr
+VwMiKA1JdX+3KNp1v47j3A55MQIDAQABo0IwQDAdBgNVHQ4EFgQUnZPGU4teyq8/
+nx4P5ZmVvCT2lI8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
+KoZIhvcNAQELBQADggEBAFis9AQOzcAN/wr91LoWXym9e2iZWEnStB03TX8nfUYG
+XUPGhi4+c7ImfU+TqbbEKpqrIZcUsd6M06uJFdhrJNTxFq7YpFzUf1GO7RgBsZNj
+vbz4YYCanrHOQnDiqX0GJX0nof5v7LMeJNrjS1UaADs1tDvZ110w/YETifLCBivt
+Z8SOyUOyXGsViQK8YvxO8rUzqrJv0wqiUOP2O+guRMLbZjipM1ZI8W0bM40NjD9g
+N53Tym1+NH4Nn3J2ixufcv1SNUFFApYvHLKac0khsUlHRUe072o0EclNmsxZt9YC
+nlpOZbWUrhvfKbAW8b8Angc6F2S1BLUjIZkKlTuXfO8=
+-----END CERTIFICATE-----
+
+AffirmTrust Networking
+-----BEGIN CERTIFICATE-----
+MIIDTDCCAjSgAwIBAgIIfE8EORzUmS0wDQYJKoZIhvcNAQEFBQAwRDELMAkGA1UE
+BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVz
+dCBOZXR3b3JraW5nMB4XDTEwMDEyOTE0MDgyNFoXDTMwMTIzMTE0MDgyNFowRDEL
+MAkGA1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZp
+cm1UcnVzdCBOZXR3b3JraW5nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAtITMMxcua5Rsa2FSoOujz3mUTOWUgJnLVWREZY9nZOIG41w3SfYvm4SEHi3y
+YJ0wTsyEheIszx6e/jarM3c1RNg1lho9Nuh6DtjVR6FqaYvZ/Ls6rnla1fTWcbua
+kCNrmreIdIcMHl+5ni36q1Mr3Lt2PpNMCAiMHqIjHNRqrSK6mQEubWXLviRmVSRL
+QESxG9fhwoXA3hA/Pe24/PHxI1Pcv2WXb9n5QHGNfb2V1M6+oF4nI979ptAmDgAp
+6zxG8D1gvz9Q0twmQVGeFDdCBKNwV6gbh+0t+nvujArjqWaJGctB+d1ENmHP4ndG
+yH329JKBNv3bNPFyfvMMFr20FQIDAQABo0IwQDAdBgNVHQ4EFgQUBx/S55zawm6i
+QLSwelAQUHTEyL0wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJ
+KoZIhvcNAQEFBQADggEBAIlXshZ6qML91tmbmzTCnLQyFE2npN/svqe++EPbkTfO
+tDIuUFUaNU52Q3Eg75N3ThVwLofDwR1t3Mu1J9QsVtFSUzpE0nPIxBsFZVpikpzu
+QY0x2+c06lkh1QF612S4ZDnNye2v7UsDSKegmQGA3GWjNq5lWUhPgkvIZfFXHeVZ
+Lgo/bNjR9eUJtGxUAArgFU2HdW23WJZa3W3SAKD0m0i+wzekujbgfIeFlxoVot4u
+olu9rxj5kFDNcFn4J2dHy8egBzp90SxdbBk6ZrV9/ZFvgrG+CJPbFEfxojfHRZ48
+x3evZKiT3/Zpg4Jg8klCNO1aAFSFHBY2kgxc+qatv9s=
+-----END CERTIFICATE-----
+
+AffirmTrust Premium
+-----BEGIN CERTIFICATE-----
+MIIFRjCCAy6gAwIBAgIIbYwURrGmCu4wDQYJKoZIhvcNAQEMBQAwQTELMAkGA1UE
+BhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVz
+dCBQcmVtaXVtMB4XDTEwMDEyOTE0MTAzNloXDTQwMTIzMTE0MTAzNlowQTELMAkG
+A1UEBhMCVVMxFDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1U
+cnVzdCBQcmVtaXVtMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxBLf
+qV/+Qd3d9Z+K4/as4Tx4mrzY8H96oDMq3I0gW64tb+eT2TZwamjPjlGjhVtnBKAQ
+JG9dKILBl1fYSCkTtuG+kU3fhQxTGJoeJKJPj/CihQvL9Cl/0qRY7iZNyaqoe5rZ
++jjeRFcV5fiMyNlI4g0WJx0eyIOFJbe6qlVBzAMiSy2RjYvmia9mx+n/K+k8rNrS
+s8PhaJyJ+HoAVt70VZVs+7pk3WKL3wt3MutizCaam7uqYoNMtAZ6MMgpv+0GTZe5
+HMQxK9VfvFMSF5yZVylmd2EhMQcuJUmdGPLu8ytxjLW6OQdJd/zvLpKQBY0tL3d7
+70O/Nbua2Plzpyzy0FfuKE4mX4+QaAkvuPjcBukumj5Rp9EixAqnOEhss/n/fauG
+V+O61oV4d7pD6kh/9ti+I20ev9E2bFhc8e6kGVQa9QPSdubhjL08s9NIS+LI+H+S
+qHZGnEJlPqQewQcDWkYtuJfzt9WyVSHvutxMAJf7FJUnM7/oQ0dG0giZFmA7mn7S
+5u046uwBHjxIVkkJx0w3AJ6IDsBz4W9m6XJHMD4Q5QsDyZpCAGzFlH5hxIrff4Ia
+C1nEWTJ3s7xgaVY5/bQGeyzWZDbZvUjthB9+pSKPKrhC9IK31FOQeE4tGv2Bb0TX
+OwF0lkLgAOIua+rF7nKsu7/+6qqo+Nz2snmKtmcCAwEAAaNCMEAwHQYDVR0OBBYE
+FJ3AZ6YMItkm9UWrpmVSESfYRaxjMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
+BAQDAgEGMA0GCSqGSIb3DQEBDAUAA4ICAQCzV00QYk465KzquByvMiPIs0laUZx2
+KI15qldGF9X1Uva3ROgIRL8YhNILgM3FEv0AVQVhh0HctSSePMTYyPtwni94loMg
+Nt58D2kTiKV1NpgIpsbfrM7jWNa3Pt668+s0QNiigfV4Py/VpfzZotReBA4Xrf5B
+8OWycvpEgjNC6C1Y91aMYj+6QrCcDFx+LmUmXFNPALJ4fqENmS2NuB2OosSw/WDQ
+MKSOyARiqcTtNd56l+0OOF6SL5Nwpamcb6d9Ex1+xghIsV5n61EIJenmJWtSKZGc
+0jlzCFfemQa0W50QBuHCAKi4HEoCChTQwUHK+4w1IX2COPKpVJEZNZOUbWo6xbLQ
+u4mGk+ibyQ86p3q4ofB4Rvr8Ny/lioTz3/4E2aFooC8k4gmVBtWVyuEklut89pMF
+u+1z6S3RdTnX5yTb2E5fQ4+e0BQ5v1VwSJlXMbSc7kqYA5YwH2AG7hsj/oFgIxpH
+YoWlzBk0gG+zrBrjn/B7SK3VAdlntqlyk+otZrWyuOQ9PLLvTIzq6we/qzWaVYa8
+GKa1qF60g2xraUDTn9zxw2lrueFtCfTxqlB2Cnp9ehehVZZCmTEJ3WARjQUwfuaO
+RtGdFNrHF+QFlozEJLUbzxQHskD4o55BhrwE0GuWyCqANP2/7waj3VjFhT0+j/6e
+KeC2uAloGRwYQw==
+-----END CERTIFICATE-----
+
+AffirmTrust Premium ECC
+-----BEGIN CERTIFICATE-----
+MIIB/jCCAYWgAwIBAgIIdJclisc/elQwCgYIKoZIzj0EAwMwRTELMAkGA1UEBhMC
+VVMxFDASBgNVBAoMC0FmZmlybVRydXN0MSAwHgYDVQQDDBdBZmZpcm1UcnVzdCBQ
+cmVtaXVtIEVDQzAeFw0xMDAxMjkxNDIwMjRaFw00MDEyMzExNDIwMjRaMEUxCzAJ
+BgNVBAYTAlVTMRQwEgYDVQQKDAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwXQWZmaXJt
+VHJ1c3QgUHJlbWl1bSBFQ0MwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQNMF4bFZ0D
+0KF5Nbc6PJJ6yhUczWLznCZcBz3lVPqj1swS6vQUX+iOGasvLkjmrBhDeKzQN8O9
+ss0s5kfiGuZjuD0uL3jET9v0D6RoTFVya5UdThhClXjMNzyR4ptlKymjQjBAMB0G
+A1UdDgQWBBSaryl6wBE1NSZRMADDav5A1a7WPDAPBgNVHRMBAf8EBTADAQH/MA4G
+A1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNnADBkAjAXCfOHiFBar8jAQr9HX/Vs
+aobgxCd05DhT1wV/GzTjxi+zygk8N53X57hG8f2h4nECMEJZh0PUUd+60wkyWs6I
+flc9nF9Ca/UHLbXwgpP5WW+uZPpY5Yse42O+tYHNbwKMeQ==
+-----END CERTIFICATE-----
+
+Amazon Root CA 1
+-----BEGIN CERTIFICATE-----
+MIIDQTCCAimgAwIBAgITBmyfz5m/jAo54vB4ikPmljZbyjANBgkqhkiG9w0BAQsF
+ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
+b24gUm9vdCBDQSAxMB4XDTE1MDUyNjAwMDAwMFoXDTM4MDExNzAwMDAwMFowOTEL
+MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
+b3QgQ0EgMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJ4gHHKeNXj
+ca9HgFB0fW7Y14h29Jlo91ghYPl0hAEvrAIthtOgQ3pOsqTQNroBvo3bSMgHFzZM
+9O6II8c+6zf1tRn4SWiw3te5djgdYZ6k/oI2peVKVuRF4fn9tBb6dNqcmzU5L/qw
+IFAGbHrQgLKm+a/sRxmPUDgH3KKHOVj4utWp+UhnMJbulHheb4mjUcAwhmahRWa6
+VOujw5H5SNz/0egwLX0tdHA114gk957EWW67c4cX8jJGKLhD+rcdqsq08p8kDi1L
+93FcXmn/6pUCyziKrlA4b9v7LWIbxcceVOF34GfID5yHI9Y/QCB/IIDEgEw+OyQm
+jgSubJrIqg0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AYYwHQYDVR0OBBYEFIQYzIU07LwMlJQuCFmcx7IQTgoIMA0GCSqGSIb3DQEBCwUA
+A4IBAQCY8jdaQZChGsV2USggNiMOruYou6r4lK5IpDB/G/wkjUu0yKGX9rbxenDI
+U5PMCCjjmCXPI6T53iHTfIUJrU6adTrCC2qJeHZERxhlbI1Bjjt/msv0tadQ1wUs
+N+gDS63pYaACbvXy8MWy7Vu33PqUXHeeE6V/Uq2V8viTO96LXFvKWlJbYK8U90vv
+o/ufQJVtMVT8QtPHRh8jrdkPSHCa2XV4cdFyQzR1bldZwgJcJmApzyMZFo6IQ6XU
+5MsI+yMRQ+hDKXJioaldXgjUkK642M4UwtBV8ob2xJNDd2ZhwLnoQdeXeGADbkpy
+rqXRfboQnoZsG4q5WTP468SQvvG5
+-----END CERTIFICATE-----
+
+Amazon Root CA 2
+-----BEGIN CERTIFICATE-----
+MIIFQTCCAymgAwIBAgITBmyf0pY1hp8KD+WGePhbJruKNzANBgkqhkiG9w0BAQwF
+ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6
+b24gUm9vdCBDQSAyMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTEL
+MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJv
+b3QgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK2Wny2cSkxK
+gXlRmeyKy2tgURO8TW0G/LAIjd0ZEGrHJgw12MBvIITplLGbhQPDW9tK6Mj4kHbZ
+W0/jTOgGNk3Mmqw9DJArktQGGWCsN0R5hYGCrVo34A3MnaZMUnbqQ523BNFQ9lXg
+1dKmSYXpN+nKfq5clU1Imj+uIFptiJXZNLhSGkOQsL9sBbm2eLfq0OQ6PBJTYv9K
+8nu+NQWpEjTj82R0Yiw9AElaKP4yRLuH3WUnAnE72kr3H9rN9yFVkE8P7K6C4Z9r
+2UXTu/Bfh+08LDmG2j/e7HJV63mjrdvdfLC6HM783k81ds8P+HgfajZRRidhW+me
+z/CiVX18JYpvL7TFz4QuK/0NURBs+18bvBt+xa47mAExkv8LV/SasrlX6avvDXbR
+8O70zoan4G7ptGmh32n2M8ZpLpcTnqWHsFcQgTfJU7O7f/aS0ZzQGPSSbtqDT6Zj
+mUyl+17vIWR6IF9sZIUVyzfpYgwLKhbcAS4y2j5L9Z469hdAlO+ekQiG+r5jqFoz
+7Mt0Q5X5bGlSNscpb/xVA1wf+5+9R+vnSUeVC06JIglJ4PVhHvG/LopyboBZ/1c6
++XUyo05f7O0oYtlNc/LMgRdg7c3r3NunysV+Ar3yVAhU/bQtCSwXVEqY0VThUWcI
+0u1ufm8/0i2BWSlmy5A5lREedCf+3euvAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMB
+Af8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSwDPBMMPQFWAJI/TPlUq9LhONm
+UjANBgkqhkiG9w0BAQwFAAOCAgEAqqiAjw54o+Ci1M3m9Zh6O+oAA7CXDpO8Wqj2
+LIxyh6mx/H9z/WNxeKWHWc8w4Q0QshNabYL1auaAn6AFC2jkR2vHat+2/XcycuUY
++gn0oJMsXdKMdYV2ZZAMA3m3MSNjrXiDCYZohMr/+c8mmpJ5581LxedhpxfL86kS
+k5Nrp+gvU5LEYFiwzAJRGFuFjWJZY7attN6a+yb3ACfAXVU3dJnJUH/jWS5E4ywl
+7uxMMne0nxrpS10gxdr9HIcWxkPo1LsmmkVwXqkLN1PiRnsn/eBG8om3zEK2yygm
+btmlyTrIQRNg91CMFa6ybRoVGld45pIq2WWQgj9sAq+uEjonljYE1x2igGOpm/Hl
+urR8FLBOybEfdF849lHqm/osohHUqS0nGkWxr7JOcQ3AWEbWaQbLU8uz/mtBzUF+
+fUwPfHJ5elnNXkoOrJupmHN5fLT0zLm4BwyydFy4x2+IoZCn9Kr5v2c69BoVYh63
+n749sSmvZ6ES8lgQGVMDMBu4Gon2nL2XA46jCfMdiyHxtN/kHNGfZQIG6lzWE7OE
+76KlXIx3KadowGuuQNKotOrN8I1LOJwZmhsoVLiJkO/KdYE+HvJkJMcYr07/R54H
+9jVlpNMKVv/1F2Rs76giJUmTtt8AF9pYfl3uxRuw0dFfIRDH+fO6AgonB8Xx1sfT
+4PsJYGw=
+-----END CERTIFICATE-----
+
+Amazon Root CA 3
+-----BEGIN CERTIFICATE-----
+MIIBtjCCAVugAwIBAgITBmyf1XSXNmY/Owua2eiedgPySjAKBggqhkjOPQQDAjA5
+MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
+Um9vdCBDQSAzMB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
+A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
+Q0EgMzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCmXp8ZBf8ANm+gBG1bG8lKl
+ui2yEujSLtf6ycXYqm0fc4E7O5hrOXwzpcVOho6AF2hiRVd9RFgdszflZwjrZt6j
+QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBSr
+ttvXBp43rDCGB5Fwx5zEGbF4wDAKBggqhkjOPQQDAgNJADBGAiEA4IWSoxe3jfkr
+BqWTrBqYaGFy+uGh0PsceGCmQ5nFuMQCIQCcAu/xlJyzlvnrxir4tiz+OpAUFteM
+YyRIHN8wfdVoOw==
+-----END CERTIFICATE-----
+
+Amazon Root CA 4
+-----BEGIN CERTIFICATE-----
+MIIB8jCCAXigAwIBAgITBmyf18G7EEwpQ+Vxe3ssyBrBDjAKBggqhkjOPQQDAzA5
+MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g
+Um9vdCBDQSA0MB4XDTE1MDUyNjAwMDAwMFoXDTQwMDUyNjAwMDAwMFowOTELMAkG
+A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEZMBcGA1UEAxMQQW1hem9uIFJvb3Qg
+Q0EgNDB2MBAGByqGSM49AgEGBSuBBAAiA2IABNKrijdPo1MN/sGKe0uoe0ZLY7Bi
+9i0b2whxIdIA6GO9mif78DluXeo9pcmBqqNbIJhFXRbb/egQbeOc4OO9X4Ri83Bk
+M6DLJC9wuoihKqB1+IGuYgbEgds5bimwHvouXKNCMEAwDwYDVR0TAQH/BAUwAwEB
+/zAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYEFNPsxzplbszh2naaVvuc84ZtV+WB
+MAoGCCqGSM49BAMDA2gAMGUCMDqLIfG9fhGt0O9Yli/W651+kI0rz2ZVwyzjKKlw
+CkcO8DdZEv8tmZQoTipPNU0zWgIxAOp1AE47xDqUEpHJWEadIRNyp4iciuRMStuW
+1KyLa2tJElMzrdfkviT8tQp21KW8EA==
+-----END CERTIFICATE-----
+
+Atos TrustedRoot 2011
+-----BEGIN CERTIFICATE-----
+MIIDdzCCAl+gAwIBAgIIXDPLYixfszIwDQYJKoZIhvcNAQELBQAwPDEeMBwGA1UE
+AwwVQXRvcyBUcnVzdGVkUm9vdCAyMDExMQ0wCwYDVQQKDARBdG9zMQswCQYDVQQG
+EwJERTAeFw0xMTA3MDcxNDU4MzBaFw0zMDEyMzEyMzU5NTlaMDwxHjAcBgNVBAMM
+FUF0b3MgVHJ1c3RlZFJvb3QgMjAxMTENMAsGA1UECgwEQXRvczELMAkGA1UEBhMC
+REUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCVhTuXbyo7LjvPpvMp
+Nb7PGKw+qtn4TaA+Gke5vJrf8v7MPkfoepbCJI419KkM/IL9bcFyYie96mvr54rM
+VD6QUM+A1JX76LWC1BTFtqlVJVfbsVD2sGBkWXppzwO3bw2+yj5vdHLqqjAqc2K+
+SZFhyBH+DgMq92og3AIVDV4VavzjgsG1xZ1kCWyjWZgHJ8cblithdHFsQ/H3NYkQ
+4J7sVaE3IqKHBAUsR320HLliKWYoyrfhk/WklAOZuXCFteZI6o1Q/NnezG8HDt0L
+cp2AMBYHlT8oDv3FdU9T1nSatCQujgKRz3bFmx5VdJx4IbHwLfELn8LVlhgf8FQi
+eowHAgMBAAGjfTB7MB0GA1UdDgQWBBSnpQaxLKYJYO7Rl+lwrrw7GWzbITAPBgNV
+HRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFKelBrEspglg7tGX6XCuvDsZbNshMBgG
+A1UdIAQRMA8wDQYLKwYBBAGwLQMEAQEwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3
+DQEBCwUAA4IBAQAmdzTblEiGKkGdLD4GkGDEjKwLVLgfuXvTBznk+j57sj1O7Z8j
+vZfza1zv7v1Apt+hk6EKhqzvINB5Ab149xnYJDE0BAGmuhWawyfc2E8PzBhj/5kP
+DpFrdRbhIfzYJsdHt6bPWHJxfrrhTZVHO8mvbaG0weyJ9rQPOLXiZNwlz6bb65pc
+maHFCN795trV1lpFDMS3wrUU77QR/w4VtfX128a961qn8FYiqTxlVMYVqL2Gns2D
+lmh6cYGJ4Qvh6hEbaAjMaZ7snkGeRDImeuKHCnE96+RapNLbxc3G3mB/ufNPRJLv
+KrcYPqcZ2Qt9sTdBQrC6YB3y/gkRsPCHe6ed
+-----END CERTIFICATE-----
+
+Autoridad de Certificacion Firmaprofesional CIF A62634068
+-----BEGIN CERTIFICATE-----
+MIIGFDCCA/ygAwIBAgIIU+w77vuySF8wDQYJKoZIhvcNAQEFBQAwUTELMAkGA1UE
+BhMCRVMxQjBABgNVBAMMOUF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIEZpcm1h
+cHJvZmVzaW9uYWwgQ0lGIEE2MjYzNDA2ODAeFw0wOTA1MjAwODM4MTVaFw0zMDEy
+MzEwODM4MTVaMFExCzAJBgNVBAYTAkVTMUIwQAYDVQQDDDlBdXRvcmlkYWQgZGUg
+Q2VydGlmaWNhY2lvbiBGaXJtYXByb2Zlc2lvbmFsIENJRiBBNjI2MzQwNjgwggIi
+MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDKlmuO6vj78aI14H9M2uDDUtd9
+thDIAl6zQyrET2qyyhxdKJp4ERppWVevtSBC5IsP5t9bpgOSL/UR5GLXMnE42QQM
+cas9UX4PB99jBVzpv5RvwSmCwLTaUbDBPLutN0pcyvFLNg4kq7/DhHf9qFD0sefG
+L9ItWY16Ck6WaVICqjaY7Pz6FIMMNx/Jkjd/14Et5cS54D40/mf0PmbR0/RAz15i
+NA9wBj4gGFrO93IbJWyTdBSTo3OxDqqHECNZXyAFGUftaI6SEspd/NYrspI8IM/h
+X68gvqB2f3bl7BqGYTM+53u0P6APjqK5am+5hyZvQWyIplD9amML9ZMWGxmPsu2b
+m8mQ9QEM3xk9Dz44I8kvjwzRAv4bVdZO0I08r0+k8/6vKtMFnXkIoctXMbScyJCy
+Z/QYFpM6/EfY0XiWMR+6KwxfXZmtY4laJCB22N/9q06mIqqdXuYnin1oKaPnirja
+EbsXLZmdEyRG98Xi2J+Of8ePdG1asuhy9azuJBCtLxTa/y2aRnFHvkLfuwHb9H/T
+KI8xWVvTyQKmtFLKbpf7Q8UIJm+K9Lv9nyiqDdVF8xM6HdjAeI9BZzwelGSuewvF
+6NkBiDkal4ZkQdU7hwxu+g/GvUgUvzlN1J5Bto+WHWOWk9mVBngxaJ43BjuAiUVh
+OSPHG0SjFeUc+JIwuwIDAQABo4HvMIHsMBIGA1UdEwEB/wQIMAYBAf8CAQEwDgYD
+VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlzeurNR4APn7VdMActHNHDhpkLzCBpgYD
+VR0gBIGeMIGbMIGYBgRVHSAAMIGPMC8GCCsGAQUFBwIBFiNodHRwOi8vd3d3LmZp
+cm1hcHJvZmVzaW9uYWwuY29tL2NwczBcBggrBgEFBQcCAjBQHk4AUABhAHMAZQBv
+ACAAZABlACAAbABhACAAQgBvAG4AYQBuAG8AdgBhACAANAA3ACAAQgBhAHIAYwBl
+AGwAbwBuAGEAIAAwADgAMAAxADcwDQYJKoZIhvcNAQEFBQADggIBABd9oPm03cXF
+661LJLWhAqvdpYhKsg9VSytXjDvlMd3+xDLx51tkljYyGOylMnfX40S2wBEqgLk9
+am58m9Ot/MPWo+ZkKXzR4Tgegiv/J2Wv+xYVxC5xhOW1//qkR71kMrv2JYSiJ0L1
+ILDCExARzRAVukKQKtJE4ZYm6zFIEv0q2skGz3QeqUvVhyj5eTSSPi5E6PaPT481
+PyWzOdxjKpBrIF/EUhJOlywqrJ2X3kjyo2bbwtKDlaZmp54lD+kLM5FlClrD2VQS
+3a/DTg4fJl4N3LON7NWBcN7STyQF82xO9UxJZo3R/9ILJUFI/lGExkKvgATP0H5k
+SeTy36LssUzAKh3ntLFlosS88Zj0qnAHY7S42jtM+kAiMFsRpvAFDsYCA0irhpuF
+3dvd6qJ2gHN99ZwExEWN57kci57q13XRcrHedUTnQn3iV2t93Jm8PYMo6oCTjcVM
+ZcFwgbg4/EMxsvYDNEeyrPsiBsse3RdHHF9mudMaotoRsaS8I8nkvof/uZS2+F0g
+StRf571oe2XyFR7SOqkt6dhrJKyXWERHrVkY8SFlcN7ONGCoQPHzPKTDKCOM/icz
+Q0CgFzzr6juwcqajuUpLXhZI9LK8yIySxZ2frHI2vDSANGupi5LAuBft7HZT9SQB
+jLMi6Et8Vcad+qMUu2WFbm5PEn4KPJ2V
+-----END CERTIFICATE-----
+
+Baltimore CyberTrust Root
+-----BEGIN CERTIFICATE-----
+MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJ
+RTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYD
+VQQDExlCYWx0aW1vcmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoX
+DTI1MDUxMjIzNTkwMFowWjELMAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9y
+ZTETMBEGA1UECxMKQ3liZXJUcnVzdDEiMCAGA1UEAxMZQmFsdGltb3JlIEN5YmVy
+VHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKMEuyKr
+mD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2yguzmKiYv60iNoS6zjr
+IZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo6vWrJYeK
+mpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSu
+XmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZy
+dc93Uk3zyZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/ye
+jl0qhqdNkNwnGjkCAwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1
+BE3wMBIGA1UdEwEB/wQIMAYBAf8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3
+DQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27TyclhAO992T9Ldcw46QQF+vaKSm2eT92
+9hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukMJY2GQE/szKN+OMY3EU/t3Wgx
+jkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhSNzkE1akxehi/oCr0
+Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhz
+ksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS
+R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp
+-----END CERTIFICATE-----
+
+Buypass Class 2 Root CA
+-----BEGIN CERTIFICATE-----
+MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
+MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
+Q2xhc3MgMiBSb290IENBMB4XDTEwMTAyNjA4MzgwM1oXDTQwMTAyNjA4MzgwM1ow
+TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
+HgYDVQQDDBdCdXlwYXNzIENsYXNzIDIgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
+BQADggIPADCCAgoCggIBANfHXvfBB9R3+0Mh9PT1aeTuMgHbo4Yf5FkNuud1g1Lr
+6hxhFUi7HQfKjK6w3Jad6sNgkoaCKHOcVgb/S2TwDCo3SbXlzwx87vFKu3MwZfPV
+L4O2fuPn9Z6rYPnT8Z2SdIrkHJasW4DptfQxh6NR/Md+oW+OU3fUl8FVM5I+GC91
+1K2GScuVr1QGbNgGE41b/+EmGVnAJLqBcXmQRFBoJJRfuLMR8SlBYaNByyM21cHx
+MlAQTn/0hpPshNOOvEu/XAFOBz3cFIqUCqTqc/sLUegTBxj6DvEr0VQVfTzh97QZ
+QmdiXnfgolXsttlpF9U6r0TtSsWe5HonfOV116rLJeffawrbD02TTqigzXsu8lkB
+arcNuAeBfos4GzjmCleZPe4h6KP1DBbdi+w0jpwqHAAVF41og9JwnxgIzRFo1clr
+Us3ERo/ctfPYV3Me6ZQ5BL/T3jjetFPsaRyifsSP5BtwrfKi+fv3FmRmaZ9JUaLi
+FRhnBkp/1Wy1TbMz4GHrXb7pmA8y1x1LPC5aAVKRCfLf6o3YBkBjqhHk/sM3nhRS
+P/TizPJhk9H9Z2vXUq6/aKtAQ6BXNVN48FP4YUIHZMbXb5tMOA1jrGKvNouicwoN
+9SG9dKpN6nIDSdvHXx1iY8f93ZHsM+71bbRuMGjeyNYmsHVee7QHIJihdjK4TWxP
+AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMmAd+BikoL1Rpzz
+uvdMw964o605MA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAU18h
+9bqwOlI5LJKwbADJ784g7wbylp7ppHR/ehb8t/W2+xUbP6umwHJdELFx7rxP462s
+A20ucS6vxOOto70MEae0/0qyexAQH6dXQbLArvQsWdZHEIjzIVEpMMpghq9Gqx3t
+OluwlN5E40EIosHsHdb9T7bWR9AUC8rmyrV7d35BH16Dx7aMOZawP5aBQW9gkOLo
++fsicdl9sz1Gv7SEr5AcD48Saq/v7h56rgJKihcrdv6sVIkkLE8/trKnToyokZf7
+KcZ7XC25y2a2t6hbElGFtQl+Ynhw/qlqYLYdDnkM/crqJIByw5c/8nerQyIKx+u2
+DISCLIBrQYoIwOula9+ZEsuK1V6ADJHgJgg2SMX6OBE1/yWDLfJ6v9r9jv6ly0Us
+H8SIU653DtmadsWOLB2jutXsMq7Aqqz30XpN69QH4kj3Io6wpJ9qzo6ysmD0oyLQ
+I+uUWnpp3Q+/QFesa1lQ2aOZ4W7+jQF5JyMV3pKdewlNWudLSDBaGOYKbeaP4NK7
+5t98biGCwWg5TbSYWGZizEqQXsP6JwSxeRV0mcy+rSDeJmAc61ZRpqPq5KM/p/9h
+3PFaTWwyI0PurKju7koSCTxdccK+efrCh2gdC/1cacwG0Jp9VJkqyTkaGa9LKkPz
+Y11aWOIv4x3kqdbQCtCev9eBCfHJxyYNrJgWVqA=
+-----END CERTIFICATE-----
+
+Buypass Class 3 Root CA
+-----BEGIN CERTIFICATE-----
+MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEd
+MBsGA1UECgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3Mg
+Q2xhc3MgMyBSb290IENBMB4XDTEwMTAyNjA4Mjg1OFoXDTQwMTAyNjA4Mjg1OFow
+TjELMAkGA1UEBhMCTk8xHTAbBgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAw
+HgYDVQQDDBdCdXlwYXNzIENsYXNzIDMgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEB
+BQADggIPADCCAgoCggIBAKXaCpUWUOOV8l6ddjEGMnqb8RB2uACatVI2zSRHsJ8Y
+ZLya9vrVediQYkwiL944PdbgqOkcLNt4EemOaFEVcsfzM4fkoF0LXOBXByow9c3E
+N3coTRiR5r/VUv1xLXA+58bEiuPwKAv0dpihi4dVsjoT/Lc+JzeOIuOoTyrvYLs9
+tznDDgFHmV0ST9tD+leh7fmdvhFHJlsTmKtdFoqwNxxXnUX/iJY2v7vKB3tvh2PX
+0DJq1l1sDPGzbjniazEuOQAnFN44wOwZZoYS6J1yFhNkUsepNxz9gjDthBgd9K5c
+/3ATAOux9TN6S9ZV+AWNS2mw9bMoNlwUxFFzTWsL8TQH2xc519woe2v1n/MuwU8X
+KhDzzMro6/1rqy6any2CbgTUUgGTLT2G/H783+9CHaZr77kgxve9oKeV/afmiSTY
+zIw0bOIjL9kSGiG5VZFvC5F5GQytQIgLcOJ60g7YaEi7ghM5EFjp2CoHxhLbWNvS
+O1UQRwUVZ2J+GGOmRj8JDlQyXr8NYnon74Do29lLBlo3WiXQCBJ31G8JUJc9yB3D
+34xFMFbG02SrZvPAXpacw8Tvw3xrizp5f7NJzz3iiZ+gMEuFuZyUJHmPfWupRWgP
+K9Dx2hzLabjKSWJtyNBjYt1gD1iqj6G8BaVmos8bdrKEZLFMOVLAMLrwjEsCsLa3
+AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFEe4zf/lb+74suwv
+Tg75JbCOPGvDMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAACAj
+QTUEkMJAYmDv4jVM1z+s4jSQuKFvdvoWFqRINyzpkMLyPPgKn9iB5btb2iUspKdV
+cSQy9sgL8rxq+JOssgfCX5/bzMiKqr5qb+FJEMwx14C7u8jYog5kV+qi9cKpMRXS
+IGrs/CIBKM+GuIAeqcwRpTzyFrNHnfzSgCHEy9BHcEGhyoMZCCxt8l13nIoUE9Q2
+HJLw5QY33KbmkJs4j1xrG0aGQ0JfPgEHU1RdZX33inOhmlRaHylDFCfChQ+1iHsa
+O5S3HWCntZznKWlXWpuTekMwGwPXYshApqr8ZORK15FTAaggiG6cX0S5y2CBNOxv
+033aSF/rtJC8LakcC6wc1aJoIIAE1vyxjy+7SjENSoYc6+I2KSb12tjE8nVhz36u
+dmNKekBlk4f4HoCMhuWG1o8O/FMsYOgWYRqiPkN7zTlgVGr18okmAWiDSKIz6MkE
+kbIRNBE+6tBDGR8Dk5AM/1E9V/RBbuHLoL7ryWPNbczk+DaqaJ3tvV2XcEQNtg41
+3OEMXbugUZTLfhbrES+jkkXITHHZvMmZUldGL1DPvTVp9D0VzgalLA8+9oG6lLvD
+u79leNKGef9JOxqDDPDeeOzI8k1MGt6CKfjBWtrt7uYnXuhF0J0cUahoq0Tj0Itq
+4/g7u9xN12TyUb7mqqta6THuBrxzvxNiCp/HuZc=
+-----END CERTIFICATE-----
+
+CA Disig Root R2
+-----BEGIN CERTIFICATE-----
+MIIFaTCCA1GgAwIBAgIJAJK4iNuwisFjMA0GCSqGSIb3DQEBCwUAMFIxCzAJBgNV
+BAYTAlNLMRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMu
+MRkwFwYDVQQDExBDQSBEaXNpZyBSb290IFIyMB4XDTEyMDcxOTA5MTUzMFoXDTQy
+MDcxOTA5MTUzMFowUjELMAkGA1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmEx
+EzARBgNVBAoTCkRpc2lnIGEucy4xGTAXBgNVBAMTEENBIERpc2lnIFJvb3QgUjIw
+ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCio8QACdaFXS1tFPbCw3Oe
+NcJxVX6B+6tGUODBfEl45qt5WDza/3wcn9iXAng+a0EE6UG9vgMsRfYvZNSrXaNH
+PWSb6WiaxswbP7q+sos0Ai6YVRn8jG+qX9pMzk0DIaPY0jSTVpbLTAwAFjxfGs3I
+x2ymrdMxp7zo5eFm1tL7A7RBZckQrg4FY8aAamkw/dLukO8NJ9+flXP04SXabBbe
+QTg06ov80egEFGEtQX6sx3dOy1FU+16SGBsEWmjGycT6txOgmLcRK7fWV8x8nhfR
+yyX+hk4kLlYMeE2eARKmK6cBZW58Yh2EhN/qwGu1pSqVg8NTEQxzHQuyRpDRQjrO
+QG6Vrf/GlK1ul4SOfW+eioANSW1z4nuSHsPzwfPrLgVv2RvPN3YEyLRa5Beny912
+H9AZdugsBbPWnDTYltxhh5EF5EQIM8HauQhl1K6yNg3ruji6DOWbnuuNZt2Zz9aJ
+QfYEkoopKW1rOhzndX0CcQ7zwOe9yxndnWCywmZgtrEE7snmhrmaZkCo5xHtgUUD
+i/ZnWejBBhG93c+AAk9lQHhcR1DIm+YfgXvkRKhbhZri3lrVx/k6RGZL5DJUfORs
+nLMOPReisjQS1n6yqEm70XooQL6iFh/f5DcfEXP7kAplQ6INfPgGAVUzfbANuPT1
+rqVCV3w2EYx7XsQDnYx5nQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
+DwEB/wQEAwIBBjAdBgNVHQ4EFgQUtZn4r7CU9eMg1gqtzk5WpC5uQu0wDQYJKoZI
+hvcNAQELBQADggIBACYGXnDnZTPIgm7ZnBc6G3pmsgH2eDtpXi/q/075KMOYKmFM
+tCQSin1tERT3nLXK5ryeJ45MGcipvXrA1zYObYVybqjGom32+nNjf7xueQgcnYqf
+GopTpti72TVVsRHFqQOzVju5hJMiXn7B9hJSi+osZ7z+Nkz1uM/Rs0mSO9MpDpkb
+lvdhuDvEK7Z4bLQjb/D907JedR+Zlais9trhxTF7+9FGs9K8Z7RiVLoJ92Owk6Ka
++elSLotgEqv89WBW7xBci8QaQtyDW2QOy7W81k/BfDxujRNt+3vrMNDcTa/F1bal
+TFtxyegxvug4BkihGuLq0t4SOVga/4AOgnXmt8kHbA7v/zjxmHHEt38OFdAlab0i
+nSvtBfZGR6ztwPDUO+Ls7pZbkBNOHlY667DvlruWIxG68kOGdGSVyCh13x01utI3
+gzhTODY7z2zp+WsO0PsE6E9312UBeIYMej4hYvF/Y3EMyZ9E26gnonW+boE+18Dr
+G5gPcFw0sorMwIUY6256s/daoQe/qUKS82Ail+QUoQebTnbAjn39pCXHR+3/H3Os
+zMOl6W8KjptlwlCFtaOgUxLMVYdh84GuEEZhvUQhuMI9dM9+JDX6HAcOmz0iyu8x
+L4ysEr3vQCj8KWefshNPZiTEUxnpHikV7+ZtsH8tZ/3zbBt1RqPlShfppNcL
+-----END CERTIFICATE-----
+
+CFCA EV ROOT
+-----BEGIN CERTIFICATE-----
+MIIFjTCCA3WgAwIBAgIEGErM1jANBgkqhkiG9w0BAQsFADBWMQswCQYDVQQGEwJD
+TjEwMC4GA1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9y
+aXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJPT1QwHhcNMTIwODA4MDMwNzAxWhcNMjkx
+MjMxMDMwNzAxWjBWMQswCQYDVQQGEwJDTjEwMC4GA1UECgwnQ2hpbmEgRmluYW5j
+aWFsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJP
+T1QwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDXXWvNED8fBVnVBU03
+sQ7smCuOFR36k0sXgiFxEFLXUWRwFsJVaU2OFW2fvwwbwuCjZ9YMrM8irq93VCpL
+TIpTUnrD7i7es3ElweldPe6hL6P3KjzJIx1qqx2hp/Hz7KDVRM8Vz3IvHWOX6Jn5
+/ZOkVIBMUtRSqy5J35DNuF++P96hyk0g1CXohClTt7GIH//62pCfCqktQT+x8Rgp
+7hZZLDRJGqgG16iI0gNyejLi6mhNbiyWZXvKWfry4t3uMCz7zEasxGPrb382KzRz
+EpR/38wmnvFyXVBlWY9ps4deMm/DGIq1lY+wejfeWkU7xzbh72fROdOXW3NiGUgt
+hxwG+3SYIElz8AXSG7Ggo7cbcNOIabla1jj0Ytwli3i/+Oh+uFzJlU9fpy25IGvP
+a931DfSCt/SyZi4QKPaXWnuWFo8BGS1sbn85WAZkgwGDg8NNkt0yxoekN+kWzqot
+aK8KgWU6cMGbrU1tVMoqLUuFG7OA5nBFDWteNfB/O7ic5ARwiRIlk9oKmSJgamNg
+TnYGmE69g60dWIolhdLHZR4tjsbftsbhf4oEIRUpdPA+nJCdDC7xij5aqgwJHsfV
+PKPtl8MeNPo4+QgO48BdK4PRVmrJtqhUUy54Mmc9gn900PvhtgVguXDbjgv5E1hv
+cWAQUhC5wUEJ73IfZzF4/5YFjQIDAQABo2MwYTAfBgNVHSMEGDAWgBTj/i39KNAL
+tbq2osS/BqoFjJP7LzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd
+BgNVHQ4EFgQU4/4t/SjQC7W6tqLEvwaqBYyT+y8wDQYJKoZIhvcNAQELBQADggIB
+ACXGumvrh8vegjmWPfBEp2uEcwPenStPuiB/vHiyz5ewG5zz13ku9Ui20vsXiObT
+ej/tUxPQ4i9qecsAIyjmHjdXNYmEwnZPNDatZ8POQQaIxffu2Bq41gt/UP+TqhdL
+jOztUmCypAbqTuv0axn96/Ua4CUqmtzHQTb3yHQFhDmVOdYLO6Qn+gjYXB74BGBS
+ESgoA//vU2YApUo0FmZ8/Qmkrp5nGm9BC2sGE5uPhnEFtC+NiWYzKXZUmhH4J/qy
+P5Hgzg0b8zAarb8iXRvTvyUFTeGSGn+ZnzxEk8rUQElsgIfXBDrDMlI1Dlb4pd19
+xIsNER9Tyx6yF7Zod1rg1MvIB671Oi6ON7fQAUtDKXeMOZePglr4UeWJoBjnaH9d
+Ci77o0cOPaYjesYBx4/IXr9tgFa+iiS6M+qf4TIRnvHST4D2G0CvOJ4RUHlzEhLN
+5mydLIhyPDCBBpEi6lmt2hkuIsKNuYyH4Ga8cyNfIWRjgEj1oDwYPZTISEEdQLpe
+/v5WOaHIz16eGWRGENoXkbcFgKyLmZJ956LYBws2J+dIeWCKw9cTXPhyQN9Ky8+Z
+AAoACxGV2lZFA4gKn2fQ1XmxqI1AbQ3CekD6819kR5LLU7m7Wc5P/dAVUwHY3+vZ
+5nbv0CO7O6l5s9UCKc2Jo5YPSjXnTkLAdc0Hz+Ys63su
+-----END CERTIFICATE-----
+
+COMODO Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIEHTCCAwWgAwIBAgIQToEtioJl4AsC7j41AkblPTANBgkqhkiG9w0BAQUFADCB
+gTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
+A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxJzAlBgNV
+BAMTHkNPTU9ETyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjEyMDEwMDAw
+MDBaFw0yOTEyMzEyMzU5NTlaMIGBMQswCQYDVQQGEwJHQjEbMBkGA1UECBMSR3Jl
+YXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxmb3JkMRowGAYDVQQKExFDT01P
+RE8gQ0EgTGltaXRlZDEnMCUGA1UEAxMeQ09NT0RPIENlcnRpZmljYXRpb24gQXV0
+aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0ECLi3LjkRv3
+UcEbVASY06m/weaKXTuH+7uIzg3jLz8GlvCiKVCZrts7oVewdFFxze1CkU1B/qnI
+2GqGd0S7WWaXUF601CxwRM/aN5VCaTwwxHGzUvAhTaHYujl8HJ6jJJ3ygxaYqhZ8
+Q5sVW7euNJH+1GImGEaaP+vB+fGQV+useg2L23IwambV4EajcNxo2f8ESIl33rXp
++2dtQem8Ob0y2WIC8bGoPW43nOIv4tOiJovGuFVDiOEjPqXSJDlqR6sA1KGzqSX+
+DT+nHbrTUcELpNqsOO9VUCQFZUaTNE8tja3G1CEZ0o7KBWFxB3NH5YoZEr0ETc5O
+nKVIrLsm9wIDAQABo4GOMIGLMB0GA1UdDgQWBBQLWOWLxkwVN6RAqTCpIb5HNlpW
+/zAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zBJBgNVHR8EQjBAMD6g
+PKA6hjhodHRwOi8vY3JsLmNvbW9kb2NhLmNvbS9DT01PRE9DZXJ0aWZpY2F0aW9u
+QXV0aG9yaXR5LmNybDANBgkqhkiG9w0BAQUFAAOCAQEAPpiem/Yb6dc5t3iuHXIY
+SdOH5EOC6z/JqvWote9VfCFSZfnVDeFs9D6Mk3ORLgLETgdxb8CPOGEIqB6BCsAv
+IC9Bi5HcSEW88cbeunZrM8gALTFGTO3nnc+IlP8zwFboJIYmuNg4ON8qa90SzMc/
+RxdMosIGlgnW2/4/PEZB31jiVg88O8EckzXZOFKs7sjsLjBOlDW0JB9LeGna8gI4
+zJVSk/BwJVmcIGfE7vmLV2H0knZ9P4SNVbfo5azV8fUZVqZa+5Acr5Pr5RzUZ5dd
+BA6+C4OmF4O5MBKgxTMVBbkN+8cFduPYSo38NBejxiEovjBFMR7HeL5YYTisO+IB
+ZQ==
+-----END CERTIFICATE-----
+
+COMODO ECC Certification Authority
+-----BEGIN CERTIFICATE-----
+MIICiTCCAg+gAwIBAgIQH0evqmIAcFBUTAGem2OZKjAKBggqhkjOPQQDAzCBhTEL
+MAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UE
+BxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMT
+IkNPTU9ETyBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwMzA2MDAw
+MDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdy
+ZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09N
+T0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0MgQ2VydGlmaWNhdGlv
+biBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQDR3svdcmCFYX7deSR
+FtSrYpn1PlILBs5BAH+X4QokPB0BBO490o0JlwzgdeT6+3eKKvUDYEs2ixYjFq0J
+cfRK9ChQtP6IHG4/bC8vCVlbpVsLM5niwz2J+Wos77LTBumjQjBAMB0GA1UdDgQW
+BBR1cacZSBm8nZ3qQUfflMRId5nTeTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
+BAUwAwEB/zAKBggqhkjOPQQDAwNoADBlAjEA7wNbeqy3eApyt4jf/7VGFAkK+qDm
+fQjGGoe9GKhzvSbKYAydzpmfz1wPMOG+FDHqAjAU9JM8SaczepBGR7NjfRObTrdv
+GDeAU/7dIOA1mjbRxwG55tzd8/8dLDoWV9mSOdY=
+-----END CERTIFICATE-----
+
+COMODO RSA Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB
+hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
+A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV
+BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5
+MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT
+EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR
+Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh
+dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR
+6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X
+pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC
+9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV
+/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf
+Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z
++pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w
+qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah
+SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC
+u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf
+Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq
+crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E
+FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB
+/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl
+wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM
+4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV
+2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna
+FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ
+CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK
+boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke
+jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL
+S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb
+QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl
+0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB
+NVOFBkpdn627G190
+-----END CERTIFICATE-----
+
+Certigna
+-----BEGIN CERTIFICATE-----
+MIIDqDCCApCgAwIBAgIJAP7c4wEPyUj/MA0GCSqGSIb3DQEBBQUAMDQxCzAJBgNV
+BAYTAkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hMB4X
+DTA3MDYyOTE1MTMwNVoXDTI3MDYyOTE1MTMwNVowNDELMAkGA1UEBhMCRlIxEjAQ
+BgNVBAoMCURoaW15b3RpczERMA8GA1UEAwwIQ2VydGlnbmEwggEiMA0GCSqGSIb3
+DQEBAQUAA4IBDwAwggEKAoIBAQDIaPHJ1tazNHUmgh7stL7qXOEm7RFHYeGifBZ4
+QCHkYJ5ayGPhxLGWkv8YbWkj4Sti993iNi+RB7lIzw7sebYs5zRLcAglozyHGxny
+gQcPOJAZ0xH+hrTy0V4eHpbNgGzOOzGTtvKg0KmVEn2lmsxryIRWijOp5yIVUxbw
+zBfsV1/pogqYCd7jX5xv3EjjhQsVWqa6n6xI4wmy9/Qy3l40vhx4XUJbzg4ij02Q
+130yGLMLLGq/jj8UEYkgDncUtT2UCIf3JR7VsmAA7G8qKCVuKj4YYxclPz5EIBb2
+JsglrgVKtOdjLPOMFlN+XPsRGgjBRmKfIrjxwo1p3Po6WAbfAgMBAAGjgbwwgbkw
+DwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUGu3+QTmQtCRZvgHyUtVF9lo53BEw
+ZAYDVR0jBF0wW4AUGu3+QTmQtCRZvgHyUtVF9lo53BGhOKQ2MDQxCzAJBgNVBAYT
+AkZSMRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hggkA/tzj
+AQ/JSP8wDgYDVR0PAQH/BAQDAgEGMBEGCWCGSAGG+EIBAQQEAwIABzANBgkqhkiG
+9w0BAQUFAAOCAQEAhQMeknH2Qq/ho2Ge6/PAD/Kl1NqV5ta+aDY9fm4fTIrv0Q8h
+bV6lUmPOEvjvKtpv6zf+EwLHyzs+ImvaYS5/1HI93TDhHkxAGYwP15zRgzB7mFnc
+fca5DClMoTOi62c6ZYTTluLtdkVwj7Ur3vkj1kluPBS1xp81HlDQwY9qcEQCYsuu
+HWhBp6pX6FOqB9IG9tUUBguRA3UsbHK1YZWaDYu5Def131TN3ubY1gkIl2PlwS6w
+t0QmwCbAr1UwnjvVNioZBPRcHv/PLLf/0P2HQBHVESO7SMAhqaQoLf0V+LBOK/Qw
+WyH8EZE0vkHve52Xdf+XlcCWWC/qu0bXu+TZLg==
+-----END CERTIFICATE-----
+
+Certigna Root CA
+-----BEGIN CERTIFICATE-----
+MIIGWzCCBEOgAwIBAgIRAMrpG4nxVQMNo+ZBbcTjpuEwDQYJKoZIhvcNAQELBQAw
+WjELMAkGA1UEBhMCRlIxEjAQBgNVBAoMCURoaW15b3RpczEcMBoGA1UECwwTMDAw
+MiA0ODE0NjMwODEwMDAzNjEZMBcGA1UEAwwQQ2VydGlnbmEgUm9vdCBDQTAeFw0x
+MzEwMDEwODMyMjdaFw0zMzEwMDEwODMyMjdaMFoxCzAJBgNVBAYTAkZSMRIwEAYD
+VQQKDAlEaGlteW90aXMxHDAaBgNVBAsMEzAwMDIgNDgxNDYzMDgxMDAwMzYxGTAX
+BgNVBAMMEENlcnRpZ25hIFJvb3QgQ0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw
+ggIKAoICAQDNGDllGlmx6mQWDoyUJJV8g9PFOSbcDO8WV43X2KyjQn+Cyu3NW9sO
+ty3tRQgXstmzy9YXUnIo245Onoq2C/mehJpNdt4iKVzSs9IGPjA5qXSjklYcoW9M
+CiBtnyN6tMbaLOQdLNyzKNAT8kxOAkmhVECe5uUFoC2EyP+YbNDrihqECB63aCPu
+I9Vwzm1RaRDuoXrC0SIxwoKF0vJVdlB8JXrJhFwLrN1CTivngqIkicuQstDuI7pm
+TLtipPlTWmR7fJj6o0ieD5Wupxj0auwuA0Wv8HT4Ks16XdG+RCYyKfHx9WzMfgIh
+C59vpD++nVPiz32pLHxYGpfhPTc3GGYo0kDFUYqMwy3OU4gkWGQwFsWq4NYKpkDf
+ePb1BHxpE4S80dGnBs8B92jAqFe7OmGtBIyT46388NtEbVncSVmurJqZNjBBe3Yz
+IoejwpKGbvlw7q6Hh5UbxHq9MfPU0uWZ/75I7HX1eBYdpnDBfzwboZL7z8g81sWT
+Co/1VTp2lc5ZmIoJlXcymoO6LAQ6l73UL77XbJuiyn1tJslV1c/DeVIICZkHJC1k
+JWumIWmbat10TWuXekG9qxf5kBdIjzb5LdXF2+6qhUVB+s06RbFo5jZMm5BX7CO5
+hwjCxAnxl4YqKE3idMDaxIzb3+KhF1nOJFl0Mdp//TBt2dzhauH8XwIDAQABo4IB
+GjCCARYwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
+FBiHVuBud+4kNTxOc5of1uHieX4rMB8GA1UdIwQYMBaAFBiHVuBud+4kNTxOc5of
+1uHieX4rMEQGA1UdIAQ9MDswOQYEVR0gADAxMC8GCCsGAQUFBwIBFiNodHRwczov
+L3d3d3cuY2VydGlnbmEuZnIvYXV0b3JpdGVzLzBtBgNVHR8EZjBkMC+gLaArhilo
+dHRwOi8vY3JsLmNlcnRpZ25hLmZyL2NlcnRpZ25hcm9vdGNhLmNybDAxoC+gLYYr
+aHR0cDovL2NybC5kaGlteW90aXMuY29tL2NlcnRpZ25hcm9vdGNhLmNybDANBgkq
+hkiG9w0BAQsFAAOCAgEAlLieT/DjlQgi581oQfccVdV8AOItOoldaDgvUSILSo3L
+6btdPrtcPbEo/uRTVRPPoZAbAh1fZkYJMyjhDSSXcNMQH+pkV5a7XdrnxIxPTGRG
+HVyH41neQtGbqH6mid2PHMkwgu07nM3A6RngatgCdTer9zQoKJHyBApPNeNgJgH6
+0BGM+RFq7q89w1DTj18zeTyGqHNFkIwgtnJzFyO+B2XleJINugHA64wcZr+shncB
+lA2c5uk5jR+mUYyZDDl34bSb+hxnV29qao6pK0xXeXpXIs/NX2NGjVxZOob4Mkdi
+o2cNGJHc+6Zr9UhhcyNZjgKnvETq9Emd8VRY+WCv2hikLyhF3HqgiIZd8zvn/yk1
+gPxkQ5Tm4xxvvq0OKmOZK8l+hfZx6AYDlf7ej0gcWtSS6Cvu5zHbugRqh5jnxV/v
+faci9wHYTfmJ0A6aBVmknpjZbyvKcL5kwlWj9Omvw5Ip3IgWJJk8jSaYtlu3zM63
+Nwf9JtmYhST/WSMDmu2dnajkXjjO11INb9I/bbEFa0nOipFGc/T2L/Coc3cOZayh
+jWZSaX5LaAzHHjcng6WMxwLkFM1JAbBzs/3GkDpv0mztO+7skb6iQ12LAEpmJURw
+3kAP+HwV96LOPNdeE4yBFxgX0b3xdxA61GU5wSesVywlVP+i2k+KYTlerj1KjL0=
+-----END CERTIFICATE-----
+
+Certum EC-384 CA
+-----BEGIN CERTIFICATE-----
+MIICZTCCAeugAwIBAgIQeI8nXIESUiClBNAt3bpz9DAKBggqhkjOPQQDAzB0MQsw
+CQYDVQQGEwJQTDEhMB8GA1UEChMYQXNzZWNvIERhdGEgU3lzdGVtcyBTLkEuMScw
+JQYDVQQLEx5DZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxGTAXBgNVBAMT
+EENlcnR1bSBFQy0zODQgQ0EwHhcNMTgwMzI2MDcyNDU0WhcNNDMwMzI2MDcyNDU0
+WjB0MQswCQYDVQQGEwJQTDEhMB8GA1UEChMYQXNzZWNvIERhdGEgU3lzdGVtcyBT
+LkEuMScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxGTAX
+BgNVBAMTEENlcnR1bSBFQy0zODQgQ0EwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATE
+KI6rGFtqvm5kN2PkzeyrOvfMobgOgknXhimfoZTy42B4mIF4Bk3y7JoOV2CDn7Tm
+Fy8as10CW4kjPMIRBSqniBMY81CE1700LCeJVf/OTOffph8oxPBUw7l8t1Ot68Kj
+QjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI0GZnQkdjrzife81r1HfS+8
+EF9LMA4GA1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNoADBlAjADVS2m5hjEfO/J
+UG7BJw+ch69u1RsIGL2SKcHvlJF40jocVYli5RsJHrpka/F2tNQCMQC0QoSZ/6vn
+nvuRlydd3LBbMHHOXjgaatkl5+r3YZJW+OraNsKHZZYuciUvf9/DE8k=
+-----END CERTIFICATE-----
+
+Certum Trusted Network CA
+-----BEGIN CERTIFICATE-----
+MIIDuzCCAqOgAwIBAgIDBETAMA0GCSqGSIb3DQEBBQUAMH4xCzAJBgNVBAYTAlBM
+MSIwIAYDVQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBTLkEuMScwJQYDVQQLEx5D
+ZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxIjAgBgNVBAMTGUNlcnR1bSBU
+cnVzdGVkIE5ldHdvcmsgQ0EwHhcNMDgxMDIyMTIwNzM3WhcNMjkxMjMxMTIwNzM3
+WjB+MQswCQYDVQQGEwJQTDEiMCAGA1UEChMZVW5pemV0byBUZWNobm9sb2dpZXMg
+Uy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSIw
+IAYDVQQDExlDZXJ0dW0gVHJ1c3RlZCBOZXR3b3JrIENBMIIBIjANBgkqhkiG9w0B
+AQEFAAOCAQ8AMIIBCgKCAQEA4/t9o3K6wvDJFIf1awFO4W5AB7ptJ11/91sts1rH
+UV+rpDKmYYe2bg+G0jACl/jXaVehGDldamR5xgFZrDwxSjh80gTSSyjoIF87B6LM
+TXPb865Px1bVWqeWifrzq2jUI4ZZJ88JJ7ysbnKDHDBy3+Ci6dLhdHUZvSqeexVU
+BBvXQzmtVSjF4hq79MDkrjhJM8x2hZ85RdKknvISjFH4fOQtf/WsX+sWn7Et0brM
+kUJ3TCXJkDhv2/DM+44el1k+1WBO5gUo7Ul5E0u6SNsv+XLTOcr+H9g0cvW0QM8x
+AcPs3hEtF10fuFDRXhmnad4HMyjKUJX5p1TLVIZQRan5SQIDAQABo0IwQDAPBgNV
+HRMBAf8EBTADAQH/MB0GA1UdDgQWBBQIds3LB/8k9sXN7buQvOKEN0Z19zAOBgNV
+HQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBAKaorSLOAT2mo/9i0Eidi15y
+sHhE49wcrwn9I0j6vSrEuVUEtRCjjSfeC4Jj0O7eDDd5QVsisrCaQVymcODU0HfL
+I9MA4GxWL+FpDQ3Zqr8hgVDZBqWo/5U30Kr+4rP1mS1FhIrlQgnXdAIv94nYmem8
+J9RHjboNRhx3zxSkHLmkMcScKHQDNP8zGSal6Q10tz6XxnboJ5ajZt3hrvJBW8qY
+VoNzcOSGGtIxQbovvi0TWnZvTuhOgQ4/WwMioBK+ZlgRSssDxLQqKi2WF+A5VLxI
+03YnnZotBqbJ7DnSq9ufmgsnAjUpsUCV5/nonFWIGUbWtzT1fs45mtk48VH3Tyw=
+-----END CERTIFICATE-----
+
+Certum Trusted Network CA 2
+-----BEGIN CERTIFICATE-----
+MIIF0jCCA7qgAwIBAgIQIdbQSk8lD8kyN/yqXhKN6TANBgkqhkiG9w0BAQ0FADCB
+gDELMAkGA1UEBhMCUEwxIjAgBgNVBAoTGVVuaXpldG8gVGVjaG5vbG9naWVzIFMu
+QS4xJzAlBgNVBAsTHkNlcnR1bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEkMCIG
+A1UEAxMbQ2VydHVtIFRydXN0ZWQgTmV0d29yayBDQSAyMCIYDzIwMTExMDA2MDgz
+OTU2WhgPMjA0NjEwMDYwODM5NTZaMIGAMQswCQYDVQQGEwJQTDEiMCAGA1UEChMZ
+VW5pemV0byBUZWNobm9sb2dpZXMgUy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRp
+ZmljYXRpb24gQXV0aG9yaXR5MSQwIgYDVQQDExtDZXJ0dW0gVHJ1c3RlZCBOZXR3
+b3JrIENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC9+Xj45tWA
+DGSdhhuWZGc/IjoedQF97/tcZ4zJzFxrqZHmuULlIEub2pt7uZld2ZuAS9eEQCsn
+0+i6MLs+CRqnSZXvK0AkwpfHp+6bJe+oCgCXhVqqndwpyeI1B+twTUrWwbNWuKFB
+OJvR+zF/j+Bf4bE/D44WSWDXBo0Y+aomEKsq09DRZ40bRr5HMNUuctHFY9rnY3lE
+fktjJImGLjQ/KUxSiyqnwOKRKIm5wFv5HdnnJ63/mgKXwcZQkpsCLL2puTRZCr+E
+Sv/f/rOf69me4Jgj7KZrdxYq28ytOxykh9xGc14ZYmhFV+SQgkK7QtbwYeDBoz1m
+o130GO6IyY0XRSmZMnUCMe4pJshrAua1YkV/NxVaI2iJ1D7eTiew8EAMvE0Xy02i
+sx7QBlrd9pPPV3WZ9fqGGmd4s7+W/jTcvedSVuWz5XV710GRBdxdaeOVDUO5/IOW
+OZV7bIBaTxNyxtd9KXpEulKkKtVBRgkg/iKgtlswjbyJDNXXcPiHUv3a76xRLgez
+Tv7QCdpw75j6VuZt27VXS9zlLCUVyJ4ueE742pyehizKV/Ma5ciSixqClnrDvFAS
+adgOWkaLOusm+iPJtrCBvkIApPjW/jAux9JG9uWOdf3yzLnQh1vMBhBgu4M1t15n
+3kfsmUjxpKEV/q2MYo45VU85FrmxY53/twIDAQABo0IwQDAPBgNVHRMBAf8EBTAD
+AQH/MB0GA1UdDgQWBBS2oVQ5AsOgP46KvPrU+Bym0ToO/TAOBgNVHQ8BAf8EBAMC
+AQYwDQYJKoZIhvcNAQENBQADggIBAHGlDs7k6b8/ONWJWsQCYftMxRQXLYtPU2sQ
+F/xlhMcQSZDe28cmk4gmb3DWAl45oPePq5a1pRNcgRRtDoGCERuKTsZPpd1iHkTf
+CVn0W3cLN+mLIMb4Ck4uWBzrM9DPhmDJ2vuAL55MYIR4PSFk1vtBHxgP58l1cb29
+XN40hz5BsA72udY/CROWFC/emh1auVbONTqwX3BNXuMp8SMoclm2q8KMZiYcdywm
+djWLKKdpoPk79SPdhRB0yZADVpHnr7pH1BKXESLjokmUbOe3lEu6LaTaM4tMpkT/
+WjzGHWTYtTHkpjx6qFcL2+1hGsvxznN3Y6SHb0xRONbkX8eftoEq5IVIeVheO/jb
+AoJnwTnbw3RLPTYe+SmTiGhbqEQZIfCn6IENLOiTNrQ3ssqwGyZ6miUfmpqAnksq
+P/ujmv5zMnHCnsZy4YpoJ/HkD7TETKVhk/iXEAcqMCWpuchxuO9ozC1+9eB+D4Ko
+b7a6bINDd82Kkhehnlt4Fj1F4jNy3eFmypnTycUm/Q1oBEauttmbjL4ZvrHG8hnj
+XALKLNhvSgfZyTXaQHXyxKcZb55CEJh15pWLYLztxRLXis7VmFxWlgPF7ncGNf/P
+5O4/E2Hu29othfDNrp2yGAlFw5Khchf8R7agCyzxxN5DaAhqXzvwdmP7zAYspsbi
+DrW5viSP
+-----END CERTIFICATE-----
+
+Certum Trusted Root CA
+-----BEGIN CERTIFICATE-----
+MIIFwDCCA6igAwIBAgIQHr9ZULjJgDdMBvfrVU+17TANBgkqhkiG9w0BAQ0FADB6
+MQswCQYDVQQGEwJQTDEhMB8GA1UEChMYQXNzZWNvIERhdGEgU3lzdGVtcyBTLkEu
+MScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkxHzAdBgNV
+BAMTFkNlcnR1bSBUcnVzdGVkIFJvb3QgQ0EwHhcNMTgwMzE2MTIxMDEzWhcNNDMw
+MzE2MTIxMDEzWjB6MQswCQYDVQQGEwJQTDEhMB8GA1UEChMYQXNzZWNvIERhdGEg
+U3lzdGVtcyBTLkEuMScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlmaWNhdGlvbiBBdXRo
+b3JpdHkxHzAdBgNVBAMTFkNlcnR1bSBUcnVzdGVkIFJvb3QgQ0EwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQDRLY67tzbqbTeRn06TpwXkKQMlzhyC93yZ
+n0EGze2jusDbCSzBfN8pfktlL5On1AFrAygYo9idBcEq2EXxkd7fO9CAAozPOA/q
+p1x4EaTByIVcJdPTsuclzxFUl6s1wB52HO8AU5853BSlLCIls3Jy/I2z5T4IHhQq
+NwuIPMqw9MjCoa68wb4pZ1Xi/K1ZXP69VyywkI3C7Te2fJmItdUDmj0VDT06qKhF
+8JVOJVkdzZhpu9PMMsmN74H+rX2Ju7pgE8pllWeg8xn2A1bUatMn4qGtg/BKEiJ3
+HAVz4hlxQsDsdUaakFjgao4rpUYwBI4Zshfjvqm6f1bxJAPXsiEodg42MEx51UGa
+mqi4NboMOvJEGyCI98Ul1z3G4z5D3Yf+xOr1Uz5MZf87Sst4WmsXXw3Hw09Omiqi
+7VdNIuJGmj8PkTQkfVXjjJU30xrwCSss0smNtA0Aq2cpKNgB9RkEth2+dv5yXMSF
+ytKAQd8FqKPVhJBPC/PgP5sZ0jeJP/J7UhyM9uH3PAeXjA6iWYEMspA90+NZRu0P
+qafegGtaqge2Gcu8V/OXIXoMsSt0Puvap2ctTMSYnjYJdmZm/Bo/6khUHL4wvYBQ
+v3y1zgD2DGHZ5yQD4OMBgQ692IU0iL2yNqh7XAjlRICMb/gv1SHKHRzQ+8S1h9E6
+Tsd2tTVItQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSM+xx1
+vALTn04uSNn5YFSqxLNP+jAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQENBQAD
+ggIBAEii1QALLtA/vBzVtVRJHlpr9OTy4EA34MwUe7nJ+jW1dReTagVphZzNTxl4
+WxmB82M+w85bj/UvXgF2Ez8sALnNllI5SW0ETsXpD4YN4fqzX4IS8TrOZgYkNCvo
+zMrnadyHncI013nR03e4qllY/p0m+jiGPp2Kh2RX5Rc64vmNueMzeMGQ2Ljdt4NR
+5MTMI9UGfOZR0800McD2RrsLrfw9EAUqO0qRJe6M1ISHgCq8CYyqOhNf6DR5UMEQ
+GfnTKB7U0VEwKbOukGfWHwpjscWpxkIxYxeU72nLL/qMFH3EQxiJ2fAyQOaA4kZf
+5ePBAFmo+eggvIksDkc0C+pXwlM2/KfUrzHN/gLldfq5Jwn58/U7yn2fqSLLiMmq
+0Uc9NneoWWRrJ8/vJ8HjJLWG965+Mk2weWjROeiQWMODvA8s1pfrzgzhIMfatz7D
+P78v3DSk+yshzWePS/Tj6tQ/50+6uaWTRRxmHyH6ZF5v4HaUMst19W7l9o/HuKTM
+qJZ9ZPskWkoDbGs4xugDQ5r3V7mzKWmTOPQD8rv7gmsHINFSH5pkAnuYZttcTVoP
+0ISVoDwUQwbKytu4QTbaakRnh6+v40URFWkIsr4WOZckbxJF0WddCajJFdr60qZf
+E2Efv4WstK2tBZQIgx51F9NxO5NQI1mg7TyRVJ12AMXDuDjb
+-----END CERTIFICATE-----
+
+Comodo AAA Services root
+-----BEGIN CERTIFICATE-----
+MIIEMjCCAxqgAwIBAgIBATANBgkqhkiG9w0BAQUFADB7MQswCQYDVQQGEwJHQjEb
+MBkGA1UECAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRow
+GAYDVQQKDBFDb21vZG8gQ0EgTGltaXRlZDEhMB8GA1UEAwwYQUFBIENlcnRpZmlj
+YXRlIFNlcnZpY2VzMB4XDTA0MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowezEL
+MAkGA1UEBhMCR0IxGzAZBgNVBAgMEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UE
+BwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2RvIENBIExpbWl0ZWQxITAfBgNVBAMM
+GEFBQSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIwDQYJKoZIhvcNAQEBBQADggEP
+ADCCAQoCggEBAL5AnfRu4ep2hxxNRUSOvkbIgwadwSr+GB+O5AL686tdUIoWMQua
+BtDFcCLNSS1UY8y2bmhGC1Pqy0wkwLxyTurxFa70VJoSCsN6sjNg4tqJVfMiWPPe
+3M/vg4aijJRPn2jymJBGhCfHdr/jzDUsi14HZGWCwEiwqJH5YZ92IFCokcdmtet4
+YgNW8IoaE+oxox6gmf049vYnMlhvB/VruPsUK6+3qszWY19zjNoFmag4qMsXeDZR
+rOme9Hg6jc8P2ULimAyrL58OAd7vn5lJ8S3frHRNG5i1R8XlKdH5kBjHYpy+g8cm
+ez6KJcfA3Z3mNWgQIJ2P2N7Sw4ScDV7oL8kCAwEAAaOBwDCBvTAdBgNVHQ4EFgQU
+oBEKIz6W8Qfs4q8p74Klf9AwpLQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQF
+MAMBAf8wewYDVR0fBHQwcjA4oDagNIYyaHR0cDovL2NybC5jb21vZG9jYS5jb20v
+QUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNqA0oDKGMGh0dHA6Ly9jcmwuY29t
+b2RvLm5ldC9BQUFDZXJ0aWZpY2F0ZVNlcnZpY2VzLmNybDANBgkqhkiG9w0BAQUF
+AAOCAQEACFb8AvCb6P+k+tZ7xkSAzk/ExfYAWMymtrwUSWgEdujm7l3sAg9g1o1Q
+GE8mTgHj5rCl7r+8dFRBv/38ErjHT1r0iWAFf2C3BUrz9vHCv8S5dIa2LX1rzNLz
+Rt0vxuBqw8M0Ayx9lt1awg6nCpnBBYurDC/zXDrPbDdVCYfeU0BsWO/8tqtlbgT2
+G9w84FoVxp7Z8VlIMCFlA2zs6SFz7JsDoeA3raAVGI/6ugLOpyypEBMs1OUIJqsi
+l2D4kF501KKaU73yqWjgom7C12yxow+ev+to51byrvLjKzg6CYG1a4XXvi3tPxq3
+smPi9WIsgtRqAEFQ8TmDn5XpNpaYbg==
+-----END CERTIFICATE-----
+
+Cybertrust Global Root
+-----BEGIN CERTIFICATE-----
+MIIDoTCCAomgAwIBAgILBAAAAAABD4WqLUgwDQYJKoZIhvcNAQEFBQAwOzEYMBYG
+A1UEChMPQ3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2Jh
+bCBSb290MB4XDTA2MTIxNTA4MDAwMFoXDTIxMTIxNTA4MDAwMFowOzEYMBYGA1UE
+ChMPQ3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBS
+b290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA+Mi8vRRQZhP/8NN5
+7CPytxrHjoXxEnOmGaoQ25yiZXRadz5RfVb23CO21O1fWLE3TdVJDm71aofW0ozS
+J8bi/zafmGWgE07GKmSb1ZASzxQG9Dvj1Ci+6A74q05IlG2OlTEQXO2iLb3VOm2y
+HLtgwEZLAfVJrn5GitB0jaEMAs7u/OePuGtm839EAL9mJRQr3RAwHQeWP032a7iP
+t3sMpTjr3kfb1V05/Iin89cqdPHoWqI7n1C6poxFNcJQZZXcY4Lv3b93TZxiyWNz
+FtApD0mpSPCzqrdsxacwOUBdrsTiXSZT8M4cIwhhqJQZugRiQOwfOHB3EgZxpzAY
+XSUnpQIDAQABo4GlMIGiMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/
+MB0GA1UdDgQWBBS2CHsNesysIEyGVjJez6tuhS1wVzA/BgNVHR8EODA2MDSgMqAw
+hi5odHRwOi8vd3d3Mi5wdWJsaWMtdHJ1c3QuY29tL2NybC9jdC9jdHJvb3QuY3Js
+MB8GA1UdIwQYMBaAFLYIew16zKwgTIZWMl7Pq26FLXBXMA0GCSqGSIb3DQEBBQUA
+A4IBAQBW7wojoFROlZfJ+InaRcHUowAl9B8Tq7ejhVhpwjCt2BWKLePJzYFa+HMj
+Wqd8BfP9IjsO0QbE2zZMcwSO5bAi5MXzLqXZI+O4Tkogp24CJJ8iYGd7ix1yCcUx
+XOl5n4BHPa2hCwcUPUf/A2kaDAtE52Mlp3+yybh2hO0j9n0Hq0V+09+zv+mKts2o
+omcrUtW3ZfA5TGOgkXmTUg9U3YO7n9GPp1Nzw8v/MOx8BLjYRB+TX3EJIrduPuoc
+A06dGiBh+4E37F78CkWr1+cXVdCg6mCbpvbjjFspwgZgFJ0tl0ypkxWdYcQBX0jW
+WL1WMRJOEcgh4LMRkWXbtKaIOM5V
+-----END CERTIFICATE-----
+
+D-TRUST Root Class 3 CA 2 2009
+-----BEGIN CERTIFICATE-----
+MIIEMzCCAxugAwIBAgIDCYPzMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNVBAYTAkRF
+MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBD
+bGFzcyAzIENBIDIgMjAwOTAeFw0wOTExMDUwODM1NThaFw0yOTExMDUwODM1NTha
+ME0xCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMM
+HkQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgMjAwOTCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBANOySs96R+91myP6Oi/WUEWJNTrGa9v+2wBoqOADER03
+UAifTUpolDWzU9GUY6cgVq/eUXjsKj3zSEhQPgrfRlWLJ23DEE0NkVJD2IfgXU42
+tSHKXzlABF9bfsyjxiupQB7ZNoTWSPOSHjRGICTBpFGOShrvUD9pXRl/RcPHAY9R
+ySPocq60vFYJfxLLHLGvKZAKyVXMD9O0Gu1HNVpK7ZxzBCHQqr0ME7UAyiZsxGsM
+lFqVlNpQmvH/pStmMaTJOKDfHR+4CS7zp+hnUquVH+BGPtikw8paxTGA6Eian5Rp
+/hnd2HN8gcqW3o7tszIFZYQ05ub9VxC1X3a/L7AQDcUCAwEAAaOCARowggEWMA8G
+A1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFP3aFMSfMN4hvR5COfyrYyNJ4PGEMA4G
+A1UdDwEB/wQEAwIBBjCB0wYDVR0fBIHLMIHIMIGAoH6gfIZ6bGRhcDovL2RpcmVj
+dG9yeS5kLXRydXN0Lm5ldC9DTj1ELVRSVVNUJTIwUm9vdCUyMENsYXNzJTIwMyUy
+MENBJTIwMiUyMDIwMDksTz1ELVRydXN0JTIwR21iSCxDPURFP2NlcnRpZmljYXRl
+cmV2b2NhdGlvbmxpc3QwQ6BBoD+GPWh0dHA6Ly93d3cuZC10cnVzdC5uZXQvY3Js
+L2QtdHJ1c3Rfcm9vdF9jbGFzc18zX2NhXzJfMjAwOS5jcmwwDQYJKoZIhvcNAQEL
+BQADggEBAH+X2zDI36ScfSF6gHDOFBJpiBSVYEQBrLLpME+bUMJm2H6NMLVwMeni
+acfzcNsgFYbQDfC+rAF1hM5+n02/t2A7nPPKHeJeaNijnZflQGDSNiH+0LS4F9p0
+o3/U37CYAqxva2ssJSRyoWXuJVrl5jLn8t+rSfrzkGkj2wTZ51xY/GXUl77M/C4K
+zCUqNQT4YJEVdT1B/yMfGchs64JTBKbkTCJNjYy6zltz7GRUUG3RnFX7acM2w4y8
+PIWmawomDeCTmGCufsYkl4phX5GOZpIJhzbNi5stPvZR1FDUWSi9g/LMKHtThm3Y
+Johw1+qRzT65ysCQblrGXnRl11z+o+I=
+-----END CERTIFICATE-----
+
+D-TRUST Root Class 3 CA 2 EV 2009
+-----BEGIN CERTIFICATE-----
+MIIEQzCCAyugAwIBAgIDCYP0MA0GCSqGSIb3DQEBCwUAMFAxCzAJBgNVBAYTAkRF
+MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBD
+bGFzcyAzIENBIDIgRVYgMjAwOTAeFw0wOTExMDUwODUwNDZaFw0yOTExMDUwODUw
+NDZaMFAxCzAJBgNVBAYTAkRFMRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNV
+BAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIgRVYgMjAwOTCCASIwDQYJKoZI
+hvcNAQEBBQADggEPADCCAQoCggEBAJnxhDRwui+3MKCOvXwEz75ivJn9gpfSegpn
+ljgJ9hBOlSJzmY3aFS3nBfwZcyK3jpgAvDw9rKFs+9Z5JUut8Mxk2og+KbgPCdM0
+3TP1YtHhzRnp7hhPTFiu4h7WDFsVWtg6uMQYZB7jM7K1iXdODL/ZlGsTl28So/6Z
+qQTMFexgaDbtCHu39b+T7WYxg4zGcTSHThfqr4uRjRxWQa4iN1438h3Z0S0NL2lR
+p75mpoo6Kr3HGrHhFPC+Oh25z1uxav60sUYgovseO3Dvk5h9jHOW8sXvhXCtKSb8
+HgQ+HKDYD8tSg2J87otTlZCpV6LqYQXY+U3EJ/pure3511H3a6UCAwEAAaOCASQw
+ggEgMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNOUikxiEyoZLsyvcop9Ntea
+HNxnMA4GA1UdDwEB/wQEAwIBBjCB3QYDVR0fBIHVMIHSMIGHoIGEoIGBhn9sZGFw
+Oi8vZGlyZWN0b3J5LmQtdHJ1c3QubmV0L0NOPUQtVFJVU1QlMjBSb290JTIwQ2xh
+c3MlMjAzJTIwQ0ElMjAyJTIwRVYlMjAyMDA5LE89RC1UcnVzdCUyMEdtYkgsQz1E
+RT9jZXJ0aWZpY2F0ZXJldm9jYXRpb25saXN0MEagRKBChkBodHRwOi8vd3d3LmQt
+dHJ1c3QubmV0L2NybC9kLXRydXN0X3Jvb3RfY2xhc3NfM19jYV8yX2V2XzIwMDku
+Y3JsMA0GCSqGSIb3DQEBCwUAA4IBAQA07XtaPKSUiO8aEXUHL7P+PPoeUSbrh/Yp
+3uDx1MYkCenBz1UbtDDZzhr+BlGmFaQt77JLvyAoJUnRpjZ3NOhk31KxEcdzes05
+nsKtjHEh8lprr988TlWvsoRlFIm5d8sqMb7Po23Pb0iUMkZv53GMoKaEGTcH8gNF
+CSuGdXzfX2lXANtu2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7na
+xpeG0ILD5EJt/rDiZE4OJudANCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqX
+KVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjmJuVvw9y4AyHqnxbxLFS1
+-----END CERTIFICATE-----
+
+DST Root CA X3
+-----BEGIN CERTIFICATE-----
+MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/
+MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT
+DkRTVCBSb290IENBIFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVow
+PzEkMCIGA1UEChMbRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQD
+Ew5EU1QgUm9vdCBDQSBYMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
+AN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdAwRgUi+DoM3ZJKuM/IUmTrE4O
+rz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwGMoOifooUMM0RoOEq
+OLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4XLh7dIN9b
+xiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw
+7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaD
+aeQQmxkqtilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNV
+HQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqG
+SIb3DQEBBQUAA4IBAQCjGiybFwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69
+ikugdB/OEIKcdBodfpga3csTS7MgROSR6cz8faXbauX+5v3gTt23ADq1cEmv8uXr
+AvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaLbumR9YbK+rlmM6pZW87ipxZz
+R8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir/md2cXjbDaJWFBM5
+JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06XyxV3bqxbYo
+Ob8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ
+-----END CERTIFICATE-----
+
+DigiCert Assured ID Root CA
+-----BEGIN CERTIFICATE-----
+MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBl
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv
+b3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQG
+EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl
+cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwggEi
+MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOAXLGH87dg+XESpa7c
+JpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lTXDGEKvYP
+mDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+
+wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4
+VYcgoc/lbQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/
+AUaG9ih5yLHa5FcXxH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMB
+AAGjYzBhMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQW
+BBRF66Kv9JLLgjEtUYunpyGd823IDzAfBgNVHSMEGDAWgBRF66Kv9JLLgjEtUYun
+pyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog683+Lt8ONyc3pklL/3cmbYMuRC
+dWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqoR+pWxnmrEthngYTf
+fwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+fT8r87cm
+NW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx
+H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe
++o0bJW1sj6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==
+-----END CERTIFICATE-----
+
+DigiCert Assured ID Root G2
+-----BEGIN CERTIFICATE-----
+MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBl
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJv
+b3QgRzIwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQG
+EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNl
+cnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwggEi
+MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82ckmIkzTz+GoeMVSA
+n61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxNEP4Htecc
+biJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp
+EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lA
+bx3RvpO704gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6Yu
+YjOuFgJ3RFrngQo8p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMB
+AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQW
+BBTOw0q5mVXyuNtgv6l+vVa1lzan1jANBgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPI
+QW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTUiaWxMTeKySHMq2zNixya1r9I
+0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LRdWLjSisCx1BL4Gni
+lmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70CjTVW0z9
+B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv
+ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwo
+IhNzbM8m9Yop5w==
+-----END CERTIFICATE-----
+
+DigiCert Assured ID Root G3
+-----BEGIN CERTIFICATE-----
+MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQsw
+CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu
+ZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3Qg
+RzMwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJV
+UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
+Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwdjAQBgcq
+hkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0FFfLvC/8QdJ+1YlJf
+Zn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+CW7if17Q
+RSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
+BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQD
+AwNnADBkAjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlY
+JjZ91eQ0hjkCMHw2U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv
+6pZjamVFkpUBtA==
+-----END CERTIFICATE-----
+
+DigiCert Global Root CA
+-----BEGIN CERTIFICATE-----
+MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD
+QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT
+MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
+b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG
+9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB
+CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97
+nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
+43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P
+T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4
+gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO
+BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR
+TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw
+DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr
+hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg
+06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF
+PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
+YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk
+CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
+-----END CERTIFICATE-----
+
+DigiCert Global Root G2
+-----BEGIN CERTIFICATE-----
+MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBh
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH
+MjAeFw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVT
+MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
+b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEcyMIIBIjANBgkqhkiG
+9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/RrohCgiN9RlUyfuI
+2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxpsMNzaHxmx
+1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ
+q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5Wz
+tCO7TG1F8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQ
+vIOlCsRnKPZzFBQ9RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAP
+BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV
+5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcNAQELBQADggEBAGBnKJRvDkhj6zHd6mcY
+1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVnNeyIv/iPsGEMNKSuIEyExtv4
+NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2ZL7tcu7XUIOGZX1NG
+Fdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUTFy8bJZ91
+8rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe
+pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTfl
+MrY=
+-----END CERTIFICATE-----
+
+DigiCert Global Root G3
+-----BEGIN CERTIFICATE-----
+MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQsw
+CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu
+ZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAe
+Fw0xMzA4MDExMjAwMDBaFw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUw
+EwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20x
+IDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IEczMHYwEAYHKoZIzj0CAQYF
+K4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu80JX28MzQC7phW1FG
+fp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6Ip6FrtUPO
+Z9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd
+BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIx
+AK288mw/EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/
+oAIwOWZbwmSNuJ5Q3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8
+sycX
+-----END CERTIFICATE-----
+
+DigiCert High Assurance EV Root CA
+-----BEGIN CERTIFICATE-----
+MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBs
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j
+ZSBFViBSb290IENBMB4XDTA2MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDEL
+MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3
+LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug
+RVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMbM5XPm
++9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlBWTrT3JTW
+PNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM
+xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFB
+Ik5lYYeBQVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3
+hzBWBOURtCmAEvF5OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsg
+EsxBu24LUTi4S8sCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQF
+MAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9HAdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaA
+FLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3DQEBBQUAA4IBAQAcGgaX3Nec
+nzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1ntlMMUu4kehDLI6z
+eM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VHMWEZ71jF
+hS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2
+Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCe
+vEsXCS+0yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep
++OkuE6N36B9K
+-----END CERTIFICATE-----
+
+DigiCert Trusted Root G4
+-----BEGIN CERTIFICATE-----
+MIIFkDCCA3igAwIBAgIQBZsbV56OITLiOQe9p3d1XDANBgkqhkiG9w0BAQwFADBi
+MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
+d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3Qg
+RzQwHhcNMTMwODAxMTIwMDAwWhcNMzgwMTE1MTIwMDAwWjBiMQswCQYDVQQGEwJV
+UzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
+Y29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQC/5pBzaN675F1KPDAiMGkz7MKnJS7JIT3y
+ithZwuEppz1Yq3aaza57G4QNxDAf8xukOBbrVsaXbR2rsnnyyhHS5F/WBTxSD1If
+xp4VpX6+n6lXFllVcq9ok3DCsrp1mWpzMpTREEQQLt+C8weE5nQ7bXHiLQwb7iDV
+ySAdYyktzuxeTsiT+CFhmzTrBcZe7FsavOvJz82sNEBfsXpm7nfISKhmV1efVFiO
+DCu3T6cw2Vbuyntd463JT17lNecxy9qTXtyOj4DatpGYQJB5w3jHtrHEtWoYOAMQ
+jdjUN6QuBX2I9YI+EJFwq1WCQTLX2wRzKm6RAXwhTNS8rhsDdV14Ztk6MUSaM0C/
+CNdaSaTC5qmgZ92kJ7yhTzm1EVgX9yRcRo9k98FpiHaYdj1ZXUJ2h4mXaXpI8OCi
+EhtmmnTK3kse5w5jrubU75KSOp493ADkRSWJtppEGSt+wJS00mFt6zPZxd9LBADM
+fRyVw4/3IbKyEbe7f/LVjHAsQWCqsWMYRJUadmJ+9oCw++hkpjPRiQfhvbfmQ6QY
+uKZ3AeEPlAwhHbJUKSWJbOUOUlFHdL4mrLZBdd56rF+NP8m800ERElvlEFDrMcXK
+chYiCd98THU/Y+whX8QgUWtvsauGi0/C1kVfnSD8oR7FwI+isX4KJpn15GkvmB0t
+9dmpsh3lGwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
+hjAdBgNVHQ4EFgQU7NfjgtJxXWRM3y5nP+e6mK4cD08wDQYJKoZIhvcNAQEMBQAD
+ggIBALth2X2pbL4XxJEbw6GiAI3jZGgPVs93rnD5/ZpKmbnJeFwMDF/k5hQpVgs2
+SV1EY+CtnJYYZhsjDT156W1r1lT40jzBQ0CuHVD1UvyQO7uYmWlrx8GnqGikJ9yd
++SeuMIW59mdNOj6PWTkiU0TryF0Dyu1Qen1iIQqAyHNm0aAFYF/opbSnr6j3bTWc
+fFqK1qI4mfN4i/RN0iAL3gTujJtHgXINwBQy7zBZLq7gcfJW5GqXb5JQbZaNaHqa
+sjYUegbyJLkJEVDXCLG4iXqEI2FCKeWjzaIgQdfRnGTZ6iahixTXTBmyUEFxPT9N
+cCOGDErcgdLMMpSEDQgJlxxPwO5rIHQw0uA5NBCFIRUBCOhVMt5xSdkoF1BN5r5N
+0XWs0Mr7QbhDparTwwVETyw2m+L64kW4I1NsBm9nVX9GtUw/bihaeSbSpKhil9Ie
+4u1Ki7wb/UdKDd9nZn6yW0HQO+T0O/QEY+nvwlQAUaCKKsnOeMzV6ocEGLPOr0mI
+r/OSmbaz5mEP0oUA51Aa5BuVnRmhuZyxm7EAHu/QD09CbMkKvO5D+jpxpchNJqU1
+/YldvIViHTLSoCtU7ZpXwdv6EM8Zt4tKG48BtieVU+i2iW1bvGjUI+iLUaJW+fCm
+gKDWHrO8Dw9TdSmq6hN35N6MgSGtBxBHEa2HPQfRdbzP82Z+
+-----END CERTIFICATE-----
+
+E-Tugra Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIGSzCCBDOgAwIBAgIIamg+nFGby1MwDQYJKoZIhvcNAQELBQAwgbIxCzAJBgNV
+BAYTAlRSMQ8wDQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBC
+aWxpxZ9pbSBUZWtub2xvamlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNV
+BAsMHUUtVHVncmEgU2VydGlmaWthc3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1
+Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTEzMDMwNTEyMDk0OFoXDTIz
+MDMwMzEyMDk0OFowgbIxCzAJBgNVBAYTAlRSMQ8wDQYDVQQHDAZBbmthcmExQDA+
+BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtub2xvamlsZXJpIHZlIEhp
+em1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlmaWthc3lvbiBN
+ZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5
+MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4vU/kwVRHoViVF56C/UY
+B4Oufq9899SKa6VjQzm5S/fDxmSJPZQuVIBSOTkHS0vdhQd2h8y/L5VMzH2nPbxH
+D5hw+IyFHnSOkm0bQNGZDbt1bsipa5rAhDGvykPL6ys06I+XawGb1Q5KCKpbknSF
+Q9OArqGIW66z6l7LFpp3RMih9lRozt6Plyu6W0ACDGQXwLWTzeHxE2bODHnv0ZEo
+q1+gElIwcxmOj+GMB6LDu0rw6h8VqO4lzKRG+Bsi77MOQ7osJLjFLFzUHPhdZL3D
+k14opz8n8Y4e0ypQBaNV2cvnOVPAmJ6MVGKLJrD3fY185MaeZkJVgkfnsliNZvcH
+fC425lAcP9tDJMW/hkd5s3kc91r0E+xs+D/iWR+V7kI+ua2oMoVJl0b+SzGPWsut
+dEcf6ZG33ygEIqDUD13ieU/qbIWGvaimzuT6w+Gzrt48Ue7LE3wBf4QOXVGUnhMM
+ti6lTPk5cDZvlsouDERVxcr6XQKj39ZkjFqzAQqptQpHF//vkUAqjqFGOjGY5RH8
+zLtJVor8udBhmm9lbObDyz51Sf6Pp+KJxWfXnUYTTjF2OySznhFlhqt/7x3U+Lzn
+rFpct1pHXFXOVbQicVtbC/DP3KBhZOqp12gKY6fgDT+gr9Oq0n7vUaDmUStVkhUX
+U8u3Zg5mTPj5dUyQ5xJwx0UCAwEAAaNjMGEwHQYDVR0OBBYEFC7j27JJ0JxUeVz6
+Jyr+zE7S6E5UMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAULuPbsknQnFR5
+XPonKv7MTtLoTlQwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAF
+Nzr0TbdF4kV1JI+2d1LoHNgQk2Xz8lkGpD4eKexd0dCrfOAKkEh47U6YA5n+KGCR
+HTAduGN8qOY1tfrTYXbm1gdLymmasoR6d5NFFxWfJNCYExL/u6Au/U5Mh/jOXKqY
+GwXgAEZKgoClM4so3O0409/lPun++1ndYYRP0lSWE2ETPo+Aab6TR7U1Q9Jauz1c
+77NCR807VRMGsAnb/WP2OogKmW9+4c4bU2pEZiNRCHu8W1Ki/QY3OEBhj0qWuJA3
++GbHeJAAFS6LrVE1Uweoa2iu+U48BybNCAVwzDk/dr2l02cmAYamU9JgO3xDf1WK
+vJUawSg5TB9D0pH0clmKuVb8P7Sd2nCcdlqMQ1DujjByTd//SffGqWfZbawCEeI6
+FiWnWAjLb1NBnEg4R2gz0dfHj9R0IdTDBZB6/86WiLEVKV0jq9BgoRJP3vQXzTLl
+yb/IQ639Lo7xr+L0mPoSHyDYwKcMhcWQ9DstliaxLL5Mq+ux0orJ23gTDx4JnW2P
+AJ8C2sH6H3p6CcRK5ogql5+Ji/03X186zjhZhkuvcQu02PJwT58yE+Owp1fl2tpD
+y4Q08ijE6m30Ku/Ba3ba+367hTzSU8JNvnHhRdH9I2cNE3X7z2VnIp2usAnRCf8d
+NL/+I5c30jn6PQ0GC7TbO6Orb1wdtn7os4I07QZcJA==
+-----END CERTIFICATE-----
+
+EC-ACC
+-----BEGIN CERTIFICATE-----
+MIIFVjCCBD6gAwIBAgIQ7is969Qh3hSoYqwE893EATANBgkqhkiG9w0BAQUFADCB
+8zELMAkGA1UEBhMCRVMxOzA5BgNVBAoTMkFnZW5jaWEgQ2F0YWxhbmEgZGUgQ2Vy
+dGlmaWNhY2lvIChOSUYgUS0wODAxMTc2LUkpMSgwJgYDVQQLEx9TZXJ2ZWlzIFB1
+YmxpY3MgZGUgQ2VydGlmaWNhY2lvMTUwMwYDVQQLEyxWZWdldSBodHRwczovL3d3
+dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAoYykwMzE1MDMGA1UECxMsSmVyYXJxdWlh
+IEVudGl0YXRzIGRlIENlcnRpZmljYWNpbyBDYXRhbGFuZXMxDzANBgNVBAMTBkVD
+LUFDQzAeFw0wMzAxMDcyMzAwMDBaFw0zMTAxMDcyMjU5NTlaMIHzMQswCQYDVQQG
+EwJFUzE7MDkGA1UEChMyQWdlbmNpYSBDYXRhbGFuYSBkZSBDZXJ0aWZpY2FjaW8g
+KE5JRiBRLTA4MDExNzYtSSkxKDAmBgNVBAsTH1NlcnZlaXMgUHVibGljcyBkZSBD
+ZXJ0aWZpY2FjaW8xNTAzBgNVBAsTLFZlZ2V1IGh0dHBzOi8vd3d3LmNhdGNlcnQu
+bmV0L3ZlcmFycmVsIChjKTAzMTUwMwYDVQQLEyxKZXJhcnF1aWEgRW50aXRhdHMg
+ZGUgQ2VydGlmaWNhY2lvIENhdGFsYW5lczEPMA0GA1UEAxMGRUMtQUNDMIIBIjAN
+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsyLHT+KXQpWIR4NA9h0X84NzJB5R
+85iKw5K4/0CQBXCHYMkAqbWUZRkiFRfCQ2xmRJoNBD45b6VLeqpjt4pEndljkYRm
+4CgPukLjbo73FCeTae6RDqNfDrHrZqJyTxIThmV6PttPB/SnCWDaOkKZx7J/sxaV
+HMf5NLWUhdWZXqBIoH7nF2W4onW4HvPlQn2v7fOKSGRdghST2MDk/7NQcvJ29rNd
+QlB50JQ+awwAvthrDk4q7D7SzIKiGGUzE3eeml0aE9jD2z3Il3rucO2n5nzbcc8t
+lGLfbdb1OL4/pYUKGbio2Al1QnDE6u/LDsg0qBIimAy4E5S2S+zw0JDnJwIDAQAB
+o4HjMIHgMB0GA1UdEQQWMBSBEmVjX2FjY0BjYXRjZXJ0Lm5ldDAPBgNVHRMBAf8E
+BTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUoMOLRKo3pUW/l4Ba0fF4
+opvpXY0wfwYDVR0gBHgwdjB0BgsrBgEEAfV4AQMBCjBlMCwGCCsGAQUFBwIBFiBo
+dHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbDA1BggrBgEFBQcCAjApGidW
+ZWdldSBodHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAwDQYJKoZIhvcN
+AQEFBQADggEBAKBIW4IB9k1IuDlVNZyAelOZ1Vr/sXE7zDkJlF7W2u++AVtd0x7Y
+/X1PzaBB4DSTv8vihpw3kpBWHNzrKQXlxJ7HNd+KDM3FIUPpqojlNcAZQmNaAl6k
+SBg6hW/cnbw/nZzBh7h6YQjpdwt/cKt63dmXLGQehb+8dJahw3oS7AwaboMMPOhy
+Rp/7SNVel+axofjk70YllJyJ22k4vuxcDlbHZVHlUIiIv0LVKz3l+bqeLrPK9HOS
+Agu+TGbrIP65y7WZf+a2E/rKS03Z7lNGBjvGTq2TWoF+bCpLagVFjPIhpDGQh2xl
+nJ2lYJU6Un/10asIbvPuW/mIPX64b24D5EI=
+-----END CERTIFICATE-----
+
+Entrust
+-----BEGIN CERTIFICATE-----
+MIIEKjCCAxKgAwIBAgIEOGPe+DANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChML
+RW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBp
+bmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5
+IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRp
+ZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw05OTEyMjQxNzUwNTFaFw0yOTA3
+MjQxNDE1MTJaMIG0MRQwEgYDVQQKEwtFbnRydXN0Lm5ldDFAMD4GA1UECxQ3d3d3
+LmVudHJ1c3QubmV0L0NQU18yMDQ4IGluY29ycC4gYnkgcmVmLiAobGltaXRzIGxp
+YWIuKTElMCMGA1UECxMcKGMpIDE5OTkgRW50cnVzdC5uZXQgTGltaXRlZDEzMDEG
+A1UEAxMqRW50cnVzdC5uZXQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgKDIwNDgp
+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArU1LqRKGsuqjIAcVFmQq
+K0vRvwtKTY7tgHalZ7d4QMBzQshowNtTK91euHaYNZOLGp18EzoOH1u3Hs/lJBQe
+sYGpjX24zGtLA/ECDNyrpUAkAH90lKGdCCmziAv1h3edVc3kw37XamSrhRSGlVuX
+MlBvPci6Zgzj/L24ScF2iUkZ/cCovYmjZy/Gn7xxGWC4LeksyZB2ZnuU4q941mVT
+XTzWnLLPKQP5L6RQstRIzgUyVYr9smRMDuSYB3Xbf9+5CFVghTAp+XtIpGmG4zU/
+HoZdenoVve8AjhUiVBcAkCaTvA5JaJG/+EfTnZVCwQ5N328mz8MYIWJmQ3DW1cAH
+4QIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
+HQ4EFgQUVeSB0RGAvtiJuQijMfmhJAkWuXAwDQYJKoZIhvcNAQEFBQADggEBADub
+j1abMOdTmXx6eadNl9cZlZD7Bh/KM3xGY4+WZiT6QBshJ8rmcnPyT/4xmf3IDExo
+U8aAghOY+rat2l098c5u9hURlIIM7j+VrxGrD9cv3h8Dj1csHsm7mhpElesYT6Yf
+zX1XEC+bBAlahLVu2B064dae0Wx5XnkcFMXj0EyTO2U87d89vqbllRrDtRnDvV5b
+u/8j72gZyxKTJ1wDLW8w0B62GqzeWvfRqqgnpv55gcR5mTNXuhKwqeBCbJPKVt7+
+bYQLCIt+jerXmCHG8+c8eS9enNFMFY3h7CI3zJpDC5fcgJCNs2ebb0gIFVbPv/Er
+fF6adulZkMV8gzURZVE=
+-----END CERTIFICATE-----
+
+Entrust Root Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC
+VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0
+Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW
+KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl
+cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw
+NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw
+NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy
+ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV
+BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ
+KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo
+Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4
+4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9
+KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI
+rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi
+94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB
+sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi
+gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo
+kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE
+vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA
+A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t
+O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua
+AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP
+9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/
+eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m
+0vdXcDazv/wor3ElhVsT/h5/WrQ8
+-----END CERTIFICATE-----
+
+Entrust Root Certification Authority - EC1
+-----BEGIN CERTIFICATE-----
+MIIC+TCCAoCgAwIBAgINAKaLeSkAAAAAUNCR+TAKBggqhkjOPQQDAzCBvzELMAkG
+A1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3
+d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEyIEVu
+dHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UEAxMq
+RW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRUMxMB4XDTEy
+MTIxODE1MjUzNloXDTM3MTIxODE1NTUzNlowgb8xCzAJBgNVBAYTAlVTMRYwFAYD
+VQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1c3QubmV0
+L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxMiBFbnRydXN0LCBJbmMuIC0g
+Zm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMzAxBgNVBAMTKkVudHJ1c3QgUm9vdCBD
+ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEVDMTB2MBAGByqGSM49AgEGBSuBBAAi
+A2IABIQTydC6bUF74mzQ61VfZgIaJPRbiWlH47jCffHyAsWfoPZb1YsGGYZPUxBt
+ByQnoaD41UcZYUx9ypMn6nQM72+WCf5j7HBdNq1nd67JnXxVRDqiY1Ef9eNi1KlH
+Bz7MIKNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O
+BBYEFLdj5xrdjekIplWDpOBqUEFlEUJJMAoGCCqGSM49BAMDA2cAMGQCMGF52OVC
+R98crlOZF7ZvHH3hvxGU0QOIdeSNiaSKd0bebWHvAvX7td/M/k7//qnmpwIwW5nX
+hTcGtXsI/esni0qU+eH6p44mCOh8kmhtc9hvJqwhAriZtyZBWyVgrtBIGu4G
+-----END CERTIFICATE-----
+
+Entrust Root Certification Authority - G2
+-----BEGIN CERTIFICATE-----
+MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMC
+VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50
+cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3Qs
+IEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVz
+dCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcy
+NTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVu
+dHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwt
+dGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0
+aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj
+YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
+AoIBAQC6hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/T
+RU4cctZOMvJyig/3gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWN
+cCG0szLni6LVhjkCsbjSR87kyUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hW
+wcKUs/Ja5CeanyTXxuzQmyWC48zCxEXFjJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1
+U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+tVOxMyLlbc9wPBr64ptntoP0
+jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAP
+BgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2fkBJmqzAN
+BgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/
+jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZ
+Rkfz6/djwUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v
+1fN2D807iDginWyTmsQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4R
+nAuknZoh8/CbCzB428Hch0P+vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmH
+VHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ19xOe4pIb4tF9g==
+-----END CERTIFICATE-----
+
+Entrust Root Certification Authority - G4
+-----BEGIN CERTIFICATE-----
+MIIGSzCCBDOgAwIBAgIRANm1Q3+vqTkPAAAAAFVlrVgwDQYJKoZIhvcNAQELBQAw
+gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL
+Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg
+MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw
+BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0
+MB4XDTE1MDUyNzExMTExNloXDTM3MTIyNzExNDExNlowgb4xCzAJBgNVBAYTAlVT
+MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1
+c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNSBFbnRydXN0LCBJ
+bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAwBgNVBAMTKUVudHJ1c3Qg
+Um9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0MIICIjANBgkqhkiG9w0B
+AQEFAAOCAg8AMIICCgKCAgEAsewsQu7i0TD/pZJH4i3DumSXbcr3DbVZwbPLqGgZ
+2K+EbTBwXX7zLtJTmeH+H17ZSK9dE43b/2MzTdMAArzE+NEGCJR5WIoV3imz/f3E
+T+iq4qA7ec2/a0My3dl0ELn39GjUu9CH1apLiipvKgS1sqbHoHrmSKvS0VnM1n4j
+5pds8ELl3FFLFUHtSUrJ3hCX1nbB76W1NhSXNdh4IjVS70O92yfbYVaCNNzLiGAM
+C1rlLAHGVK/XqsEQe9IFWrhAnoanw5CGAlZSCXqc0ieCU0plUmr1POeo8pyvi73T
+DtTUXm6Hnmo9RR3RXRv06QqsYJn7ibT/mCzPfB3pAqoEmh643IhuJbNsZvc8kPNX
+wbMv9W3y+8qh+CmdRouzavbmZwe+LGcKKh9asj5XxNMhIWNlUpEbsZmOeX7m640A
+2Vqq6nPopIICR5b+W45UYaPrL0swsIsjdXJ8ITzI9vF01Bx7owVV7rtNOzK+mndm
+nqxpkCIHH2E6lr7lmk/MBTwoWdPBDFSoWWG9yHJM6Nyfh3+9nEg2XpWjDrk4JFX8
+dWbrAuMINClKxuMrLzOg2qOGpRKX/YAr2hRC45K9PvJdXmd0LhyIRyk0X+IyqJwl
+N4y6mACXi0mWHv0liqzc2thddG5msP9E36EYxr5ILzeUePiVSj9/E15dWf10hkNj
+c0kCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYD
+VR0OBBYEFJ84xFYjwznooHFs6FRM5Og6sb9nMA0GCSqGSIb3DQEBCwUAA4ICAQAS
+5UKme4sPDORGpbZgQIeMJX6tuGguW8ZAdjwD+MlZ9POrYs4QjbRaZIxowLByQzTS
+Gwv2LFPSypBLhmb8qoMi9IsabyZIrHZ3CL/FmFz0Jomee8O5ZDIBf9PD3Vht7LGr
+hFV0d4QEJ1JrhkzO3bll/9bGXp+aEJlLdWr+aumXIOTkdnrG0CSqkM0gkLpHZPt/
+B7NTeLUKYvJzQ85BK4FqLoUWlFPUa19yIqtRLULVAJyZv967lDtX/Zr1hstWO1uI
+AeV8KEsD+UmDfLJ/fOPtjqF/YFOOVZ1QNBIPt5d7bIdKROf1beyAN/BYGW5KaHbw
+H5Lk6rWS02FREAutp9lfx1/cH6NcjKF+m7ee01ZvZl4HliDtC3T7Zk6LERXpgUl+
+b7DUUH8i119lAg2m9IUe2K4GS0qn0jFmwvjO5QimpAKWRGhXxNUzzxkvFMSUHHuk
+2fCfDrGA4tGeEWSpiBE6doLlYsKA2KSD7ZPvfC+QsDJMlhVoSFLUmQjAJOgc47Ol
+IQ6SwJAfzyBfyjs4x7dtOvPmRLgOMWuIjnDrnBdSqEGULoe256YSxXXfW8AKbnuk
+5F6G+TaU33fD6Q3AOfF5u0aOq0NZJ7cguyPpVkAh7DE9ZapD8j3fcEThuk0mEDuY
+n/PIjhs4ViFqUZPTkcpG2om3PVODLAgfi49T3f+sHw==
+-----END CERTIFICATE-----
+
+GDCA TrustAUTH R5 ROOT
+-----BEGIN CERTIFICATE-----
+MIIFiDCCA3CgAwIBAgIIfQmX/vBH6nowDQYJKoZIhvcNAQELBQAwYjELMAkGA1UE
+BhMCQ04xMjAwBgNVBAoMKUdVQU5HIERPTkcgQ0VSVElGSUNBVEUgQVVUSE9SSVRZ
+IENPLixMVEQuMR8wHQYDVQQDDBZHRENBIFRydXN0QVVUSCBSNSBST09UMB4XDTE0
+MTEyNjA1MTMxNVoXDTQwMTIzMTE1NTk1OVowYjELMAkGA1UEBhMCQ04xMjAwBgNV
+BAoMKUdVQU5HIERPTkcgQ0VSVElGSUNBVEUgQVVUSE9SSVRZIENPLixMVEQuMR8w
+HQYDVQQDDBZHRENBIFRydXN0QVVUSCBSNSBST09UMIICIjANBgkqhkiG9w0BAQEF
+AAOCAg8AMIICCgKCAgEA2aMW8Mh0dHeb7zMNOwZ+Vfy1YI92hhJCfVZmPoiC7XJj
+Dp6L3TQsAlFRwxn9WVSEyfFrs0yw6ehGXTjGoqcuEVe6ghWinI9tsJlKCvLriXBj
+TnnEt1u9ol2x8kECK62pOqPseQrsXzrj/e+APK00mxqriCZ7VqKChh/rNYmDf1+u
+KU49tm7srsHwJ5uu4/Ts765/94Y9cnrrpftZTqfrlYwiOXnhLQiPzLyRuEH3FMEj
+qcOtmkVEs7LXLM3GKeJQEK5cy4KOFxg2fZfmiJqwTTQJ9Cy5WmYqsBebnh52nUpm
+MUHfP/vFBu8btn4aRjb3ZGM74zkYI+dndRTVdVeSN72+ahsmUPI2JgaQxXABZG12
+ZuGR224HwGGALrIuL4xwp9E7PLOR5G62xDtw8mySlwnNR30YwPO7ng/Wi64HtloP
+zgsMR6flPri9fcebNaBhlzpBdRfMK5Z3KpIhHtmVdiBnaM8Nvd/WHwlqmuLMc3Gk
+L30SgLdTMEZeS1SZD2fJpcjyIMGC7J0R38IC+xo70e0gmu9lZJIQDSri3nDxGGeC
+jGHeuLzRL5z7D9Ar7Rt2ueQ5Vfj4oR24qoAATILnsn8JuLwwoC8N9VKejveSswoA
+HQBUlwbgsQfZxw9cZX08bVlX5O2ljelAU58VS6Bx9hoh49pwBiFYFIeFd3mqgnkC
+AwEAAaNCMEAwHQYDVR0OBBYEFOLJQJ9NzuiaoXzPDj9lxSmIahlRMA8GA1UdEwEB
+/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4ICAQDRSVfg
+p8xoWLoBDysZzY2wYUWsEe1jUGn4H3++Fo/9nesLqjJHdtJnJO29fDMylyrHBYZm
+DRd9FBUb1Ov9H5r2XpdptxolpAqzkT9fNqyL7FeoPueBihhXOYV0GkLH6VsTX4/5
+COmSdI31R9KrO9b7eGZONn356ZLpBN79SWP8bfsUcZNnL0dKt7n/HipzcEYwv1ry
+L3ml4Y0M2fmyYzeMN2WFcGpcWwlyua1jPLHd+PwyvzeG5LuOmCd+uh8W4XAR8gPf
+JWIyJyYYMoSf/wA6E7qaTfRPuBRwIrHKK5DOKcFw9C+df/KQHtZa37dG/OaG+svg
+IHZ6uqbL9XzeYqWxi+7egmaKTjowHz+Ay60nugxe19CxVsp3cbK1daFQqUBDF8Io
+2c9Si1vIY9RCPqAzekYu9wogRlR+ak8x8YF+QnQ4ZXMn7sZ8uI7XpTrXmKGcjBBV
+09tL7ECQ8s1uV9JiDnxXk7Gnbc2dg7sq5+W2O3FYrf3RRbxake5TFW/TRQl1brqQ
+XR4EzzffHqhmsYzmIGrv/EhOdJhCrylvLmrH+33RZjEizIYAfmaDDEL0vTSSwxrq
+T8p+ck0LcIymSLumoRT2+1hEmRSuqguTaaApJUqlyyvdimYHFngVV3Eb7PVHhPOe
+MTd61X8kreS8/f3MboPoDKi3QWwH3b08hpcv0g==
+-----END CERTIFICATE-----
+
+GLOBALTRUST 2020
+-----BEGIN CERTIFICATE-----
+MIIFgjCCA2qgAwIBAgILWku9WvtPilv6ZeUwDQYJKoZIhvcNAQELBQAwTTELMAkG
+A1UEBhMCQVQxIzAhBgNVBAoTGmUtY29tbWVyY2UgbW9uaXRvcmluZyBHbWJIMRkw
+FwYDVQQDExBHTE9CQUxUUlVTVCAyMDIwMB4XDTIwMDIxMDAwMDAwMFoXDTQwMDYx
+MDAwMDAwMFowTTELMAkGA1UEBhMCQVQxIzAhBgNVBAoTGmUtY29tbWVyY2UgbW9u
+aXRvcmluZyBHbWJIMRkwFwYDVQQDExBHTE9CQUxUUlVTVCAyMDIwMIICIjANBgkq
+hkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAri5WrRsc7/aVj6B3GyvTY4+ETUWiD59b
+RatZe1E0+eyLinjF3WuvvcTfk0Uev5E4C64OFudBc/jbu9G4UeDLgztzOG53ig9Z
+YybNpyrOVPu44sB8R85gfD+yc/LAGbaKkoc1DZAoouQVBGM+uq/ufF7MpotQsjj3
+QWPKzv9pj2gOlTblzLmMCcpL3TGQlsjMH/1WljTbjhzqLL6FLmPdqqmV0/0plRPw
+yJiT2S0WR5ARg6I6IqIoV6Lr/sCMKKCmfecqQjuCgGOlYx8ZzHyyZqjC0203b+J+
+BlHZRYQfEs4kUmSFC0iAToexIiIwquuuvuAC4EDosEKAA1GqtH6qRNdDYfOiaxaJ
+SaSjpCuKAsR49GiKweR6NrFvG5Ybd0mN1MkGco/PU+PcF4UgStyYJ9ORJitHHmkH
+r96i5OTUawuzXnzUJIBHKWk7buis/UDr2O1xcSvy6Fgd60GXIsUf1DnQJ4+H4xj0
+4KlGDfV0OoIu0G4skaMxXDtG6nsEEFZegB31pWXogvziB4xiRfUg3kZwhqG8k9Me
+dKZssCz3AwyIDMvUclOGvGBG85hqwvG/Q/lwIHfKN0F5VVJjjVsSn8VoxIidrPIw
+q7ejMZdnrY8XD2zHc+0klGvIg5rQmjdJBKuxFshsSUktq6HQjJLyQUp5ISXbY9e2
+nKd+Qmn7OmMCAwEAAaNjMGEwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AQYwHQYDVR0OBBYEFNwuH9FhN3nkq9XVsxJxaD1qaJwiMB8GA1UdIwQYMBaAFNwu
+H9FhN3nkq9XVsxJxaD1qaJwiMA0GCSqGSIb3DQEBCwUAA4ICAQCR8EICaEDuw2jA
+VC/f7GLDw56KoDEoqoOOpFaWEhCGVrqXctJUMHytGdUdaG/7FELYjQ7ztdGl4wJC
+XtzoRlgHNQIw4Lx0SsFDKv/bGtCwr2zD/cuz9X9tAy5ZVp0tLTWMstZDFyySCstd
+6IwPS3BD0IL/qMy/pJTAvoe9iuOTe8aPmxadJ2W8esVCgmxcB9CpwYhgROmYhRZf
++I/KARDOJcP5YBugxZfD0yyIMaK9MOzQ0MAS8cE54+X1+NZK3TTN+2/BT+MAi1bi
+kvcoskJ3ciNnxz8RFbLEAwW+uxF7Cr+obuf/WEPPm2eggAe2HcqtbepBEX4tdJP7
+wry+UUTF72glJ4DjyKDUEuzZpTcdN3y0kcra1LGWge9oXHYQSa9+pTeAsRxSvTOB
+TI/53WXZFM2KJVj04sWDpQmQ1GwUY7VA3+vA/MRYfg0UFodUJ25W5HCEuGwyEn6C
+MUO+1918oa2u1qsgEu8KwxCMSZY13At1XrFP1U80DhEgB3VDRemjEdqso5nCtnkn
+4rnvyOL2NSl6dPrFf4IFYqYK6miyeUcGbvJXqBUzxvd4Sj1Ce2t+/vdG6tHrju+I
+aFvowdlxfv1k7/9nR4hYJS8+hge9+6jlgqispdNpQ80xiEmEU5LAsTkbOYMBMMTy
+qfrQA71yN2BWHzZ8vTmR9W0Nv3vXkg==
+-----END CERTIFICATE-----
+
+GTS Root R1
+-----BEGIN CERTIFICATE-----
+MIIFWjCCA0KgAwIBAgIQbkepxUtHDA3sM9CJuRz04TANBgkqhkiG9w0BAQwFADBH
+MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM
+QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy
+MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl
+cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEB
+AQUAA4ICDwAwggIKAoICAQC2EQKLHuOhd5s73L+UPreVp0A8of2C+X0yBoJx9vaM
+f/vo27xqLpeXo4xL+Sv2sfnOhB2x+cWX3u+58qPpvBKJXqeqUqv4IyfLpLGcY9vX
+mX7wCl7raKb0xlpHDU0QM+NOsROjyBhsS+z8CZDfnWQpJSMHobTSPS5g4M/SCYe7
+zUjwTcLCeoiKu7rPWRnWr4+wB7CeMfGCwcDfLqZtbBkOtdh+JhpFAz2weaSUKK0P
+fyblqAj+lug8aJRT7oM6iCsVlgmy4HqMLnXWnOunVmSPlk9orj2XwoSPwLxAwAtc
+vfaHszVsrBhQf4TgTM2S0yDpM7xSma8ytSmzJSq0SPly4cpk9+aCEI3oncKKiPo4
+Zor8Y/kB+Xj9e1x3+naH+uzfsQ55lVe0vSbv1gHR6xYKu44LtcXFilWr06zqkUsp
+zBmkMiVOKvFlRNACzqrOSbTqn3yDsEB750Orp2yjj32JgfpMpf/VjsPOS+C12LOO
+Rc92wO1AK/1TD7Cn1TsNsYqiA94xrcx36m97PtbfkSIS5r762DL8EGMUUXLeXdYW
+k70paDPvOmbsB4om3xPXV2V4J95eSRQAogB/mqghtqmxlbCluQ0WEdrHbEg8QOB+
+DVrNVjzRlwW5y0vtOUucxD/SVRNuJLDWcfr0wbrM7Rv1/oFB2ACYPTrIrnqYNxgF
+lQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
+HQ4EFgQU5K8rJnEaK0gnhS9SZizv8IkTcT4wDQYJKoZIhvcNAQEMBQADggIBADiW
+Cu49tJYeX++dnAsznyvgyv3SjgofQXSlfKqE1OXyHuY3UjKcC9FhHb8owbZEKTV1
+d5iyfNm9dKyKaOOpMQkpAWBz40d8U6iQSifvS9efk+eCNs6aaAyC58/UEBZvXw6Z
+XPYfcX3v73svfuo21pdwCxXu11xWajOl40k4DLh9+42FpLFZXvRq4d2h9mREruZR
+gyFmxhE+885H7pwoHyXa/6xmld01D1zvICxi/ZG6qcz8WpyTgYMpl0p8WnK0OdC3
+d8t5/Wk6kjftbjhlRn7pYL15iJdfOBL07q9bgsiG1eGZbYwE8na6SfZu6W0eX6Dv
+J4J2QPim01hcDyxC2kLGe4g0x8HYRZvBPsVhHdljUEn2NIVq4BjFbkerQUIpm/Zg
+DdIx02OYI5NaAIFItO/Nis3Jz5nu2Z6qNuFoS3FJFDYoOj0dzpqPJeaAcWErtXvM
++SUWgeExX6GjfhaknBZqlxi9dnKlC54dNuYvoS++cJEPqOba+MSSQGwlfnuzCdyy
+F62ARPBopY+Udf90WuioAnwMCeKpSwughQtiue+hMZL77/ZRBIls6Kl0obsXs7X9
+SQ98POyDGCBDTtWTurQ0sR8WNh8M5mQ5Fkzc4P4dyKliPUDqysU0ArSuiYgzNdws
+E3PYJ/HQcu51OyLemGhmW/HGY0dVHLqlCFF1pkgl
+-----END CERTIFICATE-----
+
+GTS Root R2
+-----BEGIN CERTIFICATE-----
+MIIFWjCCA0KgAwIBAgIQbkepxlqz5yDFMJo/aFLybzANBgkqhkiG9w0BAQwFADBH
+MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM
+QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy
+MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl
+cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEB
+AQUAA4ICDwAwggIKAoICAQDO3v2m++zsFDQ8BwZabFn3GTXd98GdVarTzTukk3Lv
+CvptnfbwhYBboUhSnznFt+4orO/LdmgUud+tAWyZH8QiHZ/+cnfgLFuv5AS/T3Kg
+GjSY6Dlo7JUle3ah5mm5hRm9iYz+re026nO8/4Piy33B0s5Ks40FnotJk9/BW9Bu
+XvAuMC6C/Pq8tBcKSOWIm8Wba96wyrQD8Nr0kLhlZPdcTK3ofmZemde4wj7I0BOd
+re7kRXuJVfeKH2JShBKzwkCX44ofR5GmdFrS+LFjKBC4swm4VndAoiaYecb+3yXu
+PuWgf9RhD1FLPD+M2uFwdNjCaKH5wQzpoeJ/u1U8dgbuak7MkogwTZq9TwtImoS1
+mKPV+3PBV2HdKFZ1E66HjucMUQkQdYhMvI35ezzUIkgfKtzra7tEscszcTJGr61K
+8YzodDqs5xoic4DSMPclQsciOzsSrZYuxsN2B6ogtzVJV+mSSeh2FnIxZyuWfoqj
+x5RWIr9qS34BIbIjMt/kmkRtWVtd9QCgHJvGeJeNkP+byKq0rxFROV7Z+2et1VsR
+nTKaG73VululycslaVNVJ1zgyjbLiGH7HrfQy+4W+9OmTN6SpdTi3/UGVN4unUu0
+kzCqgc7dGtxRcw1PcOnlthYhGXmy5okLdWTK1au8CcEYof/UVKGFPP0UJAOyh9Ok
+twIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
+HQ4EFgQUu//KjiOfT5nK2+JopqUVJxce2Q4wDQYJKoZIhvcNAQEMBQADggIBALZp
+8KZ3/p7uC4Gt4cCpx/k1HUCCq+YEtN/L9x0Pg/B+E02NjO7jMyLDOfxA325BS0JT
+vhaI8dI4XsRomRyYUpOM52jtG2pzegVATX9lO9ZY8c6DR2Dj/5epnGB3GFW1fgiT
+z9D2PGcDFWEJ+YF59exTpJ/JjwGLc8R3dtyDovUMSRqodt6Sm2T4syzFJ9MHwAiA
+pJiS4wGWAqoC7o87xdFtCjMwc3i5T1QWvwsHoaRc5svJXISPD+AVdyx+Jn7axEvb
+pxZ3B7DNdehyQtaVhJ2Gg/LkkM0JR9SLA3DaWsYDQvTtN6LwG1BUSw7YhN4ZKJmB
+R64JGz9I0cNv4rBgF/XuIwKl2gBbbZCr7qLpGzvpx0QnRY5rn/WkhLx3+WuXrD5R
+RaIRpsyF7gpo8j5QOHokYh4XIDdtak23CZvJ/KRY9bb7nE4Yu5UC56GtmwfuNmsk
+0jmGwZODUNKBRqhfYlcsu2xkiAhu7xNUX90txGdj08+JN7+dIPT7eoOboB6BAFDC
+5AwiWVIQ7UNWhwD4FFKnHYuTjKJNRn8nxnGbJN7k2oaLDX5rIMHAnuFl2GqjpuiF
+izoHCBy69Y9Vmhh1fuXsgWbRIXOhNUQLgD1bnF5vKheW0YMjiGZt5obicDIvUiLn
+yOd/xCxgXS/Dr55FBcOEArf9LAhST4Ldo/DUhgkC
+-----END CERTIFICATE-----
+
+GTS Root R3
+-----BEGIN CERTIFICATE-----
+MIICDDCCAZGgAwIBAgIQbkepx2ypcyRAiQ8DVd2NHTAKBggqhkjOPQQDAzBHMQsw
+CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU
+MBIGA1UEAxMLR1RTIFJvb3QgUjMwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw
+MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp
+Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjMwdjAQBgcqhkjOPQIBBgUrgQQA
+IgNiAAQfTzOHMymKoYTey8chWEGJ6ladK0uFxh1MJ7x/JlFyb+Kf1qPKzEUURout
+736GjOyxfi//qXGdGIRFBEFVbivqJn+7kAHjSxm65FSWRQmx1WyRRK2EE46ajA2A
+DDL24CejQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
+DgQWBBTB8Sa6oC2uhYHP0/EqEr24Cmf9vDAKBggqhkjOPQQDAwNpADBmAjEAgFuk
+fCPAlaUs3L6JbyO5o91lAFJekazInXJ0glMLfalAvWhgxeG4VDvBNhcl2MG9AjEA
+njWSdIUlUfUk7GRSJFClH9voy8l27OyCbvWFGFPouOOaKaqW04MjyaR7YbPMAuhd
+-----END CERTIFICATE-----
+
+GTS Root R4
+-----BEGIN CERTIFICATE-----
+MIICCjCCAZGgAwIBAgIQbkepyIuUtui7OyrYorLBmTAKBggqhkjOPQQDAzBHMQsw
+CQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExMQzEU
+MBIGA1UEAxMLR1RTIFJvb3QgUjQwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIyMDAw
+MDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZp
+Y2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjQwdjAQBgcqhkjOPQIBBgUrgQQA
+IgNiAATzdHOnaItgrkO4NcWBMHtLSZ37wWHO5t5GvWvVYRg1rkDdc/eJkTBa6zzu
+hXyiQHY7qca4R9gq55KRanPpsXI5nymfopjTX15YhmUPoYRlBtHci8nHc8iMai/l
+xKvRHYqjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
+DgQWBBSATNbrdP9JNqPV2Py1PsVq8JQdjDAKBggqhkjOPQQDAwNnADBkAjBqUFJ0
+CMRw3J5QdCHojXohw0+WbhXRIjVhLfoIN+4Zba3bssx9BzT1YBkstTTZbyACMANx
+sbqjYAuG7ZoIapVon+Kz4ZNkfF6Tpt95LY2F45TPI11xzPKwTdb+mciUqXWi4w==
+-----END CERTIFICATE-----
+
+GlobalSign ECC Root CA - R4
+-----BEGIN CERTIFICATE-----
+MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEk
+MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpH
+bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX
+DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD
+QSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5049sJQ6fLjkZHAOkrprlOQcJ
+FspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5RikqtlxP6jUuc6MHaNCMEAw
+DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFFSwe61F
+uOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX
+kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTs
+ewv4n4Q=
+-----END CERTIFICATE-----
+
+GlobalSign ECC Root CA - R5
+-----BEGIN CERTIFICATE-----
+MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEk
+MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpH
+bG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoX
+DTM4MDExOTAzMTQwN1owUDEkMCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBD
+QSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMwEQYDVQQDEwpHbG9iYWxTaWdu
+MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9Xb/pOdEh+J8LttV7HpI6SFkc
+8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwzocWdTaRvQZU4f8ke
+hOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD
+VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI
+KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg
+515dTguDnFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnO
+xwy8p2Fp8fc74SrL+SvzZpA3
+-----END CERTIFICATE-----
+
+GlobalSign Root CA
+-----BEGIN CERTIFICATE-----
+MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG
+A1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv
+b3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw
+MDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i
+YWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT
+aWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ
+jc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp
+xy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp
+1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
+snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ
+U26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8
+9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E
+BTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B
+AQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz
+yj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE
+38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP
+AbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad
+DKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
+HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
+-----END CERTIFICATE-----
+
+GlobalSign Root CA - R2
+-----BEGIN CERTIFICATE-----
+MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G
+A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp
+Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1
+MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG
+A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
+hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL
+v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8
+eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq
+tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
+C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa
+zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB
+mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH
+V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
+bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG
+3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs
+J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO
+291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS
+ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
+AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7
+TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
+-----END CERTIFICATE-----
+
+GlobalSign Root CA - R3
+-----BEGIN CERTIFICATE-----
+MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
+A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
+Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
+MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
+A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
+hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
+RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
+gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
+KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
+QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
+XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
+DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
+LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
+RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
+jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
+6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
+mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
+Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
+WD9f
+-----END CERTIFICATE-----
+
+GlobalSign Root CA - R6
+-----BEGIN CERTIFICATE-----
+MIIFgzCCA2ugAwIBAgIORea7A4Mzw4VlSOb/RVEwDQYJKoZIhvcNAQEMBQAwTDEg
+MB4GA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjYxEzARBgNVBAoTCkdsb2Jh
+bFNpZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMTQxMjEwMDAwMDAwWhcNMzQx
+MjEwMDAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSNjET
+MBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCAiIwDQYJ
+KoZIhvcNAQEBBQADggIPADCCAgoCggIBAJUH6HPKZvnsFMp7PPcNCPG0RQssgrRI
+xutbPK6DuEGSMxSkb3/pKszGsIhrxbaJ0cay/xTOURQh7ErdG1rG1ofuTToVBu1k
+ZguSgMpE3nOUTvOniX9PeGMIyBJQbUJmL025eShNUhqKGoC3GYEOfsSKvGRMIRxD
+aNc9PIrFsmbVkJq3MQbFvuJtMgamHvm566qjuL++gmNQ0PAYid/kD3n16qIfKtJw
+LnvnvJO7bVPiSHyMEAc4/2ayd2F+4OqMPKq0pPbzlUoSB239jLKJz9CgYXfIWHSw
+1CM69106yqLbnQneXUQtkPGBzVeS+n68UARjNN9rkxi+azayOeSsJDa38O+2HBNX
+k7besvjihbdzorg1qkXy4J02oW9UivFyVm4uiMVRQkQVlO6jxTiWm05OWgtH8wY2
+SXcwvHE35absIQh1/OZhFj931dmRl4QKbNQCTXTAFO39OfuD8l4UoQSwC+n+7o/h
+bguyCLNhZglqsQY6ZZZZwPA1/cnaKI0aEYdwgQqomnUdnjqGBQCe24DWJfncBZ4n
+WUx2OVvq+aWh2IMP0f/fMBH5hc8zSPXKbWQULHpYT9NLCEnFlWQaYw55PfWzjMpY
+rZxCRXluDocZXFSxZba/jJvcE+kNb7gu3GduyYsRtYQUigAZcIN5kZeR1Bonvzce
+MgfYFGM8KEyvAgMBAAGjYzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD
+AQH/MB0GA1UdDgQWBBSubAWjkxPioufi1xzWx/B/yGdToDAfBgNVHSMEGDAWgBSu
+bAWjkxPioufi1xzWx/B/yGdToDANBgkqhkiG9w0BAQwFAAOCAgEAgyXt6NH9lVLN
+nsAEoJFp5lzQhN7craJP6Ed41mWYqVuoPId8AorRbrcWc+ZfwFSY1XS+wc3iEZGt
+Ixg93eFyRJa0lV7Ae46ZeBZDE1ZXs6KzO7V33EByrKPrmzU+sQghoefEQzd5Mr61
+55wsTLxDKZmOMNOsIeDjHfrYBzN2VAAiKrlNIC5waNrlU/yDXNOd8v9EDERm8tLj
+vUYAGm0CuiVdjaExUd1URhxN25mW7xocBFymFe944Hn+Xds+qkxV/ZoVqW/hpvvf
+cDDpw+5CRu3CkwWJ+n1jez/QcYF8AOiYrg54NMMl+68KnyBr3TsTjxKM4kEaSHpz
+oHdpx7Zcf4LIHv5YGygrqGytXm3ABdJ7t+uA/iU3/gKbaKxCXcPu9czc8FB10jZp
+nOZ7BN9uBmm23goJSFmH63sUYHpkqmlD75HHTOwY3WzvUy2MmeFe8nI+z1TIvWfs
+pA9MRf/TuTAjB0yPEL+GltmZWrSZVxykzLsViVO6LAUP5MSeGbEYNNVMnbrt9x+v
+JJUEeKgDu+6B5dpffItKoZB0JaezPkvILFa9x8jvOOJckvB595yEunQtYQEgfn7R
+8k8HWV+LLUNS60YMlOH1Zkd5d9VUWx+tJDfLRVpOoERIyNiwmcUVhAn21klJwGW4
+5hpxbqCo8YLoRT5s1gLXCmeDBVrJpBA=
+-----END CERTIFICATE-----
+
+GlobalSign Root E46
+-----BEGIN CERTIFICATE-----
+MIICCzCCAZGgAwIBAgISEdK7ujNu1LzmJGjFDYQdmOhDMAoGCCqGSM49BAMDMEYx
+CzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYDVQQD
+ExNHbG9iYWxTaWduIFJvb3QgRTQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMyMDAw
+MDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2Ex
+HDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBFNDYwdjAQBgcqhkjOPQIBBgUrgQQA
+IgNiAAScDrHPt+ieUnd1NPqlRqetMhkytAepJ8qUuwzSChDH2omwlwxwEwkBjtjq
+R+q+soArzfwoDdusvKSGN+1wCAB16pMLey5SnCNoIwZD7JIvU4Tb+0cUB+hflGdd
+yXqBPCCjQjBAMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
+DgQWBBQxCpCPtsad0kRLgLWi5h+xEk8blTAKBggqhkjOPQQDAwNoADBlAjEA31SQ
+7Zvvi5QCkxeCmb6zniz2C5GMn0oUsfZkvLtoURMMA/cVi4RguYv/Uo7njLwcAjA8
++RHUjE7AwWHCFUyqqx0LMV87HOIAl0Qx5v5zli/altP+CAezNIm8BZ/3Hobui3A=
+-----END CERTIFICATE-----
+
+GlobalSign Root R46
+-----BEGIN CERTIFICATE-----
+MIIFWjCCA0KgAwIBAgISEdK7udcjGJ5AXwqdLdDfJWfRMA0GCSqGSIb3DQEBDAUA
+MEYxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRwwGgYD
+VQQDExNHbG9iYWxTaWduIFJvb3QgUjQ2MB4XDTE5MDMyMDAwMDAwMFoXDTQ2MDMy
+MDAwMDAwMFowRjELMAkGA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYt
+c2ExHDAaBgNVBAMTE0dsb2JhbFNpZ24gUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEB
+AQUAA4ICDwAwggIKAoICAQCsrHQy6LNl5brtQyYdpokNRbopiLKkHWPd08EsCVeJ
+OaFV6Wc0dwxu5FUdUiXSE2te4R2pt32JMl8Nnp8semNgQB+msLZ4j5lUlghYruQG
+vGIFAha/r6gjA7aUD7xubMLL1aa7DOn2wQL7Id5m3RerdELv8HQvJfTqa1VbkNud
+316HCkD7rRlr+/fKYIje2sGP1q7Vf9Q8g+7XFkyDRTNrJ9CG0Bwta/OrffGFqfUo
+0q3v84RLHIf8E6M6cqJaESvWJ3En7YEtbWaBkoe0G1h6zD8K+kZPTXhc+CtI4wSE
+y132tGqzZfxCnlEmIyDLPRT5ge1lFgBPGmSXZgjPjHvjK8Cd+RTyG/FWaha/LIWF
+zXg4mutCagI0GIMXTpRW+LaCtfOW3T3zvn8gdz57GSNrLNRyc0NXfeD412lPFzYE
++cCQYDdF3uYM2HSNrpyibXRdQr4G9dlkbgIQrImwTDsHTUB+JMWKmIJ5jqSngiCN
+I/onccnfxkF0oE32kRbcRoxfKWMxWXEM2G/CtjJ9++ZdU6Z+Ffy7dXxd7Pj2Fxzs
+x2sZy/N78CsHpdlseVR2bJ0cpm4O6XkMqCNqo98bMDGfsVR7/mrLZqrcZdCinkqa
+ByFrgY/bxFn63iLABJzjqls2k+g9vXqhnQt2sQvHnf3PmKgGwvgqo6GDoLclcqUC
+4wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
+HQ4EFgQUA1yrc4GHqMywptWU4jaWSf8FmSwwDQYJKoZIhvcNAQEMBQADggIBAHx4
+7PYCLLtbfpIrXTncvtgdokIzTfnvpCo7RGkerNlFo048p9gkUbJUHJNOxO97k4Vg
+JuoJSOD1u8fpaNK7ajFxzHmuEajwmf3lH7wvqMxX63bEIaZHU1VNaL8FpO7XJqti
+2kM3S+LGteWygxk6x9PbTZ4IevPuzz5i+6zoYMzRx6Fcg0XERczzF2sUyQQCPtIk
+pnnpHs6i58FZFZ8d4kuaPp92CC1r2LpXFNqD6v6MVenQTqnMdzGxRBF6XLE+0xRF
+FRhiJBPSy03OXIPBNvIQtQ6IbbjhVp+J3pZmOUdkLG5NrmJ7v2B0GbhWrJKsFjLt
+rWhV/pi60zTe9Mlhww6G9kuEYO4Ne7UyWHmRVSyBQ7N0H3qqJZ4d16GLuc1CLgSk
+ZoNNiTW2bKg2SnkheCLQQrzRQDGQob4Ez8pn7fXwgNNgyYMqIgXQBztSvwyeqiv5
+u+YfjyW6hY0XHgL+XVAEV8/+LbzvXMAaq7afJMbfc2hIkCwU9D9SGuTSyxTDYWnP
+4vkYxboznxSjBF25cfe1lNj2M8FawTSLfJvdkzrnE6JwYZ+vj+vYxXX4M2bUdGc6
+N3ec592kD3ZDZopD8p/7DEJ4Y9HiD2971KE9dJeFt0g5QdYg/NA6s/rob8SKunE3
+vouXsXgxT7PntgMTzlSdriVZzH81Xwj3QEUxeCp6
+-----END CERTIFICATE-----
+
+Go Daddy Class 2 CA
+-----BEGIN CERTIFICATE-----
+MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEh
+MB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBE
+YWRkeSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3
+MDYyMFoXDTM0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRo
+ZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3Mg
+MiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN
+ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XCA
+PVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux6w
+wdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi
+EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMY
+avx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+
+YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLE
+sNKR1EwRcbNhyz2h/t2oatTjMIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h
+/t2oatTjoWekZTBjMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYVGhlIEdvIERhZGR5
+IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAyIENlcnRpZmlj
+YXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQAD
+ggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYXMP80kWNy
+OO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P
+TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQ
+HmyW74cNxA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mER
+dEr/VxqHD3VILs9RaRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5Cuf
+ReYNnyicsbkqWletNw+vHX/bvZ8=
+-----END CERTIFICATE-----
+
+Go Daddy Root Certificate Authority - G2
+-----BEGIN CERTIFICATE-----
+MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx
+EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT
+EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp
+ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz
+NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH
+EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE
+AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw
+DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD
+E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH
+/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy
+DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh
+GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR
+tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA
+AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
+FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX
+WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu
+9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr
+gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo
+2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO
+LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI
+4uJEvlz36hz1
+-----END CERTIFICATE-----
+
+Hellenic Academic and Research Institutions ECC RootCA 2015
+-----BEGIN CERTIFICATE-----
+MIICwzCCAkqgAwIBAgIBADAKBggqhkjOPQQDAjCBqjELMAkGA1UEBhMCR1IxDzAN
+BgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNhZGVtaWMgYW5kIFJl
+c2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkxRDBCBgNVBAMTO0hl
+bGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgRUNDIFJv
+b3RDQSAyMDE1MB4XDTE1MDcwNzEwMzcxMloXDTQwMDYzMDEwMzcxMlowgaoxCzAJ
+BgNVBAYTAkdSMQ8wDQYDVQQHEwZBdGhlbnMxRDBCBgNVBAoTO0hlbGxlbmljIEFj
+YWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgQ2VydC4gQXV0aG9yaXR5
+MUQwQgYDVQQDEztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5zdGl0
+dXRpb25zIEVDQyBSb290Q0EgMjAxNTB2MBAGByqGSM49AgEGBSuBBAAiA2IABJKg
+QehLgoRc4vgxEZmGZE4JJS+dQS8KrjVPdJWyUWRrjWvmP3CV8AVER6ZyOFB2lQJa
+jq4onvktTpnvLEhvTCUp6NFxW98dwXU3tNf6e3pCnGoKVlp8aQuqgAkkbH7BRqNC
+MEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFLQi
+C4KZJAEOnLvkDv2/+5cgk5kqMAoGCCqGSM49BAMCA2cAMGQCMGfOFmI4oqxiRaep
+lSTAGiecMjvAwNW6qef4BENThe5SId6d9SWDPp5YSy/XZxMOIQIwBeF1Ad5o7Sof
+TUwJCA3sS61kFyjndc5FZXIhF8siQQ6ME5g4mlRtm8rifOoCWCKR
+-----END CERTIFICATE-----
+
+Hellenic Academic and Research Institutions RootCA 2011
+-----BEGIN CERTIFICATE-----
+MIIEMTCCAxmgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCR1Ix
+RDBCBgNVBAoTO0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1
+dGlvbnMgQ2VydC4gQXV0aG9yaXR5MUAwPgYDVQQDEzdIZWxsZW5pYyBBY2FkZW1p
+YyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIFJvb3RDQSAyMDExMB4XDTExMTIw
+NjEzNDk1MloXDTMxMTIwMTEzNDk1MlowgZUxCzAJBgNVBAYTAkdSMUQwQgYDVQQK
+EztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5zdGl0dXRpb25zIENl
+cnQuIEF1dGhvcml0eTFAMD4GA1UEAxM3SGVsbGVuaWMgQWNhZGVtaWMgYW5kIFJl
+c2VhcmNoIEluc3RpdHV0aW9ucyBSb290Q0EgMjAxMTCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBAKlTAOMupvaO+mDYLZU++CwqVE7NuYRhlFhPjz2L5EPz
+dYmNUeTDN9KKiE15HrcS3UN4SoqS5tdI1Q+kOilENbgH9mgdVc04UfCMJDGFr4PJ
+fel3r+0ae50X+bOdOFAPplp5kYCvN66m0zH7tSYJnTxa71HFK9+WXesyHgLacEns
+bgzImjeN9/E2YEsmLIKe0HjzDQ9jpFEw4fkrJxIH2Oq9GGKYsFk3fb7u8yBRQlqD
+75O6aRXxYp2fmTmCobd0LovUxQt7L/DICto9eQqakxylKHJzkUOap9FNhYS5qXSP
+FEDH3N6sQWRstBmbAmNtJGSPRLIl6s5ddAxjMlyNh+UCAwEAAaOBiTCBhjAPBgNV
+HRMBAf8EBTADAQH/MAsGA1UdDwQEAwIBBjAdBgNVHQ4EFgQUppFC/RNhSiOeCKQp
+5dgTBCPuQSUwRwYDVR0eBEAwPqA8MAWCAy5ncjAFggMuZXUwBoIELmVkdTAGggQu
+b3JnMAWBAy5ncjAFgQMuZXUwBoEELmVkdTAGgQQub3JnMA0GCSqGSIb3DQEBBQUA
+A4IBAQAf73lB4XtuP7KMhjdCSk4cNx6NZrokgclPEg8hwAOXhiVtXdMiKahsog2p
+6z0GW5k6x8zDmjR/qw7IThzh+uTczQ2+vyT+bOdrwg3IBp5OjWEopmr95fZi6hg8
+TqBTnbI6nOulnJEWtk2C4AwFSKls9cz4y51JtPACpf1wA+2KIaWuE4ZJwzNzvoc7
+dIsXRSZMFpGD/md9zU1jZ/rzAxKWeAaNsWftjj++n08C9bMJL/NMh98qy5V8Acys
+Nnq/onN694/BtZqhFLKPM58N7yLcZnuEvUUXBj08yrl3NI/K6s8/MT7jiOOASSXI
+l7WdmplNsDz4SgCbZN2fOUvRJ9e4
+-----END CERTIFICATE-----
+
+Hellenic Academic and Research Institutions RootCA 2015
+-----BEGIN CERTIFICATE-----
+MIIGCzCCA/OgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBpjELMAkGA1UEBhMCR1Ix
+DzANBgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNhZGVtaWMgYW5k
+IFJlc2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkxQDA+BgNVBAMT
+N0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgUm9v
+dENBIDIwMTUwHhcNMTUwNzA3MTAxMTIxWhcNNDAwNjMwMTAxMTIxWjCBpjELMAkG
+A1UEBhMCR1IxDzANBgNVBAcTBkF0aGVuczFEMEIGA1UEChM7SGVsbGVuaWMgQWNh
+ZGVtaWMgYW5kIFJlc2VhcmNoIEluc3RpdHV0aW9ucyBDZXJ0LiBBdXRob3JpdHkx
+QDA+BgNVBAMTN0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1
+dGlvbnMgUm9vdENBIDIwMTUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
+AQDC+Kk/G4n8PDwEXT2QNrCROnk8ZlrvbTkBSRq0t89/TSNTt5AA4xMqKKYx8ZEA
+4yjsriFBzh/a/X0SWwGDD7mwX5nh8hKDgE0GPt+sr+ehiGsxr/CL0BgzuNtFajT0
+AoAkKAoCFZVedioNmToUW/bLy1O8E00BiDeUJRtCvCLYjqOWXjrZMts+6PAQZe10
+4S+nfK8nNLspfZu2zwnI5dMK/IhlZXQK3HMcXM1AsRzUtoSMTFDPaI6oWa7CJ06C
+ojXdFPQf/7J31Ycvqm59JCfnxssm5uX+Zwdj2EUN3TpZZTlYepKZcj2chF6IIbjV
+9Cz82XBST3i4vTwri5WY9bPRaM8gFH5MXF/ni+X1NYEZN9cRCLdmvtNKzoNXADrD
+gfgXy5I2XdGj2HUb4Ysn6npIQf1FGQatJ5lOwXBH3bWfgVMS5bGMSF0xQxfjjMZ6
+Y5ZLKTBOhE5iGV48zpeQpX8B653g+IuJ3SWYPZK2fu/Z8VFRfS0myGlZYeCsargq
+NhEEelC9MoS+L9xy1dcdFkfkR2YgP/SWxa+OAXqlD3pk9Q0Yh9muiNX6hME6wGko
+LfINaFGq46V3xqSQDqE3izEjR8EJCOtu93ib14L8hCCZSRm2Ekax+0VVFqmjZayc
+Bw/qa9wfLgZy7IaIEuQt218FL+TwA9MmM+eAws1CoRc0CwIDAQABo0IwQDAPBgNV
+HRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUcRVnyMjJvXVd
+ctA4GGqd83EkVAswDQYJKoZIhvcNAQELBQADggIBAHW7bVRLqhBYRjTyYtcWNl0I
+XtVsyIe9tC5G8jH4fOpCtZMWVdyhDBKg2mF+D1hYc2Ryx+hFjtyp8iY/xnmMsVMI
+M4GwVhO+5lFc2JsKT0ucVlMC6U/2DWDqTUJV6HwbISHTGzrMd/K4kPFox/la/vot
+9L/J9UUbzjgQKjeKeaO04wlshYaT/4mWJ3iBj2fjRnRUjtkNaeJK9E10A/+yd+2V
+Z5fkscWrv2oj6NSU4kQoYsRL4vDY4ilrGnB+JGGTe08DMiUNRSQrlrRGar9KC/ea
+j8GsGsVn82800vpzY4zvFrCopEYq+OsS7HK07/grfoxSwIuEVPkvPuNVqNxmsdnh
+X9izjFk0WaSrT2y7HxjbdavYy5LNlDhhDgcGH0tGEPEVvo2FXDtKK4F5D7Rpn0lQ
+l033DlZdwJVqwjbDG2jJ9SrcR5q+ss7FJej6A7na+RZukYT1HCjI/CbM1xyQVqdf
+bzoEvM14iQuODy+jqk+iGxI9FghAD/FGTNeqewjBCvVtJ94Cj8rDtSvK6evIIVM4
+pcw72Hc3MKJP2W/R8kCtQXoXxdZKNYm3QdV8hn9VTYNKpXMgwDqvkPGaJI7ZjnHK
+e7iG2rKPmT4dEw0SEe7Uq/DpFXYC5ODfqiAeW2GFZECpkJcNrVPSWh2HagCXZWK0
+vm9qp/UsQu0yrbYhnr68
+-----END CERTIFICATE-----
+
+Hongkong Post Root CA 1
+-----BEGIN CERTIFICATE-----
+MIIDMDCCAhigAwIBAgICA+gwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCSEsx
+FjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3Qg
+Um9vdCBDQSAxMB4XDTAzMDUxNTA1MTMxNFoXDTIzMDUxNTA0NTIyOVowRzELMAkG
+A1UEBhMCSEsxFjAUBgNVBAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdr
+b25nIFBvc3QgUm9vdCBDQSAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEArP84tulmAknjorThkPlAj3n54r15/gK97iSSHSL22oVyaf7XPwnU3ZG1ApzQ
+jVrhVcNQhrkpJsLj2aDxaQMoIIBFIi1WpztUlVYiWR8o3x8gPW2iNr4joLFutbEn
+PzlTCeqrauh0ssJlXI6/fMN4hM2eFvz1Lk8gKgifd/PFHsSaUmYeSF7jEAaPIpjh
+ZY4bXSNmO7ilMlHIhqqhqZ5/dpTCpmy3QfDVyAY45tQM4vM7TG1QjMSDJ8EThFk9
+nnV0ttgCXjqQesBCNnLsak3c78QA3xMYV18meMjWCnl3v/evt3a5pQuEF10Q6m/h
+q5URX208o1xNg1vysxmKgIsLhwIDAQABoyYwJDASBgNVHRMBAf8ECDAGAQH/AgED
+MA4GA1UdDwEB/wQEAwIBxjANBgkqhkiG9w0BAQUFAAOCAQEADkbVPK7ih9legYsC
+mEEIjEy82tvuJxuC52pF7BaLT4Wg87JwvVqWuspube5Gi27nKi6Wsxkz67SfqLI3
+7piol7Yutmcn1KZJ/RyTZXaeQi/cImyaT/JaFTmxcdcrUehtHJjA2Sr0oYJ71clB
+oiMBdDhViw+5LmeiIAQ32pwL0xch4I+XeTRvhEgCIDMb5jREn5Fw9IBehEPCKdJs
+EhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES7VBnQRM9IauUiqpO
+fMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4JxHYB0yvbi
+AmvZWg==
+-----END CERTIFICATE-----
+
+Hongkong Post Root CA 3
+-----BEGIN CERTIFICATE-----
+MIIFzzCCA7egAwIBAgIUCBZfikyl7ADJk0DfxMauI7gcWqQwDQYJKoZIhvcNAQEL
+BQAwbzELMAkGA1UEBhMCSEsxEjAQBgNVBAgTCUhvbmcgS29uZzESMBAGA1UEBxMJ
+SG9uZyBLb25nMRYwFAYDVQQKEw1Ib25na29uZyBQb3N0MSAwHgYDVQQDExdIb25n
+a29uZyBQb3N0IFJvb3QgQ0EgMzAeFw0xNzA2MDMwMjI5NDZaFw00MjA2MDMwMjI5
+NDZaMG8xCzAJBgNVBAYTAkhLMRIwEAYDVQQIEwlIb25nIEtvbmcxEjAQBgNVBAcT
+CUhvbmcgS29uZzEWMBQGA1UEChMNSG9uZ2tvbmcgUG9zdDEgMB4GA1UEAxMXSG9u
+Z2tvbmcgUG9zdCBSb290IENBIDMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
+AoICAQCziNfqzg8gTr7m1gNt7ln8wlffKWihgw4+aMdoWJwcYEuJQwy51BWy7sFO
+dem1p+/l6TWZ5Mwc50tfjTMwIDNT2aa71T4Tjukfh0mtUC1Qyhi+AViiE3CWu4mI
+VoBc+L0sPOFMV4i707mV78vH9toxdCim5lSJ9UExyuUmGs2C4HDaOym71QP1mbpV
+9WTRYA6ziUm4ii8F0oRFKHyPaFASePwLtVPLwpgchKOesL4jpNrcyCse2m5FHomY
+2vkALgbpDDtw1VAliJnLzXNg99X/NWfFobxeq81KuEXryGgeDQ0URhLj0mRiikKY
+vLTGCAj4/ahMZJx2Ab0vqWwzD9g/KLg8aQFChn5pwckGyuV6RmXpwtZQQS4/t+Tt
+bNe/JgERohYpSms0BpDsE9K2+2p20jzt8NYt3eEV7KObLyzJPivkaTv/ciWxNoZb
+x39ri1UbSsUgYT2uy1DhCDq+sI9jQVMwCFk8mB13umOResoQUGC/8Ne8lYePl8X+
+l2oBlKN8W4UdKjk60FSh0Tlxnf0h+bV78OLgAo9uliQlLKAeLKjEiafv7ZkGL7YK
+TE/bosw3Gq9HhS2KX8Q0NEwA/RiTZxPRN+ZItIsGxVd7GYYKecsAyVKvQv83j+Gj
+Hno9UKtjBucVtT+2RTeUN7F+8kjDf8V1/peNRY8apxpyKBpADwIDAQABo2MwYTAP
+BgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAfBgNVHSMEGDAWgBQXnc0e
+i9Y5K3DTXNSguB+wAPzFYTAdBgNVHQ4EFgQUF53NHovWOStw01zUoLgfsAD8xWEw
+DQYJKoZIhvcNAQELBQADggIBAFbVe27mIgHSQpsY1Q7XZiNc4/6gx5LS6ZStS6LG
+7BJ8dNVI0lkUmcDrudHr9EgwW62nV3OZqdPlt9EuWSRY3GguLmLYauRwCy0gUCCk
+MpXRAJi70/33MvJJrsZ64Ee+bs7Lo3I6LWldy8joRTnU+kLBEUx3XZL7av9YROXr
+gZ6voJmtvqkBZss4HTzfQx/0TW60uhdG/H39h4F5ag0zD/ov+BS5gLNdTaqX4fnk
+GMX41TiMJjz98iji7lpJiCzfeT2OnpA8vUFKOt1b9pq0zj8lMH8yfaIDlNDceqFS
+3m6TjRgm/VWsvY+b0s+v54Ysyx8Jb6NvqYTUc79NoXQbTiNg8swOqn+knEwlqLJm
+Ozj/2ZQw9nKEvmhVEA/GcywWaZMH/rFF7buiVWqw2rVKAiUnhde3t4ZEFolsgCs+
+l6mc1X5VTMbeRRAc6uk7nwNT7u56AQIWeNTowr5GdogTPyK7SBIdUgC0An4hGh6c
+JfTzPV4e0hz5sy229zdcxsshTrD3mUcYhcErulWuBurQB7Lcq9CClnXO0lD+mefP
+L5/ndtFhKvshuzHQqp9HpLIiyhY6UFfEW0NnxWViA0kB60PZ2Pierc+xYw5F9KBa
+LJstxabArahH9CdMOA0uG0k7UvToiIMrVCjU8jVStDKDYmlkDJGcn5fqdBb9HxEG
+mpv0
+-----END CERTIFICATE-----
+
+ISRG Root X1
+-----BEGIN CERTIFICATE-----
+MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
+TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
+cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
+WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
+ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
+MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
+h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
+0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
+A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
+T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
+B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
+B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
+KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
+OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
+jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
+qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
+rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
+HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
+hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
+ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
+3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
+NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
+ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
+TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
+jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
+oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
+4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
+mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
+emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
+-----END CERTIFICATE-----
+
+IdenTrust Commercial Root CA 1
+-----BEGIN CERTIFICATE-----
+MIIFYDCCA0igAwIBAgIQCgFCgAAAAUUjyES1AAAAAjANBgkqhkiG9w0BAQsFADBK
+MQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVu
+VHJ1c3QgQ29tbWVyY2lhbCBSb290IENBIDEwHhcNMTQwMTE2MTgxMjIzWhcNMzQw
+MTE2MTgxMjIzWjBKMQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScw
+JQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVyY2lhbCBSb290IENBIDEwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQCnUBneP5k91DNG8W9RYYKyqU+PZ4ldhNlT
+3Qwo2dfw/66VQ3KZ+bVdfIrBQuExUHTRgQ18zZshq0PirK1ehm7zCYofWjK9ouuU
++ehcCuz/mNKvcbO0U59Oh++SvL3sTzIwiEsXXlfEU8L2ApeN2WIrvyQfYo3fw7gp
+S0l4PJNgiCL8mdo2yMKi1CxUAGc1bnO/AljwpN3lsKImesrgNqUZFvX9t++uP0D1
+bVoE/c40yiTcdCMbXTMTEl3EASX2MN0CXZ/g1Ue9tOsbobtJSdifWwLziuQkkORi
+T0/Br4sOdBeo0XKIanoBScy0RnnGF7HamB4HWfp1IYVl3ZBWzvurpWCdxJ35UrCL
+vYf5jysjCiN2O/cz4ckA82n5S6LgTrx+kzmEB/dEcH7+B1rlsazRGMzyNeVJSQjK
+Vsk9+w8YfYs7wRPCTY/JTw436R+hDmrfYi7LNQZReSzIJTj0+kuniVyc0uMNOYZK
+dHzVWYfCP04MXFL0PfdSgvHqo6z9STQaKPNBiDoT7uje/5kdX7rL6B7yuVBgwDHT
+c+XvvqDtMwt0viAgxGds8AgDelWAf0ZOlqf0Hj7h9tgJ4TNkK2PXMl6f+cB7D3hv
+l7yTmvmcEpB4eoCHFddydJxVdHixuuFucAS6T6C6aMN7/zHwcz09lCqxC0EOoP5N
+iGVreTO01wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
+/zAdBgNVHQ4EFgQU7UQZwNPwBovupHu+QucmVMiONnYwDQYJKoZIhvcNAQELBQAD
+ggIBAA2ukDL2pkt8RHYZYR4nKM1eVO8lvOMIkPkp165oCOGUAFjvLi5+U1KMtlwH
+6oi6mYtQlNeCgN9hCQCTrQ0U5s7B8jeUeLBfnLOic7iPBZM4zY0+sLj7wM+x8uwt
+LRvM7Kqas6pgghstO8OEPVeKlh6cdbjTMM1gCIOQ045U8U1mwF10A0Cj7oV+wh93
+nAbowacYXVKV7cndJZ5t+qntozo00Fl72u1Q8zW/7esUTTHHYPTa8Yec4kjixsU3
++wYQ+nVZZjFHKdp2mhzpgq7vmrlR94gjmmmVYjzlVYA211QC//G5Xc7UI2/YRYRK
+W2XviQzdFKcgyxilJbQN+QHwotL0AMh0jqEqSI5l2xPE4iUXfeu+h1sXIFRRk0pT
+AwvsXcoz7WL9RccvW9xYoIA55vrX/hMUpu09lEpCdNTDd1lzzY9GvlU47/rokTLq
+l1gEIt44w8y8bckzOmoKaT+gyOpyj4xjhiO9bTyWnpXgSUyqorkqG5w2gXjtw+hG
+4iZZRHUe2XWJUc0QhJ1hYMtd+ZciTY6Y5uN/9lu7rs3KSoFrXgvzUeF0K+l+J6fZ
+mUlO+KWA2yUPHGNiiskzZ2s8EIPGrd6ozRaOjfAHN3Gf8qv8QfXBi+wAN10J5U6A
+7/qxXDgGpRtK4dw4LTzcqx+QGtVKnO7RcGzM7vRX+Bi6hG6H
+-----END CERTIFICATE-----
+
+IdenTrust Public Sector Root CA 1
+-----BEGIN CERTIFICATE-----
+MIIFZjCCA06gAwIBAgIQCgFCgAAAAUUjz0Z8AAAAAjANBgkqhkiG9w0BAQsFADBN
+MQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVu
+VHJ1c3QgUHVibGljIFNlY3RvciBSb290IENBIDEwHhcNMTQwMTE2MTc1MzMyWhcN
+MzQwMTE2MTc1MzMyWjBNMQswCQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0
+MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVibGljIFNlY3RvciBSb290IENBIDEwggIi
+MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2IpT8pEiv6EdrCvsnduTyP4o7
+ekosMSqMjbCpwzFrqHd2hCa2rIFCDQjrVVi7evi8ZX3yoG2LqEfpYnYeEe4IFNGy
+RBb06tD6Hi9e28tzQa68ALBKK0CyrOE7S8ItneShm+waOh7wCLPQ5CQ1B5+ctMlS
+bdsHyo+1W/CD80/HLaXIrcuVIKQxKFdYWuSNG5qrng0M8gozOSI5Cpcu81N3uURF
+/YTLNiCBWS2ab21ISGHKTN9T0a9SvESfqy9rg3LvdYDaBjMbXcjaY8ZNzaxmMc3R
+3j6HEDbhuaR672BQssvKplbgN6+rNBM5Jeg5ZuSYeqoSmJxZZoY+rfGwyj4GD3vw
+EUs3oERte8uojHH01bWRNszwFcYr3lEXsZdMUD2xlVl8BX0tIdUAvwFnol57plzy
+9yLxkA2T26pEUWbMfXYD62qoKjgZl3YNa4ph+bz27nb9cCvdKTz4Ch5bQhyLVi9V
+GxyhLrXHFub4qjySjmm2AcG1hp2JDws4lFTo6tyePSW8Uybt1as5qsVATFSrsrTZ
+2fjXctscvG29ZV/viDUqZi/u9rNl8DONfJhBaUYPQxxp+pu10GFqzcpL2UyQRqsV
+WaFHVCkugyhfHMKiq3IXAAaOReyL4jM9f9oZRORicsPfIsbyVtTdX5Vy7W1f90gD
+W/3FKqD2cyOEEBsB5wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
+BAUwAwEB/zAdBgNVHQ4EFgQU43HgntinQtnbcZFrlJPrw6PRFKMwDQYJKoZIhvcN
+AQELBQADggIBAEf63QqwEZE4rU1d9+UOl1QZgkiHVIyqZJnYWv6IAcVYpZmxI1Qj
+t2odIFflAWJBF9MJ23XLblSQdf4an4EKwt3X9wnQW3IV5B4Jaj0z8yGa5hV+rVHV
+DRDtfULAj+7AmgjVQdZcDiFpboBhDhXAuM/FSRJSzL46zNQuOAXeNf0fb7iAaJg9
+TaDKQGXSc3z1i9kKlT/YPyNtGtEqJBnZhbMX73huqVjRI9PHE+1yJX9dsXNw0H8G
+lwmEKYBhHfpe/3OsoOOJuBxxFcbeMX8S3OFtm6/n6J91eEyrRjuazr8FGF1NFTwW
+mhlQBJqymm9li1JfPFgEKCXAZmExfrngdbkaqIHWchezxQMxNRF4eKLg6TCMf4Df
+WN88uieW4oA0beOY02QnrEh+KHdcxiVhJfiFDGX6xDIvpZgF5PgLZxYWxoK4Mhn5
++bl53B/N66+rDt0b20XkeucC4pVd/GnwU2lhlXV5C15V5jgclKlZM57IcXR5f1GJ
+tshquDDIajjDbp7hNxbqBWJMWxJH7ae0s1hWx0nzfxJoCTFx8G34Tkf71oXuxVhA
+GaQdp/lLQzfcaFpPz+vCZHTetBXZ9FRUGi8c15dxVJCO2SCdUyt/q4/i6jC8UDfv
+8Ue1fXwsBOxonbRJRBD0ckscZOf85muQ3Wl9af0AVqW3rLatt8o+Ae+c
+-----END CERTIFICATE-----
+
+Izenpe
+-----BEGIN CERTIFICATE-----
+MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4
+MQswCQYDVQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6
+ZW5wZS5jb20wHhcNMDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYD
+VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5j
+b20wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDJ03rKDx6sp4boFmVq
+scIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5TzcqQsRNiekpsUOqHnJJAKClaO
+xdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpzbm3benhB6QiIEn6H
+LmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJGjMxCrFX
+uaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD
+yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+
+JrUV86f8hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60Q
+rLUk9TiRodZL2vG70t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyN
+BjNaooXlkDWgYlwWTvDjovoDGrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8L
+hij+0rnq49qlw0dpEuDb8PYZi+17cNcC1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIB
+QFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQDfo2/2n+iD5dPDNMN+9fR5XJ+
+HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNVHREEgagwgaWBD2lu
+Zm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4gLSBDSUYg
+QTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB
+BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAx
+MCBWaXRvcmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
+AQYwHQYDVR0OBBYEFB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUA
+A4ICAQB4pgwWSp9MiDrAyw6lFn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWb
+laQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9fbgakEyrkgPH7UIBzg/YsfqikuFgba56
+awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJOubv5vr8qhT/AQKM6WfxZSzwo
+JNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m5hzkQiCeR7Csg1lw
+LDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Pye6kfLqCT
+VyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk
+LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJb
+UjWumDqtujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/
+QnMFlEPVjjxOAToZpR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+
+naM8THLCV8Sg1Mw4J87VBp6iSNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGls
+QyYBNWNgVYkDOnXYukrZVP/u3oDYLdE41V4tC5h9Pmzb/CaIxw==
+-----END CERTIFICATE-----
+
+Microsec e-Szigno Root CA 2009
+-----BEGIN CERTIFICATE-----
+MIIECjCCAvKgAwIBAgIJAMJ+QwRORz8ZMA0GCSqGSIb3DQEBCwUAMIGCMQswCQYD
+VQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0
+ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0G
+CSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5odTAeFw0wOTA2MTYxMTMwMThaFw0y
+OTEyMzAxMTMwMThaMIGCMQswCQYDVQQGEwJIVTERMA8GA1UEBwwIQnVkYXBlc3Qx
+FjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNVBAMMHk1pY3Jvc2VjIGUtU3pp
+Z25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5mb0BlLXN6aWduby5o
+dTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOn4j/NjrdqG2KfgQvvP
+kd6mJviZpWNwrZuuyjNAfW2WbqEORO7hE52UQlKavXWFdCyoDh2Tthi3jCyoz/tc
+cbna7P7ofo/kLx2yqHWH2Leh5TvPmUpG0IMZfcChEhyVbUr02MelTTMuhTlAdX4U
+fIASmFDHQWe4oIBhVKZsTh/gnQ4H6cm6M+f+wFUoLAKApxn1ntxVUwOXewdI/5n7
+N4okxFnMUBBjjqqpGrCEGob5X7uxUG6k0QrM1XF+H6cbfPVTbiJfyyvm1HxdrtbC
+xkzlBQHZ7Vf8wSN5/PrIJIOV87VqUQHQd9bpEqH5GoP7ghu5sJf0dgYzQ0mg/wu1
++rUCAwEAAaOBgDB+MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
+A1UdDgQWBBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAfBgNVHSMEGDAWgBTLD8bfQkPM
+Pcu1SCOhGnqmKrs0aDAbBgNVHREEFDASgRBpbmZvQGUtc3ppZ25vLmh1MA0GCSqG
+SIb3DQEBCwUAA4IBAQDJ0Q5eLtXMs3w+y/w9/w0olZMEyL/azXm4Q5DwpL7v8u8h
+mLzU1F0G9u5C7DBsoKqpyvGvivo/C3NqPuouQH4frlRheesuCDfXI/OMn74dseGk
+ddug4lQUsbocKaQY9hK6ohQU4zE1yED/t+AFdlfBHFny+L/k7SViXITwfn4fs775
+tyERzAMBVnCnEJIeGzSBHq2cGsMEPO0CYdYeBvNfOofyK/FFh+U9rNHHV4S9a67c
+2Pm2G2JwCz02yULyMtd6YebS2z3PyKnJm9zbWETXbzivf3jTo60adbocwTZ8jx5t
+HMN1Rq41Bab2XD0h7lbwyYIiLXpUq3DDfSJlgnCW
+-----END CERTIFICATE-----
+
+Microsoft ECC Root Certificate Authority 2017
+-----BEGIN CERTIFICATE-----
+MIICWTCCAd+gAwIBAgIQZvI9r4fei7FK6gxXMQHC7DAKBggqhkjOPQQDAzBlMQsw
+CQYDVQQGEwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYD
+VQQDEy1NaWNyb3NvZnQgRUNDIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIw
+MTcwHhcNMTkxMjE4MjMwNjQ1WhcNNDIwNzE4MjMxNjA0WjBlMQswCQYDVQQGEwJV
+UzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYDVQQDEy1NaWNy
+b3NvZnQgRUNDIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTcwdjAQBgcq
+hkjOPQIBBgUrgQQAIgNiAATUvD0CQnVBEyPNgASGAlEvaqiBYgtlzPbKnR5vSmZR
+ogPZnZH6thaxjG7efM3beaYvzrvOcS/lpaso7GMEZpn4+vKTEAXhgShC48Zo9OYb
+hGBKia/teQ87zvH2RPUBeMCjVDBSMA4GA1UdDwEB/wQEAwIBhjAPBgNVHRMBAf8E
+BTADAQH/MB0GA1UdDgQWBBTIy5lycFIM+Oa+sgRXKSrPQhDtNTAQBgkrBgEEAYI3
+FQEEAwIBADAKBggqhkjOPQQDAwNoADBlAjBY8k3qDPlfXu5gKcs68tvWMoQZP3zV
+L8KxzJOuULsJMsbG7X7JNpQS5GiFBqIb0C8CMQCZ6Ra0DvpWSNSkMBaReNtUjGUB
+iudQZsIxtzm6uBoiB078a1QWIP8rtedMDE2mT3M=
+-----END CERTIFICATE-----
+
+Microsoft RSA Root Certificate Authority 2017
+-----BEGIN CERTIFICATE-----
+MIIFqDCCA5CgAwIBAgIQHtOXCV/YtLNHcB6qvn9FszANBgkqhkiG9w0BAQwFADBl
+MQswCQYDVQQGEwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYw
+NAYDVQQDEy1NaWNyb3NvZnQgUlNBIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5
+IDIwMTcwHhcNMTkxMjE4MjI1MTIyWhcNNDIwNzE4MjMwMDIzWjBlMQswCQYDVQQG
+EwJVUzEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMTYwNAYDVQQDEy1N
+aWNyb3NvZnQgUlNBIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5IDIwMTcwggIi
+MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDKW76UM4wplZEWCpW9R2LBifOZ
+Nt9GkMml7Xhqb0eRaPgnZ1AzHaGm++DlQ6OEAlcBXZxIQIJTELy/xztokLaCLeX0
+ZdDMbRnMlfl7rEqUrQ7eS0MdhweSE5CAg2Q1OQT85elss7YfUJQ4ZVBcF0a5toW1
+HLUX6NZFndiyJrDKxHBKrmCk3bPZ7Pw71VdyvD/IybLeS2v4I2wDwAW9lcfNcztm
+gGTjGqwu+UcF8ga2m3P1eDNbx6H7JyqhtJqRjJHTOoI+dkC0zVJhUXAoP8XFWvLJ
+jEm7FFtNyP9nTUwSlq31/niol4fX/V4ggNyhSyL71Imtus5Hl0dVe49FyGcohJUc
+aDDv70ngNXtk55iwlNpNhTs+VcQor1fznhPbRiefHqJeRIOkpcrVE7NLP8TjwuaG
+YaRSMLl6IE9vDzhTyzMMEyuP1pq9KsgtsRx9S1HKR9FIJ3Jdh+vVReZIZZ2vUpC6
+W6IYZVcSn2i51BVrlMRpIpj0M+Dt+VGOQVDJNE92kKz8OMHY4Xu54+OU4UZpyw4K
+UGsTuqwPN1q3ErWQgR5WrlcihtnJ0tHXUeOrO8ZV/R4O03QK0dqq6mm4lyiPSMQH
++FJDOvTKVTUssKZqwJz58oHhEmrARdlns87/I6KJClTUFLkqqNfs+avNJVgyeY+Q
+W5g5xAgGwax/Dj0ApQIDAQABo1QwUjAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/
+BAUwAwEB/zAdBgNVHQ4EFgQUCctZf4aycI8awznjwNnpv7tNsiMwEAYJKwYBBAGC
+NxUBBAMCAQAwDQYJKoZIhvcNAQEMBQADggIBAKyvPl3CEZaJjqPnktaXFbgToqZC
+LgLNFgVZJ8og6Lq46BrsTaiXVq5lQ7GPAJtSzVXNUzltYkyLDVt8LkS/gxCP81OC
+gMNPOsduET/m4xaRhPtthH80dK2Jp86519efhGSSvpWhrQlTM93uCupKUY5vVau6
+tZRGrox/2KJQJWVggEbbMwSubLWYdFQl3JPk+ONVFT24bcMKpBLBaYVu32TxU5nh
+SnUgnZUP5NbcA/FZGOhHibJXWpS2qdgXKxdJ5XbLwVaZOjex/2kskZGT4d9Mozd2
+TaGf+G0eHdP67Pv0RR0Tbc/3WeUiJ3IrhvNXuzDtJE3cfVa7o7P4NHmJweDyAmH3
+pvwPuxwXC65B2Xy9J6P9LjrRk5Sxcx0ki69bIImtt2dmefU6xqaWM/5TkshGsRGR
+xpl/j8nWZjEgQRCHLQzWwa80mMpkg/sTV9HB8Dx6jKXB/ZUhoHHBk2dxEuqPiApp
+GWSZI1b7rCoucL5mxAyE7+WL85MB+GqQk2dLsmijtWKP6T+MejteD+eMuMZ87zf9
+dOLITzNy4ZQ5bb0Sr74MTnB8G2+NszKTc0QWbej09+CVgI+WXTik9KveCjCHk9hN
+AHFiRSdLOkKEW39lt2c0Ui2cFmuqqNh7o0JMcccMyj6D5KbvtwEwXlGjefVwaaZB
+RA+GsCyRxj3qrg+E
+-----END CERTIFICATE-----
+
+NAVER Global Root Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIFojCCA4qgAwIBAgIUAZQwHqIL3fXFMyqxQ0Rx+NZQTQ0wDQYJKoZIhvcNAQEM
+BQAwaTELMAkGA1UEBhMCS1IxJjAkBgNVBAoMHU5BVkVSIEJVU0lORVNTIFBMQVRG
+T1JNIENvcnAuMTIwMAYDVQQDDClOQVZFUiBHbG9iYWwgUm9vdCBDZXJ0aWZpY2F0
+aW9uIEF1dGhvcml0eTAeFw0xNzA4MTgwODU4NDJaFw0zNzA4MTgyMzU5NTlaMGkx
+CzAJBgNVBAYTAktSMSYwJAYDVQQKDB1OQVZFUiBCVVNJTkVTUyBQTEFURk9STSBD
+b3JwLjEyMDAGA1UEAwwpTkFWRVIgR2xvYmFsIFJvb3QgQ2VydGlmaWNhdGlvbiBB
+dXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC21PGTXLVA
+iQqrDZBbUGOukJR0F0Vy1ntlWilLp1agS7gvQnXp2XskWjFlqxcX0TM62RHcQDaH
+38dq6SZeWYp34+hInDEW+j6RscrJo+KfziFTowI2MMtSAuXaMl3Dxeb57hHHi8lE
+HoSTGEq0n+USZGnQJoViAbbJAh2+g1G7XNr4rRVqmfeSVPc0W+m/6imBEtRTkZaz
+kVrd/pBzKPswRrXKCAfHcXLJZtM0l/aM9BhK4dA9WkW2aacp+yPOiNgSnABIqKYP
+szuSjXEOdMWLyEz59JuOuDxp7W87UC9Y7cSw0BwbagzivESq2M0UXZR4Yb8Obtoq
+vC8MC3GmsxY/nOb5zJ9TNeIDoKAYv7vxvvTWjIcNQvcGufFt7QSUqP620wbGQGHf
+nZ3zVHbOUzoBppJB7ASjjw2i1QnK1sua8e9DXcCrpUHPXFNwcMmIpi3Ua2FzUCaG
+YQ5fG8Ir4ozVu53BA0K6lNpfqbDKzE0K70dpAy8i+/Eozr9dUGWokG2zdLAIx6yo
+0es+nPxdGoMuK8u180SdOqcXYZaicdNwlhVNt0xz7hlcxVs+Qf6sdWA7G2POAN3a
+CJBitOUt7kinaxeZVL6HSuOpXgRM6xBtVNbv8ejyYhbLgGvtPe31HzClrkvJE+2K
+AQHJuFFYwGY6sWZLxNUxAmLpdIQM201GLQIDAQABo0IwQDAdBgNVHQ4EFgQU0p+I
+36HNLL3s9TsBAZMzJ7LrYEswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMB
+Af8wDQYJKoZIhvcNAQEMBQADggIBADLKgLOdPVQG3dLSLvCkASELZ0jKbY7gyKoN
+qo0hV4/GPnrK21HUUrPUloSlWGB/5QuOH/XcChWB5Tu2tyIvCZwTFrFsDDUIbatj
+cu3cvuzHV+YwIHHW1xDBE1UBjCpD5EHxzzp6U5LOogMFDTjfArsQLtk70pt6wKGm
++LUx5vR1yblTmXVHIloUFcd4G7ad6Qz4G3bxhYTeodoS76TiEJd6eN4MUZeoIUCL
+hr0N8F5OSza7OyAfikJW4Qsav3vQIkMsRIz75Sq0bBwcupTgE34h5prCy8VCZLQe
+lHsIJchxzIdFV4XTnyliIoNRlwAYl3dqmJLJfGBs32x9SuRwTMKeuB330DTHD8z7
+p/8Dvq1wkNoL3chtl1+afwkyQf3NosxabUzyqkn+Zvjp2DXrDige7kgvOtB5CTh8
+piKCk5XQA76+AqAF3SAi428diDRgxuYKuQl1C/AH6GmWNcf7I4GOODm4RStDeKLR
+LBT/DShycpWbXgnbiUSYqqFJu3FS8r/2/yehNq+4tneI3TqkbZs0kNwUXTC/t+sX
+5Ie3cdCh13cV1ELX8vMxmV2b3RZtP+oGI/hGoiLtk/bdmuYqh7GYVPEi92tF4+KO
+dh2ajcQGjTa3FPOdVGm3jjzVpG2Tgbet9r1ke8LJaDmgkpzNNIaRkPpkUZ3+/uul
+9XXeifdy
+-----END CERTIFICATE-----
+
+NetLock Arany =Class Gold= Fotanusitvany
+-----BEGIN CERTIFICATE-----
+MIIEFTCCAv2gAwIBAgIGSUEs5AAQMA0GCSqGSIb3DQEBCwUAMIGnMQswCQYDVQQG
+EwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFTATBgNVBAoMDE5ldExvY2sgS2Z0LjE3
+MDUGA1UECwwuVGFuw7pzw610dsOhbnlraWFkw7NrIChDZXJ0aWZpY2F0aW9uIFNl
+cnZpY2VzKTE1MDMGA1UEAwwsTmV0TG9jayBBcmFueSAoQ2xhc3MgR29sZCkgRsWR
+dGFuw7pzw610dsOhbnkwHhcNMDgxMjExMTUwODIxWhcNMjgxMjA2MTUwODIxWjCB
+pzELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFwZXN0MRUwEwYDVQQKDAxOZXRM
+b2NrIEtmdC4xNzA1BgNVBAsMLlRhbsO6c8OtdHbDoW55a2lhZMOzayAoQ2VydGlm
+aWNhdGlvbiBTZXJ2aWNlcykxNTAzBgNVBAMMLE5ldExvY2sgQXJhbnkgKENsYXNz
+IEdvbGQpIEbFkXRhbsO6c8OtdHbDoW55MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
+MIIBCgKCAQEAxCRec75LbRTDofTjl5Bu0jBFHjzuZ9lk4BqKf8owyoPjIMHj9DrT
+lF8afFttvzBPhCf2nx9JvMaZCpDyD/V/Q4Q3Y1GLeqVw/HpYzY6b7cNGbIRwXdrz
+AZAj/E4wqX7hJ2Pn7WQ8oLjJM2P+FpD/sLj916jAwJRDC7bVWaaeVtAkH3B5r9s5
+VA1lddkVQZQBr17s9o3x/61k/iCa11zr/qYfCGSji3ZVrR47KGAuhyXoqq8fxmRG
+ILdwfzzeSNuWU7c5d+Qa4scWhHaXWy+7GRWF+GmF9ZmnqfI0p6m2pgP8b4Y9VHx2
+BJtr+UBdADTHLpl1neWIA6pN+APSQnbAGwIDAKiLo0UwQzASBgNVHRMBAf8ECDAG
+AQH/AgEEMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUzPpnk/C2uNClwB7zU/2M
+U9+D15YwDQYJKoZIhvcNAQELBQADggEBAKt/7hwWqZw8UQCgwBEIBaeZ5m8BiFRh
+bvG5GK1Krf6BQCOUL/t1fC8oS2IkgYIL9WHxHG64YTjrgfpioTtaYtOUZcTh5m2C
++C8lcLIhJsFyUR+MLMOEkMNaj7rP9KdlpeuY0fsFskZ1FSNqb4VjMIDw1Z4fKRzC
+bLBQWV2QWzuoDTDPv31/zvGdg73JRm4gpvlhUbohL3u+pRVjodSVh/GeufOJ8z2F
+uLjbvrW5KfnaNwUASZQDhETnv0Mxz3WLJdH0pmT1kvarBes96aULNmLazAZfNou2
+XjG4Kvte9nHfRCaexOYNkbQudZWAUWpLMKawYqGT8ZvYzsRjdT9ZR7E=
+-----END CERTIFICATE-----
+
+Network Solutions Certificate Authority
+-----BEGIN CERTIFICATE-----
+MIID5jCCAs6gAwIBAgIQV8szb8JcFuZHFhfjkDFo4DANBgkqhkiG9w0BAQUFADBi
+MQswCQYDVQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMu
+MTAwLgYDVQQDEydOZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3Jp
+dHkwHhcNMDYxMjAxMDAwMDAwWhcNMjkxMjMxMjM1OTU5WjBiMQswCQYDVQQGEwJV
+UzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydO
+ZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggEiMA0GCSqG
+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkvH6SMG3G2I4rC7xGzuAnlt7e+foS0zwz
+c7MEL7xxjOWftiJgPl9dzgn/ggwbmlFQGiaJ3dVhXRncEg8tCqJDXRfQNJIg6nPP
+OCwGJgl6cvf6UDL4wpPTaaIjzkGxzOTVHzbRijr4jGPiFFlp7Q3Tf2vouAPlT2rl
+mGNpSAW+Lv8ztumXWWn4Zxmuk2GWRBXTcrA/vGp97Eh/jcOrqnErU2lBUzS1sLnF
+BgrEsEX1QV1uiUV7PTsmjHTC5dLRfbIR1PtYMiKagMnc/Qzpf14Dl847ABSHJ3A4
+qY5usyd2mFHgBeMhqxrVhSI8KbWaFsWAqPS7azCPL0YCorEMIuDTAgMBAAGjgZcw
+gZQwHQYDVR0OBBYEFCEwyfsA106Y2oeqKtCnLrFAMadMMA4GA1UdDwEB/wQEAwIB
+BjAPBgNVHRMBAf8EBTADAQH/MFIGA1UdHwRLMEkwR6BFoEOGQWh0dHA6Ly9jcmwu
+bmV0c29sc3NsLmNvbS9OZXR3b3JrU29sdXRpb25zQ2VydGlmaWNhdGVBdXRob3Jp
+dHkuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQC7rkvnt1frf6ott3NHhWrB5KUd5Oc8
+6fRZZXe1eltajSU24HqXLjjAV2CDmAaDn7l2em5Q4LqILPxFzBiwmZVRDuwduIj/
+h1AcgsLj4DKAv6ALR8jDMe+ZZzKATxcheQxpXN5eNK4CtSbqUN9/GGUsyfJj4akH
+/nxxH2szJGoeBfcFaMBqEssuXmHLrijTfsK0ZpEmXzwuJF/LWA/rKOyvEZbz3Htv
+wKeI8lN3s2Berq4o2jUsbzRF0ybh3uxbTydrFny9RAQYgrOJeRcQcT16ohZO9QHN
+pGxlaKFJdlxDydi8NmdspZS11My5vWo1ViHe2MPr+8ukYEywVaCge1ey
+-----END CERTIFICATE-----
+
+OISTE WISeKey Global Root GB CA
+-----BEGIN CERTIFICATE-----
+MIIDtTCCAp2gAwIBAgIQdrEgUnTwhYdGs/gjGvbCwDANBgkqhkiG9w0BAQsFADBt
+MQswCQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUg
+Rm91bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9i
+YWwgUm9vdCBHQiBDQTAeFw0xNDEyMDExNTAwMzJaFw0zOTEyMDExNTEwMzFaMG0x
+CzAJBgNVBAYTAkNIMRAwDgYDVQQKEwdXSVNlS2V5MSIwIAYDVQQLExlPSVNURSBG
+b3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9PSVNURSBXSVNlS2V5IEdsb2Jh
+bCBSb290IEdCIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2Be3
+HEokKtaXscriHvt9OO+Y9bI5mE4nuBFde9IllIiCFSZqGzG7qFshISvYD06fWvGx
+WuR51jIjK+FTzJlFXHtPrby/h0oLS5daqPZI7H17Dc0hBt+eFf1Biki3IPShehtX
+1F1Q/7pn2COZH8g/497/b1t3sWtuuMlk9+HKQUYOKXHQuSP8yYFfTvdv37+ErXNk
+u7dCjmn21HYdfp2nuFeKUWdy19SouJVUQHMD9ur06/4oQnc/nSMbsrY9gBQHTC5P
+99UKFg29ZkM3fiNDecNAhvVMKdqOmq0NpQSHiB6F4+lT1ZvIiwNjeOvgGUpuuy9r
+M2RYk61pv48b74JIxwIDAQABo1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUw
+AwEB/zAdBgNVHQ4EFgQUNQ/INmNe4qPs+TtmFc5RUuORmj0wEAYJKwYBBAGCNxUB
+BAMCAQAwDQYJKoZIhvcNAQELBQADggEBAEBM+4eymYGQfp3FsLAmzYh7KzKNbrgh
+cViXfa43FK8+5/ea4n32cZiZBKpDdHij40lhPnOMTZTg+XHEthYOU3gf1qKHLwI5
+gSk8rxWYITD+KJAAjNHhy/peyP34EEY7onhCkRd0VQreUGdNZtGn//3ZwLWoo4rO
+ZvUPQ82nK1d7Y0Zqqi5S2PTt4W2tKZB4SLrhI6qjiey1q5bAtEuiHZeeevJuQHHf
+aPFlTc58Bd9TZaml8LGXBHAVRgOY1NK/VLSgWH1Sb9pWJmLU2NuJMW8c8CLC02Ic
+Nc1MaRVUGpCY3useX8p3x8uOPUNpnJpY0CQ73xtAln41rYHHTnG6iBM=
+-----END CERTIFICATE-----
+
+OISTE WISeKey Global Root GC CA
+-----BEGIN CERTIFICATE-----
+MIICaTCCAe+gAwIBAgIQISpWDK7aDKtARb8roi066jAKBggqhkjOPQQDAzBtMQsw
+CQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUgRm91
+bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9iYWwg
+Um9vdCBHQyBDQTAeFw0xNzA1MDkwOTQ4MzRaFw00MjA1MDkwOTU4MzNaMG0xCzAJ
+BgNVBAYTAkNIMRAwDgYDVQQKEwdXSVNlS2V5MSIwIAYDVQQLExlPSVNURSBGb3Vu
+ZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9PSVNURSBXSVNlS2V5IEdsb2JhbCBS
+b290IEdDIENBMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAETOlQwMYPchi82PG6s4ni
+eUqjFqdrVCTbUf/q9Akkwwsin8tqJ4KBDdLArzHkdIJuyiXZjHWd8dvQmqJLIX4W
+p2OQ0jnUsYd4XxiWD1AbNTcPasbc2RNNpI6QN+a9WzGRo1QwUjAOBgNVHQ8BAf8E
+BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUSIcUrOPDnpBgOtfKie7T
+rYy0UGYwEAYJKwYBBAGCNxUBBAMCAQAwCgYIKoZIzj0EAwMDaAAwZQIwJsdpW9zV
+57LnyAyMjMPdeYwbY9XJUpROTYJKcx6ygISpJcBMWm1JKWB4E+J+SOtkAjEA2zQg
+Mgj/mkkCtojeFK9dbJlxjRo/i9fgojaGHAeCOnZT/cKi7e97sIBPWA9LUzm9
+-----END CERTIFICATE-----
+
+QuoVadis Root CA 1 G3
+-----BEGIN CERTIFICATE-----
+MIIFYDCCA0igAwIBAgIUeFhfLq0sGUvjNwc1NBMotZbUZZMwDQYJKoZIhvcNAQEL
+BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
+BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMSBHMzAeFw0xMjAxMTIxNzI3NDRaFw00
+MjAxMTIxNzI3NDRaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
+aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDEgRzMwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQCgvlAQjunybEC0BJyFuTHK3C3kEakEPBtV
+wedYMB0ktMPvhd6MLOHBPd+C5k+tR4ds7FtJwUrVu4/sh6x/gpqG7D0DmVIB0jWe
+rNrwU8lmPNSsAgHaJNM7qAJGr6Qc4/hzWHa39g6QDbXwz8z6+cZM5cOGMAqNF341
+68Xfuw6cwI2H44g4hWf6Pser4BOcBRiYz5P1sZK0/CPTz9XEJ0ngnjybCKOLXSoh
+4Pw5qlPafX7PGglTvF0FBM+hSo+LdoINofjSxxR3W5A2B4GbPgb6Ul5jxaYA/qXp
+UhtStZI5cgMJYr2wYBZupt0lwgNm3fME0UDiTouG9G/lg6AnhF4EwfWQvTA9xO+o
+abw4m6SkltFi2mnAAZauy8RRNOoMqv8hjlmPSlzkYZqn0ukqeI1RPToV7qJZjqlc
+3sX5kCLliEVx3ZGZbHqfPT2YfF72vhZooF6uCyP8Wg+qInYtyaEQHeTTRCOQiJ/G
+KubX9ZqzWB4vMIkIG1SitZgj7Ah3HJVdYdHLiZxfokqRmu8hqkkWCKi9YSgxyXSt
+hfbZxbGL0eUQMk1fiyA6PEkfM4VZDdvLCXVDaXP7a3F98N/ETH3Goy7IlXnLc6KO
+Tk0k+17kBL5yG6YnLUlamXrXXAkgt3+UuU/xDRxeiEIbEbfnkduebPRq34wGmAOt
+zCjvpUfzUwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
+BjAdBgNVHQ4EFgQUo5fW816iEOGrRZ88F2Q87gFwnMwwDQYJKoZIhvcNAQELBQAD
+ggIBABj6W3X8PnrHX3fHyt/PX8MSxEBd1DKquGrX1RUVRpgjpeaQWxiZTOOtQqOC
+MTaIzen7xASWSIsBx40Bz1szBpZGZnQdT+3Btrm0DWHMY37XLneMlhwqI2hrhVd2
+cDMT/uFPpiN3GPoajOi9ZcnPP/TJF9zrx7zABC4tRi9pZsMbj/7sPtPKlL92CiUN
+qXsCHKnQO18LwIE6PWThv6ctTr1NxNgpxiIY0MWscgKCP6o6ojoilzHdCGPDdRS5
+YCgtW2jgFqlmgiNR9etT2DGbe+m3nUvriBbP+V04ikkwj+3x6xn0dxoxGE1nVGwv
+b2X52z3sIexe9PSLymBlVNFxZPT5pqOBMzYzcfCkeF9OrYMh3jRJjehZrJ3ydlo2
+8hP0r+AJx2EqbPfgna67hkooby7utHnNkDPDs3b69fBsnQGQ+p6Q9pxyz0fawx/k
+NSBT8lTR32GDpgLiJTjehTItXnOQUl1CxM49S+H5GYQd1aJQzEH7QRTDvdbJWqNj
+ZgKAvQU6O0ec7AAmTPWIUb+oI38YB7AL7YsmoWTTYUrrXJ/es69nA7Mf3W1daWhp
+q1467HxpvMc7hU6eFbm0FU/DlXpY18ls6Wy58yljXrQs8C097Vpl4KlbQMJImYFt
+nh8GKjwStIsPm6Ik8KaN1nrgS7ZklmOVhMJKzRwuJIczYOXD
+-----END CERTIFICATE-----
+
+QuoVadis Root CA 2
+-----BEGIN CERTIFICATE-----
+MIIFtzCCA5+gAwIBAgICBQkwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0x
+GTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJv
+b3QgQ0EgMjAeFw0wNjExMjQxODI3MDBaFw0zMTExMjQxODIzMzNaMEUxCzAJBgNV
+BAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9W
+YWRpcyBSb290IENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCa
+GMpLlA0ALa8DKYrwD4HIrkwZhR0In6spRIXzL4GtMh6QRr+jhiYaHv5+HBg6XJxg
+Fyo6dIMzMH1hVBHL7avg5tKifvVrbxi3Cgst/ek+7wrGsxDp3MJGF/hd/aTa/55J
+WpzmM+Yklvc/ulsrHHo1wtZn/qtmUIttKGAr79dgw8eTvI02kfN/+NsRE8Scd3bB
+rrcCaoF6qUWD4gXmuVbBlDePSHFjIuwXZQeVikvfj8ZaCuWw419eaxGrDPmF60Tp
++ARz8un+XJiM9XOva7R+zdRcAitMOeGylZUtQofX1bOQQ7dsE/He3fbE+Ik/0XX1
+ksOR1YqI0JDs3G3eicJlcZaLDQP9nL9bFqyS2+r+eXyt66/3FsvbzSUr5R/7mp/i
+Ucw6UwxI5g69ybR2BlLmEROFcmMDBOAENisgGQLodKcftslWZvB1JdxnwQ5hYIiz
+PtGo/KPaHbDRsSNU30R2be1B2MGyIrZTHN81Hdyhdyox5C315eXbyOD/5YDXC2Og
+/zOhD7osFRXql7PSorW+8oyWHhqPHWykYTe5hnMz15eWniN9gqRMgeKh0bpnX5UH
+oycR7hYQe7xFSkyyBNKr79X9DFHOUGoIMfmR2gyPZFwDwzqLID9ujWc9Otb+fVuI
+yV77zGHcizN300QyNQliBJIWENieJ0f7OyHj+OsdWwIDAQABo4GwMIGtMA8GA1Ud
+EwEB/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBQahGK8SEwzJQTU7tD2
+A8QZRtGUazBuBgNVHSMEZzBlgBQahGK8SEwzJQTU7tD2A8QZRtGUa6FJpEcwRTEL
+MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMT
+ElF1b1ZhZGlzIFJvb3QgQ0EgMoICBQkwDQYJKoZIhvcNAQEFBQADggIBAD4KFk2f
+BluornFdLwUvZ+YTRYPENvbzwCYMDbVHZF34tHLJRqUDGCdViXh9duqWNIAXINzn
+g/iN/Ae42l9NLmeyhP3ZRPx3UIHmfLTJDQtyU/h2BwdBR5YM++CCJpNVjP4iH2Bl
+fF/nJrP3MpCYUNQ3cVX2kiF495V5+vgtJodmVjB3pjd4M1IQWK4/YY7yarHvGH5K
+WWPKjaJW1acvvFYfzznB4vsKqBUsfU16Y8Zsl0Q80m/DShcK+JDSV6IZUaUtl0Ha
+B0+pUNqQjZRG4T7wlP0QADj1O+hA4bRuVhogzG9Yje0uRY/W6ZM/57Es3zrWIozc
+hLsib9D45MY56QSIPMO661V6bYCZJPVsAfv4l7CUW+v90m/xd2gNNWQjrLhVoQPR
+TUIZ3Ph1WVaj+ahJefivDrkRoHy3au000LYmYjgahwz46P0u05B/B5EqHdZ+XIWD
+mbA4CD/pXvk1B+TJYm5Xf6dQlfe6yJvmjqIBxdZmv3lh8zwc4bmCXF2gw+nYSL0Z
+ohEUGW6yhhtoPkg3Goi3XZZenMfvJ2II4pEZXNLxId26F0KCl3GBUzGpn/Z9Yr9y
+4aOTHcyKJloJONDO1w2AFrR4pTqHTI2KpdVGl/IsELm8VCLAAVBpQ570su9t+Oza
+8eOx79+Rj1QqCyXBJhnEUhAFZdWCEOrCMc0u
+-----END CERTIFICATE-----
+
+QuoVadis Root CA 2 G3
+-----BEGIN CERTIFICATE-----
+MIIFYDCCA0igAwIBAgIURFc0JFuBiZs18s64KztbpybwdSgwDQYJKoZIhvcNAQEL
+BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
+BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMiBHMzAeFw0xMjAxMTIxODU5MzJaFw00
+MjAxMTIxODU5MzJaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
+aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDIgRzMwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQChriWyARjcV4g/Ruv5r+LrI3HimtFhZiFf
+qq8nUeVuGxbULX1QsFN3vXg6YOJkApt8hpvWGo6t/x8Vf9WVHhLL5hSEBMHfNrMW
+n4rjyduYNM7YMxcoRvynyfDStNVNCXJJ+fKH46nafaF9a7I6JaltUkSs+L5u+9ym
+c5GQYaYDFCDy54ejiK2toIz/pgslUiXnFgHVy7g1gQyjO/Dh4fxaXc6AcW34Sas+
+O7q414AB+6XrW7PFXmAqMaCvN+ggOp+oMiwMzAkd056OXbxMmO7FGmh77FOm6RQ1
+o9/NgJ8MSPsc9PG/Srj61YxxSscfrf5BmrODXfKEVu+lV0POKa2Mq1W/xPtbAd0j
+IaFYAI7D0GoT7RPjEiuA3GfmlbLNHiJuKvhB1PLKFAeNilUSxmn1uIZoL1NesNKq
+IcGY5jDjZ1XHm26sGahVpkUG0CM62+tlXSoREfA7T8pt9DTEceT/AFr2XK4jYIVz
+8eQQsSWu1ZK7E8EM4DnatDlXtas1qnIhO4M15zHfeiFuuDIIfR0ykRVKYnLP43eh
+vNURG3YBZwjgQQvD6xVu+KQZ2aKrr+InUlYrAoosFCT5v0ICvybIxo/gbjh9Uy3l
+7ZizlWNof/k19N+IxWA1ksB8aRxhlRbQ694Lrz4EEEVlWFA4r0jyWbYW8jwNkALG
+cC4BrTwV1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
+BjAdBgNVHQ4EFgQU7edvdlq/YOxJW8ald7tyFnGbxD0wDQYJKoZIhvcNAQELBQAD
+ggIBAJHfgD9DCX5xwvfrs4iP4VGyvD11+ShdyLyZm3tdquXK4Qr36LLTn91nMX66
+AarHakE7kNQIXLJgapDwyM4DYvmL7ftuKtwGTTwpD4kWilhMSA/ohGHqPHKmd+RC
+roijQ1h5fq7KpVMNqT1wvSAZYaRsOPxDMuHBR//47PERIjKWnML2W2mWeyAMQ0Ga
+W/ZZGYjeVYg3UQt4XAoeo0L9x52ID8DyeAIkVJOviYeIyUqAHerQbj5hLja7NQ4n
+lv1mNDthcnPxFlxHBlRJAHpYErAK74X9sbgzdWqTHBLmYF5vHX/JHyPLhGGfHoJE
++V+tYlUkmlKY7VHnoX6XOuYvHxHaU4AshZ6rNRDbIl9qxV6XU/IyAgkwo1jwDQHV
+csaxfGl7w/U2Rcxhbl5MlMVerugOXou/983g7aEOGzPuVBj+D77vfoRrQ+NwmNtd
+dbINWQeFFSM51vHfqSYP1kjHs6Yi9TM3WpVHn3u6GBVv/9YUZINJ0gpnIdsPNWNg
+KCLjsZWDzYWm3S8P52dSbrsvhXz1SnPnxT7AvSESBT/8twNJAlvIJebiVDj1eYeM
+HVOyToV7BjjHLPj4sHKNJeV3UvQDHEimUF+IIDBu8oJDqz2XhOdT+yHBTw8imoa4
+WSr2Rz0ZiC3oheGe7IUIarFsNMkd7EgrO3jtZsSOeWmD3n+M
+-----END CERTIFICATE-----
+
+QuoVadis Root CA 3
+-----BEGIN CERTIFICATE-----
+MIIGnTCCBIWgAwIBAgICBcYwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0x
+GTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJv
+b3QgQ0EgMzAeFw0wNjExMjQxOTExMjNaFw0zMTExMjQxOTA2NDRaMEUxCzAJBgNV
+BAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9W
+YWRpcyBSb290IENBIDMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDM
+V0IWVJzmmNPTTe7+7cefQzlKZbPoFog02w1ZkXTPkrgEQK0CSzGrvI2RaNggDhoB
+4hp7Thdd4oq3P5kazethq8Jlph+3t723j/z9cI8LoGe+AaJZz3HmDyl2/7FWeUUr
+H556VOijKTVopAFPD6QuN+8bv+OPEKhyq1hX51SGyMnzW9os2l2ObjyjPtr7guXd
+8lyyBTNvijbO0BNO/79KDDRMpsMhvVAEVeuxu537RR5kFd5VAYwCdrXLoT9Cabwv
+vWhDFlaJKjdhkf2mrk7AyxRllDdLkgbvBNDInIjbC3uBr7E9KsRlOni27tyAsdLT
+mZw67mtaa7ONt9XOnMK+pUsvFrGeaDsGb659n/je7Mwpp5ijJUMv7/FfJuGITfhe
+btfZFG4ZM2mnO4SJk8RTVROhUXhA+LjJou57ulJCg54U7QVSWllWp5f8nT8KKdjc
+T5EOE7zelaTfi5m+rJsziO+1ga8bxiJTyPbH7pcUsMV8eFLI8M5ud2CEpukqdiDt
+WAEXMJPpGovgc2PZapKUSU60rUqFxKMiMPwJ7Wgic6aIDFUhWMXhOp8q3crhkODZ
+c6tsgLjoC2SToJyMGf+z0gzskSaHirOi4XCPLArlzW1oUevaPwV/izLmE1xr/l9A
+4iLItLRkT9a6fUg+qGkM17uGcclzuD87nSVL2v9A6wIDAQABo4IBlTCCAZEwDwYD
+VR0TAQH/BAUwAwEB/zCB4QYDVR0gBIHZMIHWMIHTBgkrBgEEAb5YAAMwgcUwgZMG
+CCsGAQUFBwICMIGGGoGDQW55IHVzZSBvZiB0aGlzIENlcnRpZmljYXRlIGNvbnN0
+aXR1dGVzIGFjY2VwdGFuY2Ugb2YgdGhlIFF1b1ZhZGlzIFJvb3QgQ0EgMyBDZXJ0
+aWZpY2F0ZSBQb2xpY3kgLyBDZXJ0aWZpY2F0aW9uIFByYWN0aWNlIFN0YXRlbWVu
+dC4wLQYIKwYBBQUHAgEWIWh0dHA6Ly93d3cucXVvdmFkaXNnbG9iYWwuY29tL2Nw
+czALBgNVHQ8EBAMCAQYwHQYDVR0OBBYEFPLAE+CCQz777i9nMpY1XNu4ywLQMG4G
+A1UdIwRnMGWAFPLAE+CCQz777i9nMpY1XNu4ywLQoUmkRzBFMQswCQYDVQQGEwJC
+TTEZMBcGA1UEChMQUXVvVmFkaXMgTGltaXRlZDEbMBkGA1UEAxMSUXVvVmFkaXMg
+Um9vdCBDQSAzggIFxjANBgkqhkiG9w0BAQUFAAOCAgEAT62gLEz6wPJv92ZVqyM0
+7ucp2sNbtrCD2dDQ4iH782CnO11gUyeim/YIIirnv6By5ZwkajGxkHon24QRiSem
+d1o417+shvzuXYO8BsbRd2sPbSQvS3pspweWyuOEn62Iix2rFo1bZhfZFvSLgNLd
++LJ2w/w4E6oM3kJpK27zPOuAJ9v1pkQNn1pVWQvVDVJIxa6f8i+AxeoyUDUSly7B
+4f/xI4hROJ/yZlZ25w9Rl6VSDE1JUZU2Pb+iSwwQHYaZTKrzchGT5Or2m9qoXadN
+t54CrnMAyNojA+j56hl0YgCUyyIgvpSnWbWCar6ZeXqp8kokUvd0/bpO5qgdAm6x
+DYBEwa7TIzdfu4V8K5Iu6H6li92Z4b8nby1dqnuH/grdS/yO9SbkbnBCbjPsMZ57
+k8HkyWkaPcBrTiJt7qtYTcbQQcEr6k8Sh17rRdhs9ZgC06DYVYoGmRmioHfRMJ6s
+zHXug/WwYjnPbFfiTNKRCw51KBuav/0aQ/HKd/s7j2G4aSgWQgRecCocIdiP4b0j
+Wy10QJLZYxkNc91pvGJHvOB0K7Lrfb5BG7XARsWhIstfTsEokt4YutUqKLsRixeT
+mJlglFwjz1onl14LBQaTNx47aTbrqZ5hHY8y2o4M1nQ+ewkk2gF3R8Q7zTSMmfXK
+4SVhM7JZG+Ju1zdXtg2pEto=
+-----END CERTIFICATE-----
+
+QuoVadis Root CA 3 G3
+-----BEGIN CERTIFICATE-----
+MIIFYDCCA0igAwIBAgIULvWbAiin23r/1aOp7r0DoM8Sah0wDQYJKoZIhvcNAQEL
+BQAwSDELMAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAc
+BgNVBAMTFVF1b1ZhZGlzIFJvb3QgQ0EgMyBHMzAeFw0xMjAxMTIyMDI2MzJaFw00
+MjAxMTIyMDI2MzJaMEgxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBM
+aW1pdGVkMR4wHAYDVQQDExVRdW9WYWRpcyBSb290IENBIDMgRzMwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQCzyw4QZ47qFJenMioKVjZ/aEzHs286IxSR
+/xl/pcqs7rN2nXrpixurazHb+gtTTK/FpRp5PIpM/6zfJd5O2YIyC0TeytuMrKNu
+FoM7pmRLMon7FhY4futD4tN0SsJiCnMK3UmzV9KwCoWdcTzeo8vAMvMBOSBDGzXR
+U7Ox7sWTaYI+FrUoRqHe6okJ7UO4BUaKhvVZR74bbwEhELn9qdIoyhA5CcoTNs+c
+ra1AdHkrAj80//ogaX3T7mH1urPnMNA3I4ZyYUUpSFlob3emLoG+B01vr87ERROR
+FHAGjx+f+IdpsQ7vw4kZ6+ocYfx6bIrc1gMLnia6Et3UVDmrJqMz6nWB2i3ND0/k
+A9HvFZcba5DFApCTZgIhsUfei5pKgLlVj7WiL8DWM2fafsSntARE60f75li59wzw
+eyuxwHApw0BiLTtIadwjPEjrewl5qW3aqDCYz4ByA4imW0aucnl8CAMhZa634Ryl
+sSqiMd5mBPfAdOhx3v89WcyWJhKLhZVXGqtrdQtEPREoPHtht+KPZ0/l7DxMYIBp
+VzgeAVuNVejH38DMdyM0SXV89pgR6y3e7UEuFAUCf+D+IOs15xGsIs5XPd7JMG0Q
+A4XN8f+MFrXBsj6IbGB/kE+V9/YtrQE5BwT6dYB9v0lQ7e/JxHwc64B+27bQ3RP+
+ydOc17KXqQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
+BjAdBgNVHQ4EFgQUxhfQvKjqAkPyGwaZXSuQILnXnOQwDQYJKoZIhvcNAQELBQAD
+ggIBADRh2Va1EodVTd2jNTFGu6QHcrxfYWLopfsLN7E8trP6KZ1/AvWkyaiTt3px
+KGmPc+FSkNrVvjrlt3ZqVoAh313m6Tqe5T72omnHKgqwGEfcIHB9UqM+WXzBusnI
+FUBhynLWcKzSt/Ac5IYp8M7vaGPQtSCKFWGafoaYtMnCdvvMujAWzKNhxnQT5Wvv
+oxXqA/4Ti2Tk08HS6IT7SdEQTXlm66r99I0xHnAUrdzeZxNMgRVhvLfZkXdxGYFg
+u/BYpbWcC/ePIlUnwEsBbTuZDdQdm2NnL9DuDcpmvJRPpq3t/O5jrFc/ZSXPsoaP
+0Aj/uHYUbt7lJ+yreLVTubY/6CD50qi+YUbKh4yE8/nxoGibIh6BJpsQBJFxwAYf
+3KDTuVan45gtf4Od34wrnDKOMpTwATwiKp9Dwi7DmDkHOHv8XgBCH/MyJnmDhPbl
+8MFREsALHgQjDFSlTC9JxUrRtm5gDWv8a4uFJGS3iQ6rJUdbPM9+Sb3H6QrG2vd+
+DhcI00iX0HGS8A85PjRqHH3Y8iKuu2n0M7SmSFXRDw4m6Oy2Cy2nhTXN/VnIn9HN
+PlopNLk9hM6xZdRZkZFWdSHBd575euFgndOtBBj0fOtek49TSiIp+EgrPk2GrFt/
+ywaZWWDYWGWVjUTR939+J399roD1B0y2PpxxVJkES/1Y+Zj0
+-----END CERTIFICATE-----
+
+SSL
+-----BEGIN CERTIFICATE-----
+MIIClDCCAhqgAwIBAgIILCmcWxbtBZUwCgYIKoZIzj0EAwIwfzELMAkGA1UEBhMC
+VVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQKDA9T
+U0wgQ29ycG9yYXRpb24xNDAyBgNVBAMMK1NTTC5jb20gRVYgUm9vdCBDZXJ0aWZp
+Y2F0aW9uIEF1dGhvcml0eSBFQ0MwHhcNMTYwMjEyMTgxNTIzWhcNNDEwMjEyMTgx
+NTIzWjB/MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hv
+dXN0b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjE0MDIGA1UEAwwrU1NMLmNv
+bSBFViBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzB2MBAGByqGSM49
+AgEGBSuBBAAiA2IABKoSR5CYG/vvw0AHgyBO8TCCogbR8pKGYfL2IWjKAMTH6kMA
+VIbc/R/fALhBYlzccBYy3h+Z1MzFB8gIH2EWB1E9fVwHU+M1OIzfzZ/ZLg1Kthku
+WnBaBu2+8KGwytAJKaNjMGEwHQYDVR0OBBYEFFvKXuXe0oGqzagtZFG22XKbl+ZP
+MA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUW8pe5d7SgarNqC1kUbbZcpuX
+5k8wDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMCA2gAMGUCMQCK5kCJN+vp1RPZ
+ytRrJPOwPYdGWBrssd9v+1a6cGvHOMzosYxPD/fxZ3YOg9AeUY8CMD32IygmTMZg
+h5Mmm7I1HrrW9zzRHM76JTymGoEVW/MSD2zuZYrJh6j5B+BimoxcSg==
+-----END CERTIFICATE-----
+
+SSL
+-----BEGIN CERTIFICATE-----
+MIIF6zCCA9OgAwIBAgIIVrYpzTS8ePYwDQYJKoZIhvcNAQELBQAwgYIxCzAJBgNV
+BAYTAlVTMQ4wDAYDVQQIDAVUZXhhczEQMA4GA1UEBwwHSG91c3RvbjEYMBYGA1UE
+CgwPU1NMIENvcnBvcmF0aW9uMTcwNQYDVQQDDC5TU0wuY29tIEVWIFJvb3QgQ2Vy
+dGlmaWNhdGlvbiBBdXRob3JpdHkgUlNBIFIyMB4XDTE3MDUzMTE4MTQzN1oXDTQy
+MDUzMDE4MTQzN1owgYIxCzAJBgNVBAYTAlVTMQ4wDAYDVQQIDAVUZXhhczEQMA4G
+A1UEBwwHSG91c3RvbjEYMBYGA1UECgwPU1NMIENvcnBvcmF0aW9uMTcwNQYDVQQD
+DC5TU0wuY29tIEVWIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgUlNBIFIy
+MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAjzZlQOHWTcDXtOlG2mvq
+M0fNTPl9fb69LT3w23jhhqXZuglXaO1XPqDQCEGD5yhBJB/jchXQARr7XnAjssuf
+OePPxU7Gkm0mxnu7s9onnQqG6YE3Bf7wcXHswxzpY6IXFJ3vG2fThVUCAtZJycxa
+4bH3bzKfydQ7iEGonL3Lq9ttewkfokxykNorCPzPPFTOZw+oz12WGQvE43LrrdF9
+HSfvkusQv1vrO6/PgN3B0pYEW3p+pKk8OHakYo6gOV7qd89dAFmPZiw+B6KjBSYR
+aZfqhbcPlgtLyEDhULouisv3D5oi53+aNxPN8k0TayHRwMwi8qFG9kRpnMphNQcA
+b9ZhCBHqurj26bNg5U257J8UZslXWNvNh2n4ioYSA0e/ZhN2rHd9NCSFg83XqpyQ
+Gp8hLH94t2S42Oim9HizVcuE0jLEeK6jj2HdzghTreyI/BXkmg3mnxp3zkyPuBQV
+PWKchjgGAGYS5Fl2WlPAApiiECtoRHuOec4zSnaqW4EWG7WK2NAAe15itAnWhmMO
+pgWVSbooi4iTsjQc2KRVbrcc0N6ZVTsj9CLg+SlmJuwgUHfbSguPvuUCYHBBXtSu
+UDkiFCbLsjtzdFVHB3mBOagwE0TlBIqulhMlQg+5U8Sb/M3kHN48+qvWBkofZ6aY
+MBzdLNvcGJVXZsb/XItW9XcCAwEAAaNjMGEwDwYDVR0TAQH/BAUwAwEB/zAfBgNV
+HSMEGDAWgBT5YLvU49U09rj1BoAlp3PbRmmonjAdBgNVHQ4EFgQU+WC71OPVNPa4
+9QaAJadz20ZpqJ4wDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4ICAQBW
+s47LCp1Jjr+kxJG7ZhcFUZh1++VQLHqe8RT6q9OKPv+RKY9ji9i0qVQBDb6Thi/5
+Sm3HXvVX+cpVHBK+Rw82xd9qt9t1wkclf7nxY/hoLVUE0fKNsKTPvDxeH3jnpaAg
+cLAExbf3cqfeIg29MyVGjGSSJuM+LmOW2puMPfgYCdcDzH2GguDKBAdRUNf/ktUM
+79qGn5nX67evaOI5JpS6aLe/g9Pqemc9YmeuJeVy6OLk7K4S9ksrPJ/psEDzOFSz
+/bdoyNrGj1E8svuR3Bznm53htw1yj+KkxKl4+esUrMZDBcJlOSgYAsOCsp0FvmXt
+ll9ldDz7CTUue5wT/RsPXcdtgTpWD8w74a8CLyKsRspGPKAcTNZEtF4uXBVmCeEm
+Kf7GUmG6sXP/wwyc5WxqlD8UykAWlYTzWamsX0xhk23RO8yilQwipmdnRC652dKK
+QbNmC1r7fSOl8hqw/96bg5Qu0T/fkreRrwU7ZcegbLHNYhLDkBvjJc40vG93drEQ
+w/cFGsDWr3RiSBd3kmmQYRzelYB0VI8YHMPzA9C/pEN1hlMYegouCRw2n5H9gooi
+S9EOUCXdywMMF8mDAAhONU2Ki+3wApRmLER/y5UnlhetCTCstnEXbosX9hwJ1C07
+mKVx01QT2WDz9UtmT/rx7iASjbSsV7FFY6GsdqnC+w==
+-----END CERTIFICATE-----
+
+SSL
+-----BEGIN CERTIFICATE-----
+MIICjTCCAhSgAwIBAgIIdebfy8FoW6gwCgYIKoZIzj0EAwIwfDELMAkGA1UEBhMC
+VVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQKDA9T
+U0wgQ29ycG9yYXRpb24xMTAvBgNVBAMMKFNTTC5jb20gUm9vdCBDZXJ0aWZpY2F0
+aW9uIEF1dGhvcml0eSBFQ0MwHhcNMTYwMjEyMTgxNDAzWhcNNDEwMjEyMTgxNDAz
+WjB8MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0
+b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNvbSBS
+b290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IEVDQzB2MBAGByqGSM49AgEGBSuB
+BAAiA2IABEVuqVDEpiM2nl8ojRfLliJkP9x6jh3MCLOicSS6jkm5BBtHllirLZXI
+7Z4INcgn64mMU1jrYor+8FsPazFSY0E7ic3s7LaNGdM0B9y7xgZ/wkWV7Mt/qCPg
+CemB+vNH06NjMGEwHQYDVR0OBBYEFILRhXMw5zUE044CkvvlpNHEIejNMA8GA1Ud
+EwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUgtGFczDnNQTTjgKS++Wk0cQh6M0wDgYD
+VR0PAQH/BAQDAgGGMAoGCCqGSM49BAMCA2cAMGQCMG/n61kRpGDPYbCWe+0F+S8T
+kdzt5fxQaxFGRrMcIQBiu77D5+jNB5n5DQtdcj7EqgIwH7y6C+IwJPt8bYBVCpk+
+gA0z5Wajs6O7pdWLjwkspl1+4vAHCGht0nxpbl/f5Wpl
+-----END CERTIFICATE-----
+
+SSL
+-----BEGIN CERTIFICATE-----
+MIIF3TCCA8WgAwIBAgIIeyyb0xaAMpkwDQYJKoZIhvcNAQELBQAwfDELMAkGA1UE
+BhMCVVMxDjAMBgNVBAgMBVRleGFzMRAwDgYDVQQHDAdIb3VzdG9uMRgwFgYDVQQK
+DA9TU0wgQ29ycG9yYXRpb24xMTAvBgNVBAMMKFNTTC5jb20gUm9vdCBDZXJ0aWZp
+Y2F0aW9uIEF1dGhvcml0eSBSU0EwHhcNMTYwMjEyMTczOTM5WhcNNDEwMjEyMTcz
+OTM5WjB8MQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hv
+dXN0b24xGDAWBgNVBAoMD1NTTCBDb3Jwb3JhdGlvbjExMC8GA1UEAwwoU1NMLmNv
+bSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFJTQTCCAiIwDQYJKoZIhvcN
+AQEBBQADggIPADCCAgoCggIBAPkP3aMrfcvQKv7sZ4Wm5y4bunfh4/WvpOz6Sl2R
+xFdHaxh3a3by/ZPkPQ/CFp4LZsNWlJ4Xg4XOVu/yFv0AYvUiCVToZRdOQbngT0aX
+qhvIuG5iXmmxX9sqAn78bMrzQdjt0Oj8P2FI7bADFB0QDksZ4LtO7IZl/zbzXmcC
+C52GVWH9ejjt/uIZALdvoVBidXQ8oPrIJZK0bnoix/geoeOy3ZExqysdBP+lSgQ3
+6YWkMyv94tZVNHwZpEpox7Ko07fKoZOI68GXvIz5HdkihCR0xwQ9aqkpk8zruFvh
+/l8lqjRYyMEjVJ0bmBHDOJx+PYZspQ9AhnwC9FwCTyjLrnGfDzrIM/4RJTXq/LrF
+YD3ZfBjVsqnTdXgDciLKOsMf7yzlLqn6niy2UUb9rwPW6mBo6oUWNmuF6R7As93E
+JNyAKoFBbZQ+yODJgUEAnl6/f8UImKIYLEJAs/lvOCdLToD0PYFH4Ih86hzOtXVc
+US4cK38acijnALXRdMbX5J+tB5O2UzU1/Dfkw/ZdFr4hc96SCvigY2q8lpJqPvi8
+ZVWb3vUNiSYE/CUapiVpy8JtynziWV+XrOvvLsi81xtZPCvM8hnIk2snYxnP/Okm
++Mpxm3+T/jRnhE6Z6/yzeAkzcLpmpnbtG3PrGqUNxCITIJRWCk4sbE6x/c+cCbqi
+M+2HAgMBAAGjYzBhMB0GA1UdDgQWBBTdBAkHovV6fVJTEpKV7jiAJQ2mWTAPBgNV
+HRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFN0ECQei9Xp9UlMSkpXuOIAlDaZZMA4G
+A1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAgEAIBgRlCn7Jp0cHh5wYfGV
+cpNxJK1ok1iOMq8bs3AD/CUrdIWQPXhq9LmLpZc7tRiRux6n+UBbkflVma8eEdBc
+Hadm47GUBwwyOabqG7B52B2ccETjit3E+ZUfijhDPwGFpUenPUayvOUiaPd7nNgs
+PgohyC0zrL/FgZkxdMF1ccW+sfAjRfSda/wZY52jvATGGAslu1OJD7OAUN5F7kR/
+q5R4ZJjT9ijdh9hwZXT7DrkT66cPYakylszeu+1jTBi7qUD3oFRuIIhxdRjqerQ0
+cuAjJ3dctpDqhiVAq+8zD8ufgr6iIPv2tS0a5sKFsXQP+8hlAqRSAUfdSSLBv9jr
+a6x+3uxjMxW3IwiPxg+NQVrdjsW5j+VFP3jbutIbQLH+cU0/4IGiul607BXgk90I
+H37hVZkLId6Tngr75qNJvTYw/ud3sqB1l7UtgYgXZSD32pAAn8lSzDLKNXz1PQ/Y
+K9f1JmzJBjSWFupwWRoyeXkLtoh/D1JIPb9s2KJELtFOt3JY04kTlf5Eq/jXixtu
+nLwsoFvVagCvXzfh1foQC5ichucmj87w7G6KVwuA406ywKBjYZC6VWg3dGq2ktuf
+oYYitmUnDuy2n0Jg5GfCtdpBC8TTi2EbvPofkSvXRAdeuims2cXp71NIWuuA8ShY
+Ic2wBlX7Jz9TkHCpBB5XJ7k=
+-----END CERTIFICATE-----
+
+SZAFIR ROOT CA2
+-----BEGIN CERTIFICATE-----
+MIIDcjCCAlqgAwIBAgIUPopdB+xV0jLVt+O2XwHrLdzk1uQwDQYJKoZIhvcNAQEL
+BQAwUTELMAkGA1UEBhMCUEwxKDAmBgNVBAoMH0tyYWpvd2EgSXpiYSBSb3psaWN6
+ZW5pb3dhIFMuQS4xGDAWBgNVBAMMD1NaQUZJUiBST09UIENBMjAeFw0xNTEwMTkw
+NzQzMzBaFw0zNTEwMTkwNzQzMzBaMFExCzAJBgNVBAYTAlBMMSgwJgYDVQQKDB9L
+cmFqb3dhIEl6YmEgUm96bGljemVuaW93YSBTLkEuMRgwFgYDVQQDDA9TWkFGSVIg
+Uk9PVCBDQTIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC3vD5QqEvN
+QLXOYeeWyrSh2gwisPq1e3YAd4wLz32ohswmUeQgPYUM1ljj5/QqGJ3a0a4m7utT
+3PSQ1hNKDJA8w/Ta0o4NkjrcsbH/ON7Dui1fgLkCvUqdGw+0w8LBZwPd3BucPbOw
+3gAeqDRHu5rr/gsUvTaE2g0gv/pby6kWIK05YO4vdbbnl5z5Pv1+TW9NL++IDWr6
+3fE9biCloBK0TXC5ztdyO4mTp4CEHCdJckm1/zuVnsHMyAHs6A6KCpbns6aH5db5
+BSsNl0BwPLqsdVqc1U2dAgrSS5tmS0YHF2Wtn2yIANwiieDhZNRnvDF5YTy7ykHN
+XGoAyDw4jlivAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD
+AgEGMB0GA1UdDgQWBBQuFqlKGLXLzPVvUPMjX/hd56zwyDANBgkqhkiG9w0BAQsF
+AAOCAQEAtXP4A9xZWx126aMqe5Aosk3AM0+qmrHUuOQn/6mWmc5G4G18TKI4pAZw
+8PRBEew/R40/cof5O/2kbytTAOD/OblqBw7rHRz2onKQy4I9EYKL0rufKq8h5mOG
+nXkZ7/e7DDWQw4rtTw/1zBLZpD67oPwglV9PJi8RI4NOdQcPv5vRtB3pEAT+ymCP
+oky4rc/hkA/NrgrHXXu3UNLUYfrVFdvXn4dRVOul4+vJhaAlIDf7js4MNIThPIGy
+d05DpYhfhmehPea0XGG2Ptv+tyjFogeutcrKjSoS75ftwjCkySp6+/NNIxuZMzSg
+LvWpCz/UXeHPhJ/iGcJfitYgHuNztw==
+-----END CERTIFICATE-----
+
+SecureSign RootCA11
+-----BEGIN CERTIFICATE-----
+MIIDbTCCAlWgAwIBAgIBATANBgkqhkiG9w0BAQUFADBYMQswCQYDVQQGEwJKUDEr
+MCkGA1UEChMiSmFwYW4gQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcywgSW5jLjEcMBoG
+A1UEAxMTU2VjdXJlU2lnbiBSb290Q0ExMTAeFw0wOTA0MDgwNDU2NDdaFw0yOTA0
+MDgwNDU2NDdaMFgxCzAJBgNVBAYTAkpQMSswKQYDVQQKEyJKYXBhbiBDZXJ0aWZp
+Y2F0aW9uIFNlcnZpY2VzLCBJbmMuMRwwGgYDVQQDExNTZWN1cmVTaWduIFJvb3RD
+QTExMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA/XeqpRyQBTvLTJsz
+i1oURaTnkBbR31fSIRCkF/3frNYfp+TbfPfs37gD2pRY/V1yfIw/XwFndBWW4wI8
+h9uuywGOwvNmxoVF9ALGOrVisq/6nL+k5tSAMJjzDbaTj6nU2DbysPyKyiyhFTOV
+MdrAG/LuYpmGYz+/3ZMqg6h2uRMft85OQoWPIucuGvKVCbIFtUROd6EgvanyTgp9
+UK31BQ1FT0Zx/Sg+U/sE2C3XZR1KG/rPO7AxmjVuyIsG0wCR8pQIZUyxNAYAeoni
+8McDWc/V1uinMrPmmECGxc0nEovMe863ETxiYAcjPitAbpSACW22s293bzUIUPsC
+h8U+iQIDAQABo0IwQDAdBgNVHQ4EFgQUW/hNT7KlhtQ60vFjmqC+CfZXt94wDgYD
+VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB
+AKChOBZmLqdWHyGcBvod7bkixTgm2E5P7KN/ed5GIaGHd48HCJqypMWvDzKYC3xm
+KbabfSVSSUOrTC4rbnpwrxYO4wJs+0LmGJ1F2FXI6Dvd5+H0LgscNFxsWEr7jIhQ
+X5Ucv+2rIrVls4W6ng+4reV6G4pQOh29Dbx7VFALuUKvVaAYga1lme++5Jy/xIWr
+QbJUb9wlze144o4MjQlJ3WN7WmmWAiGovVJZ6X01y8hSyn+B/tlr0/cR7SXf+Of5
+pPpyl4RTDaXQMhhRdlkUbA/r7F+AjHVDg8OFmP9Mni0N5HeDk061lgeLKBObjBmN
+QSdJQO7e5iNEOdyhIta6A/I=
+-----END CERTIFICATE-----
+
+SecureTrust CA
+-----BEGIN CERTIFICATE-----
+MIIDuDCCAqCgAwIBAgIQDPCOXAgWpa1Cf/DrJxhZ0DANBgkqhkiG9w0BAQUFADBI
+MQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24x
+FzAVBgNVBAMTDlNlY3VyZVRydXN0IENBMB4XDTA2MTEwNzE5MzExOFoXDTI5MTIz
+MTE5NDA1NVowSDELMAkGA1UEBhMCVVMxIDAeBgNVBAoTF1NlY3VyZVRydXN0IENv
+cnBvcmF0aW9uMRcwFQYDVQQDEw5TZWN1cmVUcnVzdCBDQTCCASIwDQYJKoZIhvcN
+AQEBBQADggEPADCCAQoCggEBAKukgeWVzfX2FI7CT8rU4niVWJxB4Q2ZQCQXOZEz
+Zum+4YOvYlyJ0fwkW2Gz4BERQRwdbvC4u/jep4G6pkjGnx29vo6pQT64lO0pGtSO
+0gMdA+9tDWccV9cGrcrI9f4Or2YlSASWC12juhbDCE/RRvgUXPLIXgGZbf2IzIao
+wW8xQmxSPmjL8xk037uHGFaAJsTQ3MBv396gwpEWoGQRS0S8Hvbn+mPeZqx2pHGj
+7DaUaHp3pLHnDi+BeuK1cobvomuL8A/b01k/unK8RCSc43Oz969XL0Imnal0ugBS
+8kvNU3xHCzaFDmapCJcWNFfBZveA4+1wVMeT4C4oFVmHursCAwEAAaOBnTCBmjAT
+BgkrBgEEAYI3FAIEBh4EAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB
+/zAdBgNVHQ4EFgQUQjK2FvoE/f5dS3rD/fdMQB1aQ68wNAYDVR0fBC0wKzApoCeg
+JYYjaHR0cDovL2NybC5zZWN1cmV0cnVzdC5jb20vU1RDQS5jcmwwEAYJKwYBBAGC
+NxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEBADDtT0rhWDpSclu1pqNlGKa7UTt3
+6Z3q059c4EVlew3KW+JwULKUBRSuSceNQQcSc5R+DCMh/bwQf2AQWnL1mA6s7Ll/
+3XpvXdMc9P+IBWlCqQVxyLesJugutIxq/3HcuLHfmbx8IVQr5Fiiu1cprp6poxkm
+D5kuCLDv/WnPmRoJjeOnnyvJNjR7JLN4TJUXpAYmHrZkUjZfYGfZnMUFdAvnZyPS
+CPyI6a6Lf+Ew9Dd+/cYy2i2eRDAwbO4H3tI0/NL/QPZL9GZGBlSm8jIKYyYwa5vR
+3ItHuuG51WLQoqD0ZwV4KWMabwTW+MZMo5qxN7SN5ShLHZ4swrhovO0C7jE=
+-----END CERTIFICATE-----
+
+Secure Global CA
+-----BEGIN CERTIFICATE-----
+MIIDvDCCAqSgAwIBAgIQB1YipOjUiolN9BPI8PjqpTANBgkqhkiG9w0BAQUFADBK
+MQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24x
+GTAXBgNVBAMTEFNlY3VyZSBHbG9iYWwgQ0EwHhcNMDYxMTA3MTk0MjI4WhcNMjkx
+MjMxMTk1MjA2WjBKMQswCQYDVQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3Qg
+Q29ycG9yYXRpb24xGTAXBgNVBAMTEFNlY3VyZSBHbG9iYWwgQ0EwggEiMA0GCSqG
+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvNS7YrGxVaQZx5RNoJLNP2MwhR/jxYDiJ
+iQPpvepeRlMJ3Fz1Wuj3RSoC6zFh1ykzTM7HfAo3fg+6MpjhHZevj8fcyTiW89sa
+/FHtaMbQbqR8JNGuQsiWUGMu4P51/pinX0kuleM5M2SOHqRfkNJnPLLZ/kG5VacJ
+jnIFHovdRIWCQtBJwB1g8NEXLJXr9qXBkqPFwqcIYA1gBBCWeZ4WNOaptvolRTnI
+HmX5k/Wq8VLcmZg9pYYaDDUz+kulBAYVHDGA76oYa8J719rO+TMg1fW9ajMtgQT7
+sFzUnKPiXB3jqUJ1XnvUd+85VLrJChgbEplJL4hL/VBi0XPnj3pDAgMBAAGjgZ0w
+gZowEwYJKwYBBAGCNxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQF
+MAMBAf8wHQYDVR0OBBYEFK9EBMJBfkiD2045AuzshHrmzsmkMDQGA1UdHwQtMCsw
+KaAnoCWGI2h0dHA6Ly9jcmwuc2VjdXJldHJ1c3QuY29tL1NHQ0EuY3JsMBAGCSsG
+AQQBgjcVAQQDAgEAMA0GCSqGSIb3DQEBBQUAA4IBAQBjGghAfaReUw132HquHw0L
+URYD7xh8yOOvaliTFGCRsoTciE6+OYo68+aCiV0BN7OrJKQVDpI1WkpEXk5X+nXO
+H0jOZvQ8QCaSmGwb7iRGDBezUqXbpZGRzzfTb+cnCDpOGR86p1hcF895P4vkp9Mm
+I50mD1hp/Ed+stCNi5O/KU9DaXR2Z0vPB4zmAve14bRDtUstFJ/53CYNv6ZHdAbY
+iNE6KTCEztI5gGIbqMdXSbxqVVFnFUq+NQfk1XWYN3kwFNspnWzFacxHVaIw98xc
+f8LDmBxrThaA63p4ZUWiABqvDA1VZDRIuJK58bRQKfJPIx/abKwfROHdI3hRW8cW
+-----END CERTIFICATE-----
+
+Security Communication RootCA2
+-----BEGIN CERTIFICATE-----
+MIIDdzCCAl+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBdMQswCQYDVQQGEwJKUDEl
+MCMGA1UEChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEnMCUGA1UECxMe
+U2VjdXJpdHkgQ29tbXVuaWNhdGlvbiBSb290Q0EyMB4XDTA5MDUyOTA1MDAzOVoX
+DTI5MDUyOTA1MDAzOVowXTELMAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRy
+dXN0IFN5c3RlbXMgQ08uLExURC4xJzAlBgNVBAsTHlNlY3VyaXR5IENvbW11bmlj
+YXRpb24gUm9vdENBMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANAV
+OVKxUrO6xVmCxF1SrjpDZYBLx/KWvNs2l9amZIyoXvDjChz335c9S672XewhtUGr
+zbl+dp+++T42NKA7wfYxEUV0kz1XgMX5iZnK5atq1LXaQZAQwdbWQonCv/Q4EpVM
+VAX3NuRFg3sUZdbcDE3R3n4MqzvEFb46VqZab3ZpUql6ucjrappdUtAtCms1FgkQ
+hNBqyjoGADdH5H5XTz+L62e4iKrFvlNVspHEfbmwhRkGeC7bYRr6hfVKkaHnFtWO
+ojnflLhwHyg/i/xAXmODPIMqGplrz95Zajv8bxbXH/1KEOtOghY6rCcMU/Gt1SSw
+awNQwS08Ft1ENCcadfsCAwEAAaNCMEAwHQYDVR0OBBYEFAqFqXdlBZh8QIH4D5cs
+OPEK7DzPMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
+DQEBCwUAA4IBAQBMOqNErLlFsceTfsgLCkLfZOoc7llsCLqJX2rKSpWeeo8HxdpF
+coJxDjrSzG+ntKEju/Ykn8sX/oymzsLS28yN/HH8AynBbF0zX2S2ZTuJbxh2ePXc
+okgfGT+Ok+vx+hfuzU7jBBJV1uXk3fs+BXziHV7Gp7yXT2g69ekuCkO2r1dcYmh8
+t/2jioSgrGK+KwmHNPBqAbubKVY8/gA3zyNs8U6qtnRGEmyR7jTV7JqR50S+kDFy
+1UkC9gLl9B/rfNmWVan/7Ir5mUf/NVoCqgTLiluHcSmRvaS0eg29mvVXIwAHIRc/
+SjnRBUkLp7Y3gaVdjKozXoEofKd9J+sAro03
+-----END CERTIFICATE-----
+
+Security Communication Root CA
+-----BEGIN CERTIFICATE-----
+MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEY
+MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21t
+dW5pY2F0aW9uIFJvb3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5
+WjBQMQswCQYDVQQGEwJKUDEYMBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYD
+VQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3
+DQEBAQUAA4IBDwAwggEKAoIBAQCzs/5/022x7xZ8V6UMbXaKL0u/ZPtM7orw8yl8
+9f/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzGjGdnSj74cbAZJ6kJ
+DKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1aeV+7AwFb9
+Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq/N
+QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJ
+xrHty8OVYNEP8Ktw+N/LTX7s1vqr2b1/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0G
+A1UdDgQWBBSgc0mZaNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0T
+AQH/BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vG
+kl3g0dNq/vu+m22/xwVtWSDEHPC32oRYAmP6SBbvT6UL90qY8j+eG61Ha2POCEfr
+Uj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7KaEIkQmywszo+zenaSMQVy+n5
+Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKqL8aJdkNAExNnPaJU
+JRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfcioU+tHXot
+RSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T/zOLjw9XARYvz6buyXAiFL39vmwLAw==
+-----END CERTIFICATE-----
+
+Staat der Nederlanden EV Root CA
+-----BEGIN CERTIFICATE-----
+MIIFcDCCA1igAwIBAgIEAJiWjTANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJO
+TDEeMBwGA1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSkwJwYDVQQDDCBTdGFh
+dCBkZXIgTmVkZXJsYW5kZW4gRVYgUm9vdCBDQTAeFw0xMDEyMDgxMTE5MjlaFw0y
+MjEyMDgxMTEwMjhaMFgxCzAJBgNVBAYTAk5MMR4wHAYDVQQKDBVTdGFhdCBkZXIg
+TmVkZXJsYW5kZW4xKTAnBgNVBAMMIFN0YWF0IGRlciBOZWRlcmxhbmRlbiBFViBS
+b290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA48d+ifkkSzrS
+M4M1LGns3Amk41GoJSt5uAg94JG6hIXGhaTK5skuU6TJJB79VWZxXSzFYGgEt9nC
+UiY4iKTWO0Cmws0/zZiTs1QUWJZV1VD+hq2kY39ch/aO5ieSZxeSAgMs3NZmdO3d
+Z//BYY1jTw+bbRcwJu+r0h8QoPnFfxZpgQNH7R5ojXKhTbImxrpsX23Wr9GxE46p
+rfNeaXUmGD5BKyF/7otdBwadQ8QpCiv8Kj6GyzyDOvnJDdrFmeK8eEEzduG/L13l
+pJhQDBXd4Pqcfzho0LKmeqfRMb1+ilgnQ7O6M5HTp5gVXJrm0w912fxBmJc+qiXb
+j5IusHsMX/FjqTf5m3VpTCgmJdrV8hJwRVXj33NeN/UhbJCONVrJ0yPr08C+eKxC
+KFhmpUZtcALXEPlLVPxdhkqHz3/KRawRWrUgUY0viEeXOcDPusBCAUCZSCELa6fS
+/ZbV0b5GnUngC6agIk440ME8MLxwjyx1zNDFjFE7PZQIZCZhfbnDZY8UnCHQqv0X
+cgOPvZuM5l5Tnrmd74K74bzickFbIZTTRTeU0d8JOV3nI6qaHcptqAqGhYqCvkIH
+1vI4gnPah1vlPNOePqc7nvQDs/nxfRN0Av+7oeX6AHkcpmZBiFxgV6YuCcS6/ZrP
+px9Aw7vMWgpVSzs4dlG4Y4uElBbmVvMCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB
+/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFP6rAJCYniT8qcwaivsnuL8wbqg7
+MA0GCSqGSIb3DQEBCwUAA4ICAQDPdyxuVr5Os7aEAJSrR8kN0nbHhp8dB9O2tLsI
+eK9p0gtJ3jPFrK3CiAJ9Brc1AsFgyb/E6JTe1NOpEyVa/m6irn0F3H3zbPB+po3u
+2dfOWBfoqSmuc0iH55vKbimhZF8ZE/euBhD/UcabTVUlT5OZEAFTdfETzsemQUHS
+v4ilf0X8rLiltTMMgsT7B/Zq5SWEXwbKwYY5EdtYzXc7LMJMD16a4/CrPmEbUCTC
+wPTxGfARKbalGAKb12NMcIxHowNDXLldRqANb/9Zjr7dn3LDWyvfjFvO5QxGbJKy
+CqNMVEIYFRIYvdr8unRu/8G2oGTYqV9Vrp9canaW2HNnh/tNf1zuacpzEPuKqf2e
+vTY4SUmH9A4U8OmHuD+nT3pajnnUk+S7aFKErGzp85hwVXIy+TSrK0m1zSBi5Dp6
+Z2Orltxtrpfs/J92VoguZs9btsmksNcFuuEnL5O7Jiqik7Ab846+HUCjuTaPPoIa
+Gl6I6lD4WeKDRikL40Rc4ZW2aZCaFG+XroHPaO+Zmr615+F/+PoTRxZMzG0IQOeL
+eG9QgkRQP2YGiqtDhFZKDyAthg710tvSeopLzaXoTvFeJiUBWSOgftL2fiFX1ye8
+FVdMpEbB4IMeDExNH08GGeL5qPQ6gqGyeUN51q1veieQA6TqJIc/2b3Z6fJfUEkc
+7uzXLg==
+-----END CERTIFICATE-----
+
+Starfield Class 2 CA
+-----BEGIN CERTIFICATE-----
+MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzEl
+MCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMp
+U3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQw
+NjI5MTczOTE2WhcNMzQwNjI5MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UE
+ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZp
+ZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEgMA0GCSqGSIb3
+DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N78gDGIc/oav7PKaf
+8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMej2YcOadN
++lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0
+X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aa
+K4UmkhynArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA
+1W4TNSNe35tfPe/W93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0G
+A1UdDgQWBBS/X7fRzt0fhvRbVazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fR
+zt0fhvRbVazc1xDCDqmI56FspGowaDELMAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0
+YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAsTKVN0YXJmaWVsZCBD
+bGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8w
+DQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1epoXkJKtv3
+L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D
+eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJl
+xy16paq8U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynp
+VSJYACPq4xJDKVtHCN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEY
+WQPJIrSPnNVeKtelttQKbfi3QBFGmh95DmK/D5fs4C8fF5Q=
+-----END CERTIFICATE-----
+
+Starfield Root Certificate Authority - G2
+-----BEGIN CERTIFICATE-----
+MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMx
+EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
+HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVs
+ZCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAw
+MFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6
+b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVj
+aG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQgUm9vdCBDZXJ0aWZp
+Y2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
+ggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg
+nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1
+HOZ/5FSuS/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/N
+Hwtjuzqd+/x5AJhhdM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dN
+dloedl40wOiWVpmKs/B/pM293DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0
+HZbUJtQIBFnQmA4O5t78w+wfkPECAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO
+BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n2TB/xH1oo2Kooc6rB1snMA0G
+CSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWUXuEok21iXQnCoKjU
+sHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox9g61DLu3
+4jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg
+8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/K
+pL/QlwVKvOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1
+mMpYjn0q7pBZc2T5NnReJaH1ZgUufzkVqSr7UIuOhWn0
+-----END CERTIFICATE-----
+
+Starfield Services Root Certificate Authority - G2
+-----BEGIN CERTIFICATE-----
+MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMx
+EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoT
+HFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVs
+ZCBTZXJ2aWNlcyBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5
+MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYD
+VQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYDVQQKExxTdGFy
+ZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJTdGFyZmllbGQgU2Vy
+dmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZI
+hvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p
+OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm2
+8xpWriu2dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1K
+Ts9DkTvnVtYAcMtS7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufe
+hRhJfGZOozptqbXuNC66DQO4M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk
+6mFBrMnUVN+HL8cisibMn1lUaJ/8viovxFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAw
+DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFJxfAN+q
+AdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBLNqaEd2ndOxmfZyMI
+bw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynVv/heyNXB
+ve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z
+qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkd
+iEDPfUYd/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn
+0q23KXB56jzaYyWf/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCN
+sSi6
+-----END CERTIFICATE-----
+
+SwissSign Gold CA - G2
+-----BEGIN CERTIFICATE-----
+MIIFujCCA6KgAwIBAgIJALtAHEP1Xk+wMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
+BAYTAkNIMRUwEwYDVQQKEwxTd2lzc1NpZ24gQUcxHzAdBgNVBAMTFlN3aXNzU2ln
+biBHb2xkIENBIC0gRzIwHhcNMDYxMDI1MDgzMDM1WhcNMzYxMDI1MDgzMDM1WjBF
+MQswCQYDVQQGEwJDSDEVMBMGA1UEChMMU3dpc3NTaWduIEFHMR8wHQYDVQQDExZT
+d2lzc1NpZ24gR29sZCBDQSAtIEcyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
+CgKCAgEAr+TufoskDhJuqVAtFkQ7kpJcyrhdhJJCEyq8ZVeCQD5XJM1QiyUqt2/8
+76LQwB8CJEoTlo8jE+YoWACjR8cGp4QjK7u9lit/VcyLwVcfDmJlD909Vopz2q5+
+bbqBHH5CjCA12UNNhPqE21Is8w4ndwtrvxEvcnifLtg+5hg3Wipy+dpikJKVyh+c
+6bM8K8vzARO/Ws/BtQpgvd21mWRTuKCWs2/iJneRjOBiEAKfNA+k1ZIzUd6+jbqE
+emA8atufK+ze3gE/bk3lUIbLtK/tREDFylqM2tIrfKjuvqblCqoOpd8FUrdVxyJd
+MmqXl2MT28nbeTZ7hTpKxVKJ+STnnXepgv9VHKVxaSvRAiTysybUa9oEVeXBCsdt
+MDeQKuSeFDNeFhdVxVu1yzSJkvGdJo+hB9TGsnhQ2wwMC3wLjEHXuendjIj3o02y
+MszYF9rNt85mndT9Xv+9lz4pded+p2JYryU0pUHHPbwNUMoDAw8IWh+Vc3hiv69y
+FGkOpeUDDniOJihC8AcLYiAQZzlG+qkDzAQ4embvIIO1jEpWjpEA/I5cgt6IoMPi
+aG59je883WX0XaxR7ySArqpWl2/5rX3aYT+YdzylkbYcjCbaZaIJbcHiVOO5ykxM
+gI93e2CaHt+28kgeDrpOVG2Y4OGiGqJ3UM/EY5LsRxmd6+ZrzsECAwEAAaOBrDCB
+qTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUWyV7
+lqRlUX64OfPAeGZe6Drn8O4wHwYDVR0jBBgwFoAUWyV7lqRlUX64OfPAeGZe6Drn
+8O4wRgYDVR0gBD8wPTA7BglghXQBWQECAQEwLjAsBggrBgEFBQcCARYgaHR0cDov
+L3JlcG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBACe6
+45R88a7A3hfm5djV9VSwg/S7zV4Fe0+fdWavPOhWfvxyeDgD2StiGwC5+OlgzczO
+UYrHUDFu4Up+GC9pWbY9ZIEr44OE5iKHjn3g7gKZYbge9LgriBIWhMIxkziWMaa5
+O1M/wySTVltpkuzFwbs4AOPsF6m43Md8AYOfMke6UiI0HTJ6CVanfCU2qT1L2sCC
+bwq7EsiHSycR+R4tx5M/nttfJmtS2S6K8RTGRI0Vqbe/vd6mGu6uLftIdxf+u+yv
+GPUqUfA5hJeVbG4bwyvEdGB5JbAKJ9/fXtI5z0V9QkvfsywexcZdylU6oJxpmo/a
+77KwPJ+HbBIrZXAVUjEaJM9vMSNQH4xPjyPDdEFjHFWoFN0+4FFQz/EbMFYOkrCC
+hdiDyyJkvC24JdVUorgG6q2SpCSgwYa1ShNqR88uC1aVVMvOmttqtKay20EIhid3
+92qgQmwLOM7XdVAyksLfKzAiSNDVQTglXaTpXZ/GlHXQRf0wl0OPkKsKx4ZzYEpp
+Ld6leNcG2mqeSz53OiATIgHQv2ieY2BrNU0LbbqhPcCT4H8js1WtciVORvnSFu+w
+ZMEBnunKoGqYDs/YYPIvSbjkQuE4NRb0yG5P94FW6LqjviOvrv1vA+ACOzB2+htt
+Qc8Bsem4yWb02ybzOqR08kkkW8mw0FfB+j564ZfJ
+-----END CERTIFICATE-----
+
+SwissSign Silver CA - G2
+-----BEGIN CERTIFICATE-----
+MIIFvTCCA6WgAwIBAgIITxvUL1S7L0swDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UE
+BhMCQ0gxFTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWdu
+IFNpbHZlciBDQSAtIEcyMB4XDTA2MTAyNTA4MzI0NloXDTM2MTAyNTA4MzI0Nlow
+RzELMAkGA1UEBhMCQ0gxFTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMY
+U3dpc3NTaWduIFNpbHZlciBDQSAtIEcyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
+MIICCgKCAgEAxPGHf9N4Mfc4yfjDmUO8x/e8N+dOcbpLj6VzHVxumK4DV644N0Mv
+Fz0fyM5oEMF4rhkDKxD6LHmD9ui5aLlV8gREpzn5/ASLHvGiTSf5YXu6t+WiE7br
+YT7QbNHm+/pe7R20nqA1W6GSy/BJkv6FCgU+5tkL4k+73JU3/JHpMjUi0R86TieF
+nbAVlDLaYQ1HTWBCrpJH6INaUFjpiou5XaHc3ZlKHzZnu0jkg7Y360g6rw9njxcH
+6ATK72oxh9TAtvmUcXtnZLi2kUpCe2UuMGoM9ZDulebyzYLs2aFK7PayS+VFheZt
+eJMELpyCbTapxDFkH4aDCyr0NQp4yVXPQbBH6TCfmb5hqAaEuSh6XzjZG6k4sIN/
+c8HDO0gqgg8hm7jMqDXDhBuDsz6+pJVpATqJAHgE2cn0mRmrVn5bi4Y5FZGkECwJ
+MoBgs5PAKrYYC51+jUnyEEp/+dVGLxmSo5mnJqy7jDzmDrxHB9xzUfFwZC8I+bRH
+HTBsROopN4WSaGa8gzj+ezku01DwH/teYLappvonQfGbGHLy9YR0SslnxFSuSGTf
+jNFusB3hB48IHpmccelM2KX3RxIfdNFRnobzwqIjQAtz20um53MGjMGg6cFZrEb6
+5i/4z3GcRm25xBWNOHkDRUjvxF3XCO6HOSKGsg0PWEP3calILv3q1h8CAwEAAaOB
+rDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU
+F6DNweRBtjpbO8tFnb0cwpj6hlgwHwYDVR0jBBgwFoAUF6DNweRBtjpbO8tFnb0c
+wpj6hlgwRgYDVR0gBD8wPTA7BglghXQBWQEDAQEwLjAsBggrBgEFBQcCARYgaHR0
+cDovL3JlcG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIB
+AHPGgeAn0i0P4JUw4ppBf1AsX19iYamGamkYDHRJ1l2E6kFSGG9YrVBWIGrGvShp
+WJHckRE1qTodvBqlYJ7YH39FkWnZfrt4csEGDyrOj4VwYaygzQu4OSlWhDJOhrs9
+xCrZ1x9y7v5RoSJBsXECYxqCsGKrXlcSH9/L3XWgwF15kIwb4FDm3jH+mHtwX6WQ
+2K34ArZv02DdQEsixT2tOnqfGhpHkXkzuoLcMmkDlm4fS/Bx/uNncqCxv1yL5PqZ
+IseEuRuNI5c/7SXgz2W79WEE790eslpBIlqhn10s6FvJbakMDHiqYMZWjwFaDGi8
+aRl5xB9+lwW/xekkUV7U1UtT7dkjWjYDZaPBA61BMPNGG4WQr2W11bHkFlt4dR2X
+em1ZqSqPe97Dh4kQmUlzeMg9vVE1dCrV8X5pGyq7O70luJpaPXJhkGaH7gzWTdQR
+dAtq/gsD/KNVV4n+SsuuWxcFyPKNIzFTONItaj+CuY0IavdeQXRuwxF+B6wpYJE/
+OMpXEA29MC/HpeZBoNquBYeaoKRlbEwJDIm6uNO5wJOKMPqN5ZprFQFOZ6raYlY+
+hAhm0sQ2fac+EPyI4NSA5QC9qvNOBqN6avlicuMJT+ubDgEj8Z+7fNzcbBGXJbLy
+tGMU0gYqZ4yD9c7qB9iaah7s5Aq7KkzrCWA5zspi2C5u
+-----END CERTIFICATE-----
+
+T-TeleSec GlobalRoot Class 2
+-----BEGIN CERTIFICATE-----
+MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUx
+KzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAd
+BgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNl
+YyBHbG9iYWxSb290IENsYXNzIDIwHhcNMDgxMDAxMTA0MDE0WhcNMzMxMDAxMjM1
+OTU5WjCBgjELMAkGA1UEBhMCREUxKzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnBy
+aXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50
+ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNzIDIwggEiMA0G
+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCqX9obX+hzkeXaXPSi5kfl82hVYAUd
+AqSzm1nzHoqvNK38DcLZSBnuaY/JIPwhqgcZ7bBcrGXHX+0CfHt8LRvWurmAwhiC
+FoT6ZrAIxlQjgeTNuUk/9k9uN0goOA/FvudocP05l03Sx5iRUKrERLMjfTlH6VJi
+1hKTXrcxlkIF+3anHqP1wvzpesVsqXFP6st4vGCvx9702cu+fjOlbpSD8DT6Iavq
+jnKgP6TeMFvvhk1qlVtDRKgQFRzlAVfFmPHmBiiRqiDFt1MmUUOyCxGVWOHAD3bZ
+wI18gfNycJ5v/hqO2V81xrJvNHy+SE/iWjnX2J14np+GPgNeGYtEotXHAgMBAAGj
+QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS/
+WSA2AHmgoCJrjNXyYdK4LMuCSjANBgkqhkiG9w0BAQsFAAOCAQEAMQOiYQsfdOhy
+NsZt+U2e+iKo4YFWz827n+qrkRk4r6p8FU3ztqONpfSO9kSpp+ghla0+AGIWiPAC
+uvxhI+YzmzB6azZie60EI4RYZeLbK4rnJVM3YlNfvNoBYimipidx5joifsFvHZVw
+IEoHNN/q/xWA5brXethbdXwFeilHfkCoMRN3zUA7tFFHei4R40cR3p1m0IvVVGb6
+g1XqfMIpiRvpb7PO4gWEyS8+eIVibslfwXhjdFjASBgMmTnrpMwatXlajRWc2BQN
+9noHV8cigwUtPJslJj0Ys6lDfMjIq2SPDqO/nBudMNva0Bkuqjzx+zOAduTNrRlP
+BSeOE6Fuwg==
+-----END CERTIFICATE-----
+
+T-TeleSec GlobalRoot Class 3
+-----BEGIN CERTIFICATE-----
+MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUx
+KzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAd
+BgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNl
+YyBHbG9iYWxSb290IENsYXNzIDMwHhcNMDgxMDAxMTAyOTU2WhcNMzMxMDAxMjM1
+OTU5WjCBgjELMAkGA1UEBhMCREUxKzApBgNVBAoMIlQtU3lzdGVtcyBFbnRlcnBy
+aXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lzdGVtcyBUcnVzdCBDZW50
+ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNzIDMwggEiMA0G
+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9dZPwYiJvJK7genasfb3ZJNW4t/zN
+8ELg63iIVl6bmlQdTQyK9tPPcPRStdiTBONGhnFBSivwKixVA9ZIw+A5OO3yXDw/
+RLyTPWGrTs0NvvAgJ1gORH8EGoel15YUNpDQSXuhdfsaa3Ox+M6pCSzyU9XDFES4
+hqX2iys52qMzVNn6chr3IhUciJFrf2blw2qAsCTz34ZFiP0Zf3WHHx+xGwpzJFu5
+ZeAsVMhg02YXP+HMVDNzkQI6pn97djmiH5a2OK61yJN0HZ65tOVgnS9W0eDrXltM
+EnAMbEQgqxHY9Bn20pxSN+f6tsIxO0rUFJmtxxr1XV/6B7h8DR/Wgx6zAgMBAAGj
+QjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS1
+A/d2O2GCahKqGFPrAyGUv/7OyjANBgkqhkiG9w0BAQsFAAOCAQEAVj3vlNW92nOy
+WL6ukK2YJ5f+AbGwUgC4TeQbIXQbfsDuXmkqJa9c1h3a0nnJ85cp4IaH3gRZD/FZ
+1GSFS5mvJQQeyUapl96Cshtwn5z2r3Ex3XsFpSzTucpH9sry9uetuUg/vBa3wW30
+6gmv7PO15wWeph6KU1HWk4HMdJP2udqmJQV0eVp+QD6CSyYRMG7hP0HHRwA11fXT
+91Q+gT3aSWqas+8QPebrb9HIIkfLzM8BMZLZGOMivgkeGj5asuRrDFR6fUNOuIml
+e9eiPZaGzPImNC1qkp2aGtAw4l1OBLBfiyB+d8E9lYLRRpo7PHi4b6HQDWSieB4p
+TpPDpFQUWw==
+-----END CERTIFICATE-----
+
+TUBITAK Kamu SM SSL Kok Sertifikasi - Surum 1
+-----BEGIN CERTIFICATE-----
+MIIEYzCCA0ugAwIBAgIBATANBgkqhkiG9w0BAQsFADCB0jELMAkGA1UEBhMCVFIx
+GDAWBgNVBAcTD0dlYnplIC0gS29jYWVsaTFCMEAGA1UEChM5VHVya2l5ZSBCaWxp
+bXNlbCB2ZSBUZWtub2xvamlrIEFyYXN0aXJtYSBLdXJ1bXUgLSBUVUJJVEFLMS0w
+KwYDVQQLEyRLYW11IFNlcnRpZmlrYXN5b24gTWVya2V6aSAtIEthbXUgU00xNjA0
+BgNVBAMTLVRVQklUQUsgS2FtdSBTTSBTU0wgS29rIFNlcnRpZmlrYXNpIC0gU3Vy
+dW0gMTAeFw0xMzExMjUwODI1NTVaFw00MzEwMjUwODI1NTVaMIHSMQswCQYDVQQG
+EwJUUjEYMBYGA1UEBxMPR2ViemUgLSBLb2NhZWxpMUIwQAYDVQQKEzlUdXJraXll
+IEJpbGltc2VsIHZlIFRla25vbG9qaWsgQXJhc3Rpcm1hIEt1cnVtdSAtIFRVQklU
+QUsxLTArBgNVBAsTJEthbXUgU2VydGlmaWthc3lvbiBNZXJrZXppIC0gS2FtdSBT
+TTE2MDQGA1UEAxMtVFVCSVRBSyBLYW11IFNNIFNTTCBLb2sgU2VydGlmaWthc2kg
+LSBTdXJ1bSAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr3UwM6q7
+a9OZLBI3hNmNe5eA027n/5tQlT6QlVZC1xl8JoSNkvoBHToP4mQ4t4y86Ij5iySr
+LqP1N+RAjhgleYN1Hzv/bKjFxlb4tO2KRKOrbEz8HdDc72i9z+SqzvBV96I01INr
+N3wcwv61A+xXzry0tcXtAA9TNypN9E8Mg/uGz8v+jE69h/mniyFXnHrfA2eJLJ2X
+YacQuFWQfw4tJzh03+f92k4S400VIgLI4OD8D62K18lUUMw7D8oWgITQUVbDjlZ/
+iSIzL+aFCr2lqBs23tPcLG07xxO9WSMs5uWk99gL7eqQQESolbuT1dCANLZGeA4f
+AJNG4e7p+exPFwIDAQABo0IwQDAdBgNVHQ4EFgQUZT/HiobGPN08VFw1+DrtUgxH
+V8gwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEL
+BQADggEBACo/4fEyjq7hmFxLXs9rHmoJ0iKpEsdeV31zVmSAhHqT5Am5EM2fKifh
+AHe+SMg1qIGf5LgsyX8OsNJLN13qudULXjS99HMpw+0mFZx+CFOKWI3QSyjfwbPf
+IPP54+M638yclNhOT8NrF7f3cuitZjO1JVOr4PhMqZ398g26rrnZqsZr+ZO7rqu4
+lzwDGrpDxpa5RXI4s6ehlj2Re37AIVNMh+3yC1SVUZPVIqUNivGTDj5UDrDYyU7c
+8jEyVupk+eq1nRZmQnLzf9OxMUP8pI4X8W0jq5Rm+K37DwhuJi1/FwcJsoz7UMCf
+lo3Ptv0AnVoUmr8CRPXBwp8iXqIPoeM=
+-----END CERTIFICATE-----
+
+TWCA Global Root CA
+-----BEGIN CERTIFICATE-----
+MIIFQTCCAymgAwIBAgICDL4wDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVFcx
+EjAQBgNVBAoTCVRBSVdBTi1DQTEQMA4GA1UECxMHUm9vdCBDQTEcMBoGA1UEAxMT
+VFdDQSBHbG9iYWwgUm9vdCBDQTAeFw0xMjA2MjcwNjI4MzNaFw0zMDEyMzExNTU5
+NTlaMFExCzAJBgNVBAYTAlRXMRIwEAYDVQQKEwlUQUlXQU4tQ0ExEDAOBgNVBAsT
+B1Jvb3QgQ0ExHDAaBgNVBAMTE1RXQ0EgR2xvYmFsIFJvb3QgQ0EwggIiMA0GCSqG
+SIb3DQEBAQUAA4ICDwAwggIKAoICAQCwBdvI64zEbooh745NnHEKH1Jw7W2CnJfF
+10xORUnLQEK1EjRsGcJ0pDFfhQKX7EMzClPSnIyOt7h52yvVavKOZsTuKwEHktSz
+0ALfUPZVr2YOy+BHYC8rMjk1Ujoog/h7FsYYuGLWRyWRzvAZEk2tY/XTP3VfKfCh
+MBwqoJimFb3u/Rk28OKRQ4/6ytYQJ0lM793B8YVwm8rqqFpD/G2Gb3PpN0Wp8DbH
+zIh1HrtsBv+baz4X7GGqcXzGHaL3SekVtTzWoWH1EfcFbx39Eb7QMAfCKbAJTibc
+46KokWofwpFFiFzlmLhxpRUZyXx1EcxwdE8tmx2RRP1WKKD+u4ZqyPpcC1jcxkt2
+yKsi2XMPpfRaAok/T54igu6idFMqPVMnaR1sjjIsZAAmY2E2TqNGtz99sy2sbZCi
+laLOz9qC5wc0GZbpuCGqKX6mOL6OKUohZnkfs8O1CWfe1tQHRvMq2uYiN2DLgbYP
+oA/pyJV/v1WRBXrPPRXAb94JlAGD1zQbzECl8LibZ9WYkTunhHiVJqRaCPgrdLQA
+BDzfuBSO6N+pjWxnkjMdwLfS7JLIvgm/LCkFbwJrnu+8vyq8W8BQj0FwcYeyTbcE
+qYSjMq+u7msXi7Kx/mzhkIyIqJdIzshNy/MGz19qCkKxHh53L46g5pIOBvwFItIm
+4TFRfTLcDwIDAQABoyMwITAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
+/zANBgkqhkiG9w0BAQsFAAOCAgEAXzSBdu+WHdXltdkCY4QWwa6gcFGn90xHNcgL
+1yg9iXHZqjNB6hQbbCEAwGxCGX6faVsgQt+i0trEfJdLjbDorMjupWkEmQqSpqsn
+LhpNgb+E1HAerUf+/UqdM+DyucRFCCEK2mlpc3INvjT+lIutwx4116KD7+U4x6WF
+H6vPNOw/KP4M8VeGTslV9xzU2KV9Bnpv1d8Q34FOIWWxtuEXeZVFBs5fzNxGiWNo
+RI2T9GRwoD2dKAXDOXC4Ynsg/eTb6QihuJ49CcdP+yz4k3ZB3lLg4VfSnQO8d57+
+nile98FRYB/e2guyLXW3Q0iT5/Z5xoRdgFlglPx4mI88k1HtQJAH32RjJMtOcQWh
+15QaiDLxInQirqWm2BJpTGCjAu4r7NRjkgtevi92a6O2JryPA9gK8kxkRr05YuWW
+6zRjESjMlfGt7+/cgFhI6Uu46mWs6fyAtbXIRfmswZ/ZuepiiI7E8UuDEq3mi4TW
+nsLrgxifarsbJGAzcMzs9zLzXNl5fe+epP7JI8Mk7hWSsT2RTyaGvWZzJBPqpK5j
+wa19hAM8EHiGG3njxPPyBJUgriOCxLM6AGK/5jYk4Ve6xx6QddVfP5VhK8E7zeWz
+aGHQRiapIVJpLesux+t3zqY6tQMzT3bR51xUAV3LePTJDL/PEo4XLSNolOer/qmy
+KwbQBM0=
+-----END CERTIFICATE-----
+
+TWCA Root Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzES
+MBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFU
+V0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMz
+WhcNMzAxMjMxMTU1OTU5WjBfMQswCQYDVQQGEwJUVzESMBAGA1UECgwJVEFJV0FO
+LUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFUV0NBIFJvb3QgQ2VydGlm
+aWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
+AQCwfnK4pAOU5qfeCTiRShFAh6d8WWQUe7UREN3+v9XAu1bihSX0NXIP+FPQQeFE
+AcK0HMMxQhZHhTMidrIKbw/lJVBPhYa+v5guEGcevhEFhgWQxFnQfHgQsIBct+HH
+K3XLfJ+utdGdIzdjp9xCoi2SBBtQwXu4PhvJVgSLL1KbralW6cH/ralYhzC2gfeX
+RfwZVzsrb+RH9JlF/h3x+JejiB03HFyP4HYlmlD4oFT/RJB2I9IyxsOrBr/8+7/z
+rX2SYgJbKdM1o5OaQ2RgXbL6Mv87BK9NQGr5x+PvI/1ry+UPizgN7gr8/g+YnzAx
+3WxSZfmLgb4i4RxYA7qRG4kHAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
+HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqOFsmjd6LWvJPelSDGRjjCDWmujANBgkq
+hkiG9w0BAQUFAAOCAQEAPNV3PdrfibqHDAhUaiBQkr6wQT25JmSDCi/oQMCXKCeC
+MErJk/9q56YAf4lCmtYR5VPOL8zy2gXE/uJQxDqGfczafhAJO5I1KlOy/usrBdls
+XebQ79NqZp4VKIV66IIArB6nCWlWQtNoURi+VJq/REG6Sb4gumlc7rh3zc5sH62D
+lhh9DrUUOYTxKOkto557HnpyWoOzeW/vtPzQCqVYT0bf+215WfKEIlKuD8z7fDvn
+aspHYcN6+NOSBB+4IIThNlQWx0DeO4pz3N/GCUzf7Nr/1FNCocnyYh0igzyXxfkZ
+YiesZSLX0zzG5Y6yU8xJzrww/nsOM5D77dIUkR8Hrw==
+-----END CERTIFICATE-----
+
+TeliaSonera Root CA v1
+-----BEGIN CERTIFICATE-----
+MIIFODCCAyCgAwIBAgIRAJW+FqD3LkbxezmCcvqLzZYwDQYJKoZIhvcNAQEFBQAw
+NzEUMBIGA1UECgwLVGVsaWFTb25lcmExHzAdBgNVBAMMFlRlbGlhU29uZXJhIFJv
+b3QgQ0EgdjEwHhcNMDcxMDE4MTIwMDUwWhcNMzIxMDE4MTIwMDUwWjA3MRQwEgYD
+VQQKDAtUZWxpYVNvbmVyYTEfMB0GA1UEAwwWVGVsaWFTb25lcmEgUm9vdCBDQSB2
+MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMK+6yfwIaPzaSZVfp3F
+VRaRXP3vIb9TgHot0pGMYzHw7CTww6XScnwQbfQ3t+XmfHnqjLWCi65ItqwA3GV1
+7CpNX8GH9SBlK4GoRz6JI5UwFpB/6FcHSOcZrr9FZ7E3GwYq/t75rH2D+1665I+X
+Z75Ljo1kB1c4VWk0Nj0TSO9P4tNmHqTPGrdeNjPUtAa9GAH9d4RQAEX1jF3oI7x+
+/jXh7VB7qTCNGdMJjmhnXb88lxhTuylixcpecsHHltTbLaC0H2kD7OriUPEMPPCs
+81Mt8Bz17Ww5OXOAFshSsCPN4D7c3TxHoLs1iuKYaIu+5b9y7tL6pe0S7fyYGKkm
+dtwoSxAgHNN/Fnct7W+A90m7UwW7XWjH1Mh1Fj+JWov3F0fUTPHSiXk+TT2YqGHe
+Oh7S+F4D4MHJHIzTjU3TlTazN19jY5szFPAtJmtTfImMMsJu7D0hADnJoWjiUIMu
+sDor8zagrC/kb2HCUQk5PotTubtn2txTuXZZNp1D5SDgPTJghSJRt8czu90VL6R4
+pgd7gUY2BIbdeTXHlSw7sKMXNeVzH7RcWe/a6hBle3rQf5+ztCo3O3CLm1u5K7fs
+slESl1MpWtTwEhDcTwK7EpIvYtQ/aUN8Ddb8WHUBiJ1YFkveupD/RwGJBmr2X7KQ
+arMCpgKIv7NHfirZ1fpoeDVNAgMBAAGjPzA9MA8GA1UdEwEB/wQFMAMBAf8wCwYD
+VR0PBAQDAgEGMB0GA1UdDgQWBBTwj1k4ALP1j5qWDNXr+nuqF+gTEjANBgkqhkiG
+9w0BAQUFAAOCAgEAvuRcYk4k9AwI//DTDGjkk0kiP0Qnb7tt3oNmzqjMDfz1mgbl
+dxSR651Be5kqhOX//CHBXfDkH1e3damhXwIm/9fH907eT/j3HEbAek9ALCI18Bmx
+0GtnLLCo4MBANzX2hFxc469CeP6nyQ1Q6g2EdvZR74NTxnr/DlZJLo961gzmJ1Tj
+TQpgcmLNkQfWpb/ImWvtxBnmq0wROMVvMeJuScg/doAmAyYp4Db29iBT4xdwNBed
+Y2gea+zDTYa4EzAvXUYNR0PVG6pZDrlcjQZIrXSHX8f8MVRBE+LHIQ6e4B4N4cB7
+Q4WQxYpYxmUKeFfyxiMPAdkgS94P+5KFdSpcc41teyWRyu5FrgZLAMzTsVlQ2jqI
+OylDRl6XK1TOU2+NSueW+r9xDkKLfP0ooNBIytrEgUy7onOTJsjrDNYmiLbAJM+7
+vVvrdX3pCI6GMyx5dwlppYn8s3CQh3aP0yK7Qs69cwsgJirQmz1wHiRszYd2qReW
+t88NkvuOGKmYSdGe/mBEciG5Ge3C9THxOUiIkCR1VBatzvT4aRRkOfujuLpwQMcn
+HL/EVlP6Y2XQ8xwOFvVrhlhNGNTkDY6lnVuR3HYkUD/GKvvZt5y11ubQ2egZixVx
+SK236thZiNSQvxaz2emsWWFUyBy6ysHK4bkgTI86k4mloMy/0/Z1pHWWbVY=
+-----END CERTIFICATE-----
+
+TrustCor ECA-1
+-----BEGIN CERTIFICATE-----
+MIIEIDCCAwigAwIBAgIJAISCLF8cYtBAMA0GCSqGSIb3DQEBCwUAMIGcMQswCQYD
+VQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEgQ2l0eTEk
+MCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYDVQQLDB5U
+cnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxFzAVBgNVBAMMDlRydXN0Q29y
+IEVDQS0xMB4XDTE2MDIwNDEyMzIzM1oXDTI5MTIzMTE3MjgwN1owgZwxCzAJBgNV
+BAYTAlBBMQ8wDQYDVQQIDAZQYW5hbWExFDASBgNVBAcMC1BhbmFtYSBDaXR5MSQw
+IgYDVQQKDBtUcnVzdENvciBTeXN0ZW1zIFMuIGRlIFIuTC4xJzAlBgNVBAsMHlRy
+dXN0Q29yIENlcnRpZmljYXRlIEF1dGhvcml0eTEXMBUGA1UEAwwOVHJ1c3RDb3Ig
+RUNBLTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDPj+ARtZ+odnbb
+3w9U73NjKYKtR8aja+3+XzP4Q1HpGjORMRegdMTUpwHmspI+ap3tDvl0mEDTPwOA
+BoJA6LHip1GnHYMma6ve+heRK9jGrB6xnhkB1Zem6g23xFUfJ3zSCNV2HykVh0A5
+3ThFEXXQmqc04L/NyFIduUd+Dbi7xgz2c1cWWn5DkR9VOsZtRASqnKmcp0yJF4Ou
+owReUoCLHhIlERnXDH19MURB6tuvsBzvgdAsxZohmz3tQjtQJvLsznFhBmIhVE5/
+wZ0+fyCMgMsq2JdiyIMzkX2woloPV+g7zPIlstR8L+xNxqE6FXrntl019fZISjZF
+ZtS6mFjBAgMBAAGjYzBhMB0GA1UdDgQWBBREnkj1zG1I1KBLf/5ZJC+Dl5mahjAf
+BgNVHSMEGDAWgBREnkj1zG1I1KBLf/5ZJC+Dl5mahjAPBgNVHRMBAf8EBTADAQH/
+MA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG9w0BAQsFAAOCAQEABT41XBVwm8nHc2Fv
+civUwo/yQ10CzsSUuZQRg2dd4mdsdXa/uwyqNsatR5Nj3B5+1t4u/ukZMjgDfxT2
+AHMsWbEhBuH7rBiVDKP/mZb3Kyeb1STMHd3BOuCYRLDE5D53sXOpZCz2HAF8P11F
+hcCF5yWPldwX8zyfGm6wyuMdKulMY/okYWLW2n62HGz1Ah3UKt1VkOsqEUc8Ll50
+soIipX1TH0XsJ5F95yIW6MBoNtjG8U+ARDL54dHRHareqKucBK+tIA5kmE2la8BI
+WJZpTdwHjFGTot+fDz2LYLSCjaoITmJF4PkL0uDgPFveXHEnJcLmA4GLEFPjx1Wi
+tJ/X5g==
+-----END CERTIFICATE-----
+
+TrustCor RootCert CA-1
+-----BEGIN CERTIFICATE-----
+MIIEMDCCAxigAwIBAgIJANqb7HHzA7AZMA0GCSqGSIb3DQEBCwUAMIGkMQswCQYD
+VQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEgQ2l0eTEk
+MCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYDVQQLDB5U
+cnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxHzAdBgNVBAMMFlRydXN0Q29y
+IFJvb3RDZXJ0IENBLTEwHhcNMTYwMjA0MTIzMjE2WhcNMjkxMjMxMTcyMzE2WjCB
+pDELMAkGA1UEBhMCUEExDzANBgNVBAgMBlBhbmFtYTEUMBIGA1UEBwwLUGFuYW1h
+IENpdHkxJDAiBgNVBAoMG1RydXN0Q29yIFN5c3RlbXMgUy4gZGUgUi5MLjEnMCUG
+A1UECwweVHJ1c3RDb3IgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MR8wHQYDVQQDDBZU
+cnVzdENvciBSb290Q2VydCBDQS0xMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
+CgKCAQEAv463leLCJhJrMxnHQFgKq1mqjQCj/IDHUHuO1CAmujIS2CNUSSUQIpid
+RtLByZ5OGy4sDjjzGiVoHKZaBeYei0i/mJZ0PmnK6bV4pQa81QBeCQryJ3pS/C3V
+seq0iWEk8xoT26nPUu0MJLq5nux+AHT6k61sKZKuUbS701e/s/OojZz0JEsq1pme
+9J7+wH5COucLlVPat2gOkEz7cD+PSiyU8ybdY2mplNgQTsVHCJCZGxdNuWxu72CV
+EY4hgLW9oHPY0LJ3xEXqWib7ZnZ2+AYfYW0PVcWDtxBWcgYHpfOxGgMFZA6dWorW
+hnAbJN7+KIor0Gqw/Hqi3LJ5DotlDwIDAQABo2MwYTAdBgNVHQ4EFgQU7mtJPHo/
+DeOxCbeKyKsZn3MzUOcwHwYDVR0jBBgwFoAU7mtJPHo/DeOxCbeKyKsZn3MzUOcw
+DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQAD
+ggEBACUY1JGPE+6PHh0RU9otRCkZoB5rMZ5NDp6tPVxBb5UrJKF5mDo4Nvu7Zp5I
+/5CQ7z3UuJu0h3U/IJvOcs+hVcFNZKIZBqEHMwwLKeXx6quj7LUKdJDHfXLy11yf
+ke+Ri7fc7Waiz45mO7yfOgLgJ90WmMCV1Aqk5IGadZQ1nJBfiDcGrVmVCrDRZ9MZ
+yonnMlo2HD6CqFqTvsbQZJG2z9m2GM/bftJlo6bEjhcxwft+dtvTheNYsnd6djts
+L1Ac59v2Z3kf9YKVmgenFK+P3CghZwnS1k1aHBkcjndcw5QkPTJrS37UeJSDvjdN
+zl/HHk484IkzlQsPpTLWPFp5LBk=
+-----END CERTIFICATE-----
+
+TrustCor RootCert CA-2
+-----BEGIN CERTIFICATE-----
+MIIGLzCCBBegAwIBAgIIJaHfyjPLWQIwDQYJKoZIhvcNAQELBQAwgaQxCzAJBgNV
+BAYTAlBBMQ8wDQYDVQQIDAZQYW5hbWExFDASBgNVBAcMC1BhbmFtYSBDaXR5MSQw
+IgYDVQQKDBtUcnVzdENvciBTeXN0ZW1zIFMuIGRlIFIuTC4xJzAlBgNVBAsMHlRy
+dXN0Q29yIENlcnRpZmljYXRlIEF1dGhvcml0eTEfMB0GA1UEAwwWVHJ1c3RDb3Ig
+Um9vdENlcnQgQ0EtMjAeFw0xNjAyMDQxMjMyMjNaFw0zNDEyMzExNzI2MzlaMIGk
+MQswCQYDVQQGEwJQQTEPMA0GA1UECAwGUGFuYW1hMRQwEgYDVQQHDAtQYW5hbWEg
+Q2l0eTEkMCIGA1UECgwbVHJ1c3RDb3IgU3lzdGVtcyBTLiBkZSBSLkwuMScwJQYD
+VQQLDB5UcnVzdENvciBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxHzAdBgNVBAMMFlRy
+dXN0Q29yIFJvb3RDZXJ0IENBLTIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
+AoICAQCnIG7CKqJiJJWQdsg4foDSq8GbZQWU9MEKENUCrO2fk8eHyLAnK0IMPQo+
+QVqedd2NyuCb7GgypGmSaIwLgQ5WoD4a3SwlFIIvl9NkRvRUqdw6VC0xK5mC8tkq
+1+9xALgxpL56JAfDQiDyitSSBBtlVkxs1Pu2YVpHI7TYabS3OtB0PAx1oYxOdqHp
+2yqlO/rOsP9+aij9JxzIsekp8VduZLTQwRVtDr4uDkbIXvRR/u8OYzo7cbrPb1nK
+DOObXUm4TOJXsZiKQlecdu/vvdFoqNL0Cbt3Nb4lggjEFixEIFapRBF37120Hape
+az6LMvYHL1cEksr1/p3C6eizjkxLAjHZ5DxIgif3GIJ2SDpxsROhOdUuxTTCHWKF
+3wP+TfSvPd9cW436cOGlfifHhi5qjxLGhF5DUVCcGZt45vz27Ud+ez1m7xMTiF88
+oWP7+ayHNZ/zgp6kPwqcMWmLmaSISo5uZk3vFsQPeSghYA2FFn3XVDjxklb9tTNM
+g9zXEJ9L/cb4Qr26fHMC4P99zVvh1Kxhe1fVSntb1IVYJ12/+CtgrKAmrhQhJ8Z3
+mjOAPF5GP/fDsaOGM8boXg25NSyqRsGFAnWAoOsk+xWq5Gd/bnc/9ASKL3x74xdh
+8N0JqSDIvgmk0H5Ew7IwSjiqqewYmgeCK9u4nBit2uBGF6zPXQIDAQABo2MwYTAd
+BgNVHQ4EFgQU2f4hQG6UnrybPZx9mCAZ5YwwYrIwHwYDVR0jBBgwFoAU2f4hQG6U
+nrybPZx9mCAZ5YwwYrIwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYw
+DQYJKoZIhvcNAQELBQADggIBAJ5Fngw7tu/hOsh80QA9z+LqBrWyOrsGS2h60COX
+dKcs8AjYeVrXWoSK2BKaG9l9XE1wxaX5q+WjiYndAfrs3fnpkpfbsEZC89NiqpX+
+MWcUaViQCqoL7jcjx1BRtPV+nuN79+TMQjItSQzL/0kMmx40/W5ulop5A7Zv2wnL
+/V9lFDfhOPXzYRZY5LVtDQsEGz9QLX+zx3oaFoBg+Iof6Rsqxvm6ARppv9JYx1RX
+CI/hOWB3S6xZhBqI8d3LT3jX5+EzLfzuQfogsL7L9ziUwOHQhQ+77Sxzq+3+knYa
+ZH9bDTMJBzN7Bj8RpFxwPIXAz+OQqIN3+tvmxYxoZxBnpVIt8MSZj3+/0WvitUfW
+2dCFmU2Umw9Lje4AWkcdEQOsQRivh7dvDDqPys/cA8GiCcjl/YBeyGBCARsaU1q7
+N6a3vLqE6R5sGtRk2tRD/pOLS/IseRYQ1JMLiI+h2IYURpFHmygk71dSTlxCnKr3
+Sewn6EAes6aJInKc9Q0ztFijMDvd1GpUk74aTfOTlPf8hAs/hCBcNANExdqtvArB
+As8e5ZTZ845b2EzwnexhF7sUMlQMAimTHpKG9n/v55IFDlndmQguLvqcAFLTxWYp
+5KeXRKQOKIETNcX2b2TmQcTVL8w0RSXPQQCWPUouwpaYT05KnJe32x+SMsj/D1Fu
+1uwJ
+-----END CERTIFICATE-----
+
+Trustwave Global Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIF2jCCA8KgAwIBAgIMBfcOhtpJ80Y1LrqyMA0GCSqGSIb3DQEBCwUAMIGIMQsw
+CQYDVQQGEwJVUzERMA8GA1UECAwISWxsaW5vaXMxEDAOBgNVBAcMB0NoaWNhZ28x
+ITAfBgNVBAoMGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjExMC8GA1UEAwwoVHJ1
+c3R3YXZlIEdsb2JhbCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0xNzA4MjMx
+OTM0MTJaFw00MjA4MjMxOTM0MTJaMIGIMQswCQYDVQQGEwJVUzERMA8GA1UECAwI
+SWxsaW5vaXMxEDAOBgNVBAcMB0NoaWNhZ28xITAfBgNVBAoMGFRydXN0d2F2ZSBI
+b2xkaW5ncywgSW5jLjExMC8GA1UEAwwoVHJ1c3R3YXZlIEdsb2JhbCBDZXJ0aWZp
+Y2F0aW9uIEF1dGhvcml0eTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB
+ALldUShLPDeS0YLOvR29zd24q88KPuFd5dyqCblXAj7mY2Hf8g+CY66j96xz0Xzn
+swuvCAAJWX/NKSqIk4cXGIDtiLK0thAfLdZfVaITXdHG6wZWiYj+rDKd/VzDBcdu
+7oaJuogDnXIhhpCujwOl3J+IKMujkkkP7NAP4m1ET4BqstTnoApTAbqOl5F2brz8
+1Ws25kCI1nsvXwXoLG0R8+eyvpJETNKXpP7ScoFDB5zpET71ixpZfR9oWN0EACyW
+80OzfpgZdNmcc9kYvkHHNHnZ9GLCQ7mzJ7Aiy/k9UscwR7PJPrhq4ufogXBeQotP
+JqX+OsIgbrv4Fo7NDKm0G2x2EOFYeUY+VM6AqFcJNykbmROPDMjWLBz7BegIlT1l
+RtzuzWniTY+HKE40Cz7PFNm73bZQmq131BnW2hqIyE4bJ3XYsgjxroMwuREOzYfw
+hI0Vcnyh78zyiGG69Gm7DIwLdVcEuE4qFC49DxweMqZiNu5m4iK4BUBjECLzMx10
+coos9TkpoNPnG4CELcU9402x/RpvumUHO1jsQkUm+9jaJXLE9gCxInm943xZYkqc
+BW89zubWR2OZxiRvchLIrH+QtAuRcOi35hYQcRfO3gZPSEF9NUqjifLJS3tBEW1n
+twiYTOURGa5CgNz7kAXU+FDKvuStx8KU1xad5hePrzb7AgMBAAGjQjBAMA8GA1Ud
+EwEB/wQFMAMBAf8wHQYDVR0OBBYEFJngGWcNYtt2s9o9uFvo/ULSMQ6HMA4GA1Ud
+DwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAmHNw4rDT7TnsTGDZqRKGFx6W
+0OhUKDtkLSGm+J1WE2pIPU/HPinbbViDVD2HfSMF1OQc3Og4ZYbFdada2zUFvXfe
+uyk3QAUHw5RSn8pk3fEbK9xGChACMf1KaA0HZJDmHvUqoai7PF35owgLEQzxPy0Q
+lG/+4jSHg9bP5Rs1bdID4bANqKCqRieCNqcVtgimQlRXtpla4gt5kNdXElE1GYhB
+aCXUNxeEFfsBctyV3lImIJgm4nb1J2/6ADtKYdkNy1GTKv0WBpanI5ojSP5RvbbE
+sLFUzt5sQa0WZ37b/TjNuThOssFgy50X31ieemKyJo90lZvkWx3SD92YHJtZuSPT
+MaCm/zjdzyBP6VhWOmfD0faZmZ26NraAL4hHT4a/RDqA5Dccprrql5gR0IRiR2Qe
+qu5AvzSxnI9O4fKSTx+O856X3vOmeWqJcU9LJxdI/uz0UA9PSX3MReO9ekDFQdxh
+VicGaeVyQYHTtgGJoC86cnn+OjC/QezHYj6RS8fZMXZC+fc8Y+wmjHMMfRod6qh8
+h6jCJ3zhM0EPz8/8AKAigJ5Kp28AsEFFtyLKaEjFQqKu3R3y4G5OBVixwJAWKqQ9
+EEC+j2Jjg6mcgn0tAumDMHzLJ8n9HmYAsC7TIS+OMxZsmO0QqAfWzJPP29FpHOTK
+yeC2nOnOcXHebD8WpHk=
+-----END CERTIFICATE-----
+
+Trustwave Global ECC P256 Certification Authority
+-----BEGIN CERTIFICATE-----
+MIICYDCCAgegAwIBAgIMDWpfCD8oXD5Rld9dMAoGCCqGSM49BAMCMIGRMQswCQYD
+VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAf
+BgNVBAoTGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3
+YXZlIEdsb2JhbCBFQ0MgUDI1NiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0x
+NzA4MjMxOTM1MTBaFw00MjA4MjMxOTM1MTBaMIGRMQswCQYDVQQGEwJVUzERMA8G
+A1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAfBgNVBAoTGFRydXN0
+d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3YXZlIEdsb2JhbCBF
+Q0MgUDI1NiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTBZMBMGByqGSM49AgEGCCqG
+SM49AwEHA0IABH77bOYj43MyCMpg5lOcunSNGLB4kFKA3TjASh3RqMyTpJcGOMoN
+FWLGjgEqZZ2q3zSRLoHB5DOSMcT9CTqmP62jQzBBMA8GA1UdEwEB/wQFMAMBAf8w
+DwYDVR0PAQH/BAUDAwcGADAdBgNVHQ4EFgQUo0EGrJBt0UrrdaVKEJmzsaGLSvcw
+CgYIKoZIzj0EAwIDRwAwRAIgB+ZU2g6gWrKuEZ+Hxbb/ad4lvvigtwjzRM4q3wgh
+DDcCIC0mA6AFvWvR9lz4ZcyGbbOcNEhjhAnFjXca4syc4XR7
+-----END CERTIFICATE-----
+
+Trustwave Global ECC P384 Certification Authority
+-----BEGIN CERTIFICATE-----
+MIICnTCCAiSgAwIBAgIMCL2Fl2yZJ6SAaEc7MAoGCCqGSM49BAMDMIGRMQswCQYD
+VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAf
+BgNVBAoTGFRydXN0d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3
+YXZlIEdsb2JhbCBFQ0MgUDM4NCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0x
+NzA4MjMxOTM2NDNaFw00MjA4MjMxOTM2NDNaMIGRMQswCQYDVQQGEwJVUzERMA8G
+A1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xITAfBgNVBAoTGFRydXN0
+d2F2ZSBIb2xkaW5ncywgSW5jLjE6MDgGA1UEAxMxVHJ1c3R3YXZlIEdsb2JhbCBF
+Q0MgUDM4NCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTB2MBAGByqGSM49AgEGBSuB
+BAAiA2IABGvaDXU1CDFHBa5FmVXxERMuSvgQMSOjfoPTfygIOiYaOs+Xgh+AtycJ
+j9GOMMQKmw6sWASr9zZ9lCOkmwqKi6vr/TklZvFe/oyujUF5nQlgziip04pt89ZF
+1PKYhDhloKNDMEEwDwYDVR0TAQH/BAUwAwEB/zAPBgNVHQ8BAf8EBQMDBwYAMB0G
+A1UdDgQWBBRVqYSJ0sEyvRjLbKYHTsjnnb6CkDAKBggqhkjOPQQDAwNnADBkAjA3
+AZKXRRJ+oPM+rRk6ct30UJMDEr5E0k9BpIycnR+j9sKS50gU/k6bpZFXrsY3crsC
+MGclCrEMXu6pY5Jv5ZAL/mYiykf9ijH3g/56vxC+GCsej/YpHpRZ744hN8tRmKVu
+Sw==
+-----END CERTIFICATE-----
+
+UCA Extended Validation Root
+-----BEGIN CERTIFICATE-----
+MIIFWjCCA0KgAwIBAgIQT9Irj/VkyDOeTzRYZiNwYDANBgkqhkiG9w0BAQsFADBH
+MQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxJTAjBgNVBAMMHFVDQSBF
+eHRlbmRlZCBWYWxpZGF0aW9uIFJvb3QwHhcNMTUwMzEzMDAwMDAwWhcNMzgxMjMx
+MDAwMDAwWjBHMQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxJTAjBgNV
+BAMMHFVDQSBFeHRlbmRlZCBWYWxpZGF0aW9uIFJvb3QwggIiMA0GCSqGSIb3DQEB
+AQUAA4ICDwAwggIKAoICAQCpCQcoEwKwmeBkqh5DFnpzsZGgdT6o+uM4AHrsiWog
+D4vFsJszA1qGxliG1cGFu0/GnEBNyr7uaZa4rYEwmnySBesFK5pI0Lh2PpbIILvS
+sPGP2KxFRv+qZ2C0d35qHzwaUnoEPQc8hQ2E0B92CvdqFN9y4zR8V05WAT558aop
+O2z6+I9tTcg1367r3CTueUWnhbYFiN6IXSV8l2RnCdm/WhUFhvMJHuxYMjMR83dk
+sHYf5BA1FxvyDrFspCqjc/wJHx4yGVMR59mzLC52LqGj3n5qiAno8geK+LLNEOfi
+c0CTuwjRP+H8C5SzJe98ptfRr5//lpr1kXuYC3fUfugH0mK1lTnj8/FtDw5lhIpj
+VMWAtuCeS31HJqcBCF3RiJ7XwzJE+oJKCmhUfzhTA8ykADNkUVkLo4KRel7sFsLz
+KuZi2irbWWIQJUoqgQtHB0MGcIfS+pMRKXpITeuUx3BNr2fVUbGAIAEBtHoIppB/
+TuDvB0GHr2qlXov7z1CymlSvw4m6WC31MJixNnI5fkkE/SmnTHnkBVfblLkWU41G
+sx2VYVdWf6/wFlthWG82UBEL2KwrlRYaDh8IzTY0ZRBiZtWAXxQgXy0MoHgKaNYs
+1+lvK9JKBZP8nm9rZ/+I8U6laUpSNwXqxhaN0sSZ0YIrO7o1dfdRUVjzyAfd5LQD
+fwIDAQABo0IwQDAdBgNVHQ4EFgQU2XQ65DA9DfcS3H5aBZ8eNJr34RQwDwYDVR0T
+AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBADaN
+l8xCFWQpN5smLNb7rhVpLGsaGvdftvkHTFnq88nIua7Mui563MD1sC3AO6+fcAUR
+ap8lTwEpcOPlDOHqWnzcSbvBHiqB9RZLcpHIojG5qtr8nR/zXUACE/xOHAbKsxSQ
+VBcZEhrxH9cMaVr2cXj0lH2RC47skFSOvG+hTKv8dGT9cZr4QQehzZHkPJrgmzI5
+c6sq1WnIeJEmMX3ixzDx/BR4dxIOE/TdFpS/S2d7cFOFyrC78zhNLJA5wA3CXWvp
+4uXViI3WLL+rG761KIcSF3Ru/H38j9CHJrAb+7lsq+KePRXBOy5nAliRn+/4Qh8s
+t2j1da3Ptfb/EX3C8CSlrdP6oDyp+l3cpaDvRKS+1ujl5BOWF3sGPjLtx7dCvHaj
+2GU4Kzg1USEODm8uNBNA4StnDG1KQTAYI1oyVZnJF+A83vbsea0rWBmirSwiGpWO
+vpaQXUJXxPkUAzUrHC1RVwinOt4/5Mi0A3PCwSaAuwtCH60NryZy2sy+s6ODWA2C
+xR9GUeOcGMyNm43sSet1UNWMKFnKdDTajAshqx7qG+XH/RU+wBeq+yNuJkbL+vmx
+cmtpzyKEC2IPrNkZAJSidjzULZrtBJ4tBmIQN1IchXIbJ+XMxjHsN+xjWZsLHXbM
+fjKaiJUINlK73nZfdklJrX+9ZSCyycErdhh2n1ax
+-----END CERTIFICATE-----
+
+UCA Global G2 Root
+-----BEGIN CERTIFICATE-----
+MIIFRjCCAy6gAwIBAgIQXd+x2lqj7V2+WmUgZQOQ7zANBgkqhkiG9w0BAQsFADA9
+MQswCQYDVQQGEwJDTjERMA8GA1UECgwIVW5pVHJ1c3QxGzAZBgNVBAMMElVDQSBH
+bG9iYWwgRzIgUm9vdDAeFw0xNjAzMTEwMDAwMDBaFw00MDEyMzEwMDAwMDBaMD0x
+CzAJBgNVBAYTAkNOMREwDwYDVQQKDAhVbmlUcnVzdDEbMBkGA1UEAwwSVUNBIEds
+b2JhbCBHMiBSb290MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxeYr
+b3zvJgUno4Ek2m/LAfmZmqkywiKHYUGRO8vDaBsGxUypK8FnFyIdK+35KYmToni9
+kmugow2ifsqTs6bRjDXVdfkX9s9FxeV67HeToI8jrg4aA3++1NDtLnurRiNb/yzm
+VHqUwCoV8MmNsHo7JOHXaOIxPAYzRrZUEaalLyJUKlgNAQLx+hVRZ2zA+te2G3/R
+VogvGjqNO7uCEeBHANBSh6v7hn4PJGtAnTRnvI3HLYZveT6OqTwXS3+wmeOwcWDc
+C/Vkw85DvG1xudLeJ1uK6NjGruFZfc8oLTW4lVYa8bJYS7cSN8h8s+1LgOGN+jIj
+tm+3SJUIsUROhYw6AlQgL9+/V087OpAh18EmNVQg7Mc/R+zvWr9LesGtOxdQXGLY
+D0tK3Cv6brxzks3sx1DoQZbXqX5t2Okdj4q1uViSukqSKwxW/YDrCPBeKW4bHAyv
+j5OJrdu9o54hyokZ7N+1wxrrFv54NkzWbtA+FxyQF2smuvt6L78RHBgOLXMDj6Dl
+NaBa4kx1HXHhOThTeEDMg5PXCp6dW4+K5OXgSORIskfNTip1KnvyIvbJvgmRlld6
+iIis7nCs+dwp4wwcOxJORNanTrAmyPPZGpeRaOrvjUYG0lZFWJo8DA+DuAUlwznP
+O6Q0ibd5Ei9Hxeepl2n8pndntd978XplFeRhVmUCAwEAAaNCMEAwDgYDVR0PAQH/
+BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFIHEjMz15DD/pQwIX4wV
+ZyF0Ad/fMA0GCSqGSIb3DQEBCwUAA4ICAQATZSL1jiutROTL/7lo5sOASD0Ee/oj
+L3rtNtqyzm325p7lX1iPyzcyochltq44PTUbPrw7tgTQvPlJ9Zv3hcU2tsu8+Mg5
+1eRfB70VVJd0ysrtT7q6ZHafgbiERUlMjW+i67HM0cOU2kTC5uLqGOiiHycFutfl
+1qnN3e92mI0ADs0b+gO3joBYDic/UvuUospeZcnWhNq5NXHzJsBPd+aBJ9J3O5oU
+b3n09tDh05S60FdRvScFDcH9yBIw7m+NESsIndTUv4BFFJqIRNow6rSn4+7vW4LV
+PtateJLbXDzz2K36uGt/xDYotgIVilQsnLAXc47QN6MUPJiVAAwpBVueSUmxX8fj
+y88nZY41F7dXyDDZQVu5FLbowg+UMaeUmMxq67XhJ/UQqAHojhJi6IjMtX9Gl8Cb
+EGY4GjZGXyJoPd/JxhMnq1MGrKI8hgZlb7F+sSlEmqO6SWkoaY/X5V+tBIZkbxqg
+DMUIYs6Ao9Dz7GjevjPHF1t/gMRMTLGmhIrDO7gJzRSBuhjjVFc2/tsvfEehOjPI
++Vg7RE+xygKJBJYoaMVLuCaJu9YzL1DV/pqJuhgyklTGW+Cd+V7lDSKb9triyCGy
+YiGqhkCyLmTTX8jjfhFnRR8F/uOi77Oos/N9j/gMHyIfLXC0uAE0djAA5SN4p1bX
+UB+K+wb1whnw0A==
+-----END CERTIFICATE-----
+
+USERTrust ECC Certification Authority
+-----BEGIN CERTIFICATE-----
+MIICjzCCAhWgAwIBAgIQXIuZxVqUxdJxVt7NiYDMJjAKBggqhkjOPQQDAzCBiDEL
+MAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNl
+eSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMT
+JVVTRVJUcnVzdCBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAx
+MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgT
+Ck5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVUaGUg
+VVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBFQ0MgQ2VydGlm
+aWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQarFRaqflo
+I+d61SRvU8Za2EurxtW20eZzca7dnNYMYf3boIkDuAUU7FfO7l0/4iGzzvfUinng
+o4N+LZfQYcTxmdwlkWOrfzCjtHDix6EznPO/LlxTsV+zfTJ/ijTjeXmjQjBAMB0G
+A1UdDgQWBBQ64QmG1M8ZwpZ2dEl23OA1xmNjmjAOBgNVHQ8BAf8EBAMCAQYwDwYD
+VR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAwNoADBlAjA2Z6EWCNzklwBBHU6+4WMB
+zzuqQhFkoJ2UOQIReVx7Hfpkue4WQrO/isIJxOzksU0CMQDpKmFHjFJKS04YcPbW
+RNZu9YO6bVi9JNlWSOrvxKJGgYhqOkbRqZtNyWHa0V1Xahg=
+-----END CERTIFICATE-----
+
+USERTrust RSA Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCB
+iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0pl
+cnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNV
+BAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAw
+MjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBiDELMAkGA1UEBhMCVVMxEzARBgNV
+BAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVU
+aGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2Vy
+dGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
+AoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B
+3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkY
+tJHUYmTbf6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/
+Fp0YvVGONaanZshyZ9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2
+VN3I5xI6Ta5MirdcmrS3ID3KfyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT
+79uq/nROacdrjGCT3sTHDN/hMq7MkztReJVni+49Vv4M0GkPGw/zJSZrM233bkf6
+c0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+tdOmw1XNtB1xLaqUkL39iAigmT
+Yo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugTncxbgtNMs+1b/97l
+c6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE9JnnV4ee
+UB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE
+Hg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAd
+BgNVHQ4EFgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8G
+A1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPF
+Up/L+M+ZBn8b2kMVn54CVVeWFPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KO
+VWKR82kV2LyI48SqC/3vqOlLVSoGIG1VeCkZ7l8wXEskEVX/JJpuXior7gtNn3/3
+ATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jRRa8YFWSQEg9zKC7F4iRO/Fjs
+8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9spnFixdjQg3IM8WcR
+iQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwXtuhxkYze
+Sf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ
+XHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/
+qS3fuQL39ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRB
+VXyNWQKV3WKdwrnuWih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aB
+L6KCq9NjRHDEjf8tM7qtj3u1cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfG
+jjxDah2nGN59PRbxYvnKkKj9
+-----END CERTIFICATE-----
+
+XRamp Global CA Root
+-----BEGIN CERTIFICATE-----
+MIIEMDCCAxigAwIBAgIQUJRs7Bjq1ZxN1ZfvdY+grTANBgkqhkiG9w0BAQUFADCB
+gjELMAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEk
+MCIGA1UEChMbWFJhbXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRY
+UmFtcCBHbG9iYWwgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQxMTAxMTcx
+NDA0WhcNMzUwMTAxMDUzNzE5WjCBgjELMAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3
+dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMbWFJhbXAgU2VjdXJpdHkgU2Vy
+dmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2VydGlmaWNhdGlvbiBB
+dXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCYJB69FbS6
+38eMpSe2OAtp87ZOqCwuIR1cRN8hXX4jdP5efrRKt6atH67gBhbim1vZZ3RrXYCP
+KZ2GG9mcDZhtdhAoWORlsH9KmHmf4MMxfoArtYzAQDsRhtDLooY2YKTVMIJt2W7Q
+DxIEM5dfT2Fa8OT5kavnHTu86M/0ay00fOJIYRyO82FEzG+gSqmUsE3a56k0enI4
+qEHMPJQRfevIpoy3hsvKMzvZPTeL+3o+hiznc9cKV6xkmxnr9A8ECIqsAxcZZPRa
+JSKNNCyy9mgdEm3Tih4U2sSPpuIjhdV6Db1q4Ons7Be7QhtnqiXtRYMh/MHJfNVi
+PvryxS3T/dRlAgMBAAGjgZ8wgZwwEwYJKwYBBAGCNxQCBAYeBABDAEEwCwYDVR0P
+BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMZPoj0GY4QJnM5i5ASs
+jVy16bYbMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwueHJhbXBzZWN1cml0
+eS5jb20vWEdDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQEwDQYJKoZIhvcNAQEFBQAD
+ggEBAJEVOQMBG2f7Shz5CmBbodpNl2L5JFMn14JkTpAuw0kbK5rc/Kh4ZzXxHfAR
+vbdI4xD2Dd8/0sm2qlWkSLoC295ZLhVbO50WfUfXN+pfTXYSNrsf16GBBEYgoyxt
+qZ4Bfj8pzgCT3/3JknOJiWSe5yvkHJEs0rnOfc5vMZnT5r7SHpDwCRR5XCOrTdLa
+IR9NmXmd4c8nnxCbHIgNsIpkQTG4DmyQJKSbXHGPurt+HBvbaoAPIbzp26a3QPSy
+i6mx5O+aGtA9aZnuqCij4Tyz8LIRnM98QObd50N9otg6tamN8jSZxNQQ4Qb9CYQQ
+O+7ETPTsJ3xCwnR8gooJybQDJbw=
+-----END CERTIFICATE-----
+
+certSIGN ROOT CA
+-----BEGIN CERTIFICATE-----
+MIIDODCCAiCgAwIBAgIGIAYFFnACMA0GCSqGSIb3DQEBBQUAMDsxCzAJBgNVBAYT
+AlJPMREwDwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBD
+QTAeFw0wNjA3MDQxNzIwMDRaFw0zMTA3MDQxNzIwMDRaMDsxCzAJBgNVBAYTAlJP
+MREwDwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTCC
+ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALczuX7IJUqOtdu0KBuqV5Do
+0SLTZLrTk+jUrIZhQGpgV2hUhE28alQCBf/fm5oqrl0Hj0rDKH/v+yv6efHHrfAQ
+UySQi2bJqIirr1qjAOm+ukbuW3N7LBeCgV5iLKECZbO9xSsAfsT8AzNXDe3i+s5d
+RdY4zTW2ssHQnIFKquSyAVwdj1+ZxLGt24gh65AIgoDzMKND5pCCrlUoSe1b16kQ
+OA7+j0xbm0bqQfWwCHTD0IgztnzXdN/chNFDDnU5oSVAKOp4yw4sLjmdjItuFhwv
+JoIQ4uNllAoEwF73XVv4EOLQunpL+943AAAaWyjj0pxzPjKHmKHJUS/X3qwzs08C
+AwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAcYwHQYDVR0O
+BBYEFOCMm9slSbPxfIbWskKHC9BroNnkMA0GCSqGSIb3DQEBBQUAA4IBAQA+0hyJ
+LjX8+HXd5n9liPRyTMks1zJO890ZeUe9jjtbkw9QSSQTaxQGcu8J06Gh40CEyecY
+MnQ8SG4Pn0vU9x7Tk4ZkVJdjclDVVc/6IJMCopvDI5NOFlV2oHB5bc0hH88vLbwZ
+44gx+FkagQnIl6Z0x2DEW8xXjrJ1/RsCCdtZb3KTafcxQdaIOL+Hsr0Wefmq5L6I
+Jd1hJyMctTEHBDa0GpC9oHRxUIltvBTjD4au8as+x6AJzKNI0eDbZOeStc+vckNw
+i/nDhDwTqn6Sm1dTk/pwwpEOMfmbZ13pljheX7NzTogVZ96edhBiIL5VaZVDADlN
+9u6wWk5JRFRYX0KD
+-----END CERTIFICATE-----
+
+certSIGN Root CA G2
+-----BEGIN CERTIFICATE-----
+MIIFRzCCAy+gAwIBAgIJEQA0tk7GNi02MA0GCSqGSIb3DQEBCwUAMEExCzAJBgNV
+BAYTAlJPMRQwEgYDVQQKEwtDRVJUU0lHTiBTQTEcMBoGA1UECxMTY2VydFNJR04g
+Uk9PVCBDQSBHMjAeFw0xNzAyMDYwOTI3MzVaFw00MjAyMDYwOTI3MzVaMEExCzAJ
+BgNVBAYTAlJPMRQwEgYDVQQKEwtDRVJUU0lHTiBTQTEcMBoGA1UECxMTY2VydFNJ
+R04gUk9PVCBDQSBHMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMDF
+dRmRfUR0dIf+DjuW3NgBFszuY5HnC2/OOwppGnzC46+CjobXXo9X69MhWf05N0Iw
+vlDqtg+piNguLWkh59E3GE59kdUWX2tbAMI5Qw02hVK5U2UPHULlj88F0+7cDBrZ
+uIt4ImfkabBoxTzkbFpG583H+u/E7Eu9aqSs/cwoUe+StCmrqzWaTOTECMYmzPhp
+n+Sc8CnTXPnGFiWeI8MgwT0PPzhAsP6CRDiqWhqKa2NYOLQV07YRaXseVO6MGiKs
+cpc/I1mbySKEwQdPzH/iV8oScLumZfNpdWO9lfsbl83kqK/20U6o2YpxJM02PbyW
+xPFsqa7lzw1uKA2wDrXKUXt4FMMgL3/7FFXhEZn91QqhngLjYl/rNUssuHLoPj1P
+rCy7Lobio3aP5ZMqz6WryFyNSwb/EkaseMsUBzXgqd+L6a8VTxaJW732jcZZroiF
+DsGJ6x9nxUWO/203Nit4ZoORUSs9/1F3dmKh7Gc+PoGD4FapUB8fepmrY7+EF3fx
+DTvf95xhszWYijqy7DwaNz9+j5LP2RIUZNoQAhVB/0/E6xyjyfqZ90bp4RjZsbgy
+LcsUDFDYg2WD7rlcz8sFWkz6GZdr1l0T08JcVLwyc6B49fFtHsufpaafItzRUZ6C
+eWRgKRM+o/1Pcmqr4tTluCRVLERLiohEnMqE0yo7AgMBAAGjQjBAMA8GA1UdEwEB
+/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBSCIS1mxteg4BXrzkwJ
+d8RgnlRuAzANBgkqhkiG9w0BAQsFAAOCAgEAYN4auOfyYILVAzOBywaK8SJJ6ejq
+kX/GM15oGQOGO0MBzwdw5AgeZYWR5hEit/UCI46uuR59H35s5r0l1ZUa8gWmr4UC
+b6741jH/JclKyMeKqdmfS0mbEVeZkkMR3rYzpMzXjWR91M08KCy0mpbqTfXERMQl
+qiCA2ClV9+BB/AYm/7k29UMUA2Z44RGx2iBfRgB4ACGlHgAoYXhvqAEBj500mv/0
+OJD7uNGzcgbJceaBxXntC6Z58hMLnPddDnskk7RI24Zf3lCGeOdA5jGokHZwYa+c
+NywRtYK3qq4kNFtyDGkNzVmf9nGvnAvRCjj5BiKDUyUM/FHE5r7iOZULJK2v0ZXk
+ltd0ZGtxTgI8qoXzIKNDOXZbbFD+mpwUHmUUihW9o4JFWklWatKcsWMy5WHgUyIO
+pwpJ6st+H6jiYoD2EEVSmAYY3qXNL3+q1Ok+CHLsIwMCPKaq2LxndD0UF/tUSxfj
+03k9bWtJySgOLnRQvwzZRjoQhsmnP+mg7H/rpXdYaXHmgwo38oZJar55CJD2AhZk
+PuXaTH4MNMn5X7azKFGnpyuqSfqNZSlO42sTp5SjLVFteAxEy9/eCG/Oo2Sr05WE
+1LlSVHJ7liXMvGnjSG4N0MedJ5qq+BOS3R7fY581qRY27Iy4g/Q9iY/NtBde17MX
+QRBdJ3NghVdJIgc=
+-----END CERTIFICATE-----
+
+e-Szigno Root CA 2017
+-----BEGIN CERTIFICATE-----
+MIICQDCCAeWgAwIBAgIMAVRI7yH9l1kN9QQKMAoGCCqGSM49BAMCMHExCzAJBgNV
+BAYTAkhVMREwDwYDVQQHDAhCdWRhcGVzdDEWMBQGA1UECgwNTWljcm9zZWMgTHRk
+LjEXMBUGA1UEYQwOVkFUSFUtMjM1ODQ0OTcxHjAcBgNVBAMMFWUtU3ppZ25vIFJv
+b3QgQ0EgMjAxNzAeFw0xNzA4MjIxMjA3MDZaFw00MjA4MjIxMjA3MDZaMHExCzAJ
+BgNVBAYTAkhVMREwDwYDVQQHDAhCdWRhcGVzdDEWMBQGA1UECgwNTWljcm9zZWMg
+THRkLjEXMBUGA1UEYQwOVkFUSFUtMjM1ODQ0OTcxHjAcBgNVBAMMFWUtU3ppZ25v
+IFJvb3QgQ0EgMjAxNzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABJbcPYrYsHtv
+xie+RJCxs1YVe45DJH0ahFnuY2iyxl6H0BVIHqiQrb1TotreOpCmYF9oMrWGQd+H
+Wyx7xf58etqjYzBhMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
+A1UdDgQWBBSHERUI0arBeAyxr87GyZDvvzAEwDAfBgNVHSMEGDAWgBSHERUI0arB
+eAyxr87GyZDvvzAEwDAKBggqhkjOPQQDAgNJADBGAiEAtVfd14pVCzbhhkT61Nlo
+jbjcI4qKDdQvfepz7L9NbKgCIQDLpbQS+ue16M9+k/zzNY9vTlp8tLxOsvxyqltZ
++efcMQ==
+-----END CERTIFICATE-----
+
+ePKI Root Certification Authority
+-----BEGIN CERTIFICATE-----
+MIIFsDCCA5igAwIBAgIQFci9ZUdcr7iXAF7kBtK8nTANBgkqhkiG9w0BAQUFADBe
+MQswCQYDVQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdod2EgVGVsZWNvbSBDby4sIEx0
+ZC4xKjAoBgNVBAsMIWVQS0kgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAe
+Fw0wNDEyMjAwMjMxMjdaFw0zNDEyMjAwMjMxMjdaMF4xCzAJBgNVBAYTAlRXMSMw
+IQYDVQQKDBpDaHVuZ2h3YSBUZWxlY29tIENvLiwgTHRkLjEqMCgGA1UECwwhZVBL
+SSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIICIjANBgkqhkiG9w0BAQEF
+AAOCAg8AMIICCgKCAgEA4SUP7o3biDN1Z82tH306Tm2d0y8U82N0ywEhajfqhFAH
+SyZbCUNsIZ5qyNUD9WBpj8zwIuQf5/dqIjG3LBXy4P4AakP/h2XGtRrBp0xtInAh
+ijHyl3SJCRImHJ7K2RKilTza6We/CKBk49ZCt0Xvl/T29de1ShUCWH2YWEtgvM3X
+DZoTM1PRYfl61dd4s5oz9wCGzh1NlDivqOx4UXCKXBCDUSH3ET00hl7lSM2XgYI1
+TBnsZfZrxQWh7kcT1rMhJ5QQCtkkO7q+RBNGMD+XPNjX12ruOzjjK9SXDrkb5wdJ
+fzcq+Xd4z1TtW0ado4AOkUPB1ltfFLqfpo0kR0BZv3I4sjZsN/+Z0V0OWQqraffA
+sgRFelQArr5T9rXn4fg8ozHSqf4hUmTFpmfwdQcGlBSBVcYn5AGPF8Fqcde+S/uU
+WH1+ETOxQvdibBjWzwloPn9s9h6PYq2lY9sJpx8iQkEeb5mKPtf5P0B6ebClAZLS
+nT0IFaUQAS2zMnaolQ2zepr7BxB4EW/hj8e6DyUadCrlHJhBmd8hh+iVBmoKs2pH
+dmX2Os+PYhcZewoozRrSgx4hxyy/vv9haLdnG7t4TY3OZ+XkwY63I2binZB1NJip
+NiuKmpS5nezMirH4JYlcWrYvjB9teSSnUmjDhDXiZo1jDiVN1Rmy5nk3pyKdVDEC
+AwEAAaNqMGgwHQYDVR0OBBYEFB4M97Zn8uGSJglFwFU5Lnc/QkqiMAwGA1UdEwQF
+MAMBAf8wOQYEZyoHAAQxMC8wLQIBADAJBgUrDgMCGgUAMAcGBWcqAwAABBRFsMLH
+ClZ87lt4DJX5GFPBphzYEDANBgkqhkiG9w0BAQUFAAOCAgEACbODU1kBPpVJufGB
+uvl2ICO1J2B01GqZNF5sAFPZn/KmsSQHRGoqxqWOeBLoR9lYGxMqXnmbnwoqZ6Yl
+PwZpVnPDimZI+ymBV3QGypzqKOg4ZyYr8dW1P2WT+DZdjo2NQCCHGervJ8A9tDkP
+JXtoUHRVnAxZfVo9QZQlUgjgRywVMRnVvwdVxrsStZf0X4OFunHB2WyBEXYKCrC/
+gpf36j36+uwtqSiUO1bd0lEursC9CBWMd1I0ltabrNMdjmEPNXubrjlpC2JgQCA2
+j6/7Nu4tCEoduL+bXPjqpRugc6bY+G7gMwRfaKonh+3ZwZCc7b3jajWvY9+rGNm6
+5ulK6lCKD2GTHuItGeIwlDWSXQ62B68ZgI9HkFFLLk3dheLSClIKF5r8GrBQAuUB
+o2M3IUxExJtRmREOc5wGj1QupyheRDmHVi03vYVElOEMSyycw5KFNGHLD7ibSkNS
+/jQ6fbjpKdx2qcgw+BRxgMYeNkh0IkFch4LoGHGLQYlE535YW6i4jRPpp2zDR+2z
+Gp1iro2C6pSe3VkQw63d4k3jMdXH7OjysP6SHhYKGvzZ8/gntsm+HbRsZJB/9OTE
+W9c3rkIO3aQab3yIVMUWbuF6aC74Or8NpDyJO3inTmODBCEIZ43ygknQW/2xzQ+D
+hNQ+IIX3Sj0rnP0qCglN6oH4EZw=
+-----END CERTIFICATE-----
+
+emSign ECC Root CA - C3
+-----BEGIN CERTIFICATE-----
+MIICKzCCAbGgAwIBAgIKe3G2gla4EnycqDAKBggqhkjOPQQDAzBaMQswCQYDVQQG
+EwJVUzETMBEGA1UECxMKZW1TaWduIFBLSTEUMBIGA1UEChMLZU11ZGhyYSBJbmMx
+IDAeBgNVBAMTF2VtU2lnbiBFQ0MgUm9vdCBDQSAtIEMzMB4XDTE4MDIxODE4MzAw
+MFoXDTQzMDIxODE4MzAwMFowWjELMAkGA1UEBhMCVVMxEzARBgNVBAsTCmVtU2ln
+biBQS0kxFDASBgNVBAoTC2VNdWRocmEgSW5jMSAwHgYDVQQDExdlbVNpZ24gRUND
+IFJvb3QgQ0EgLSBDMzB2MBAGByqGSM49AgEGBSuBBAAiA2IABP2lYa57JhAd6bci
+MK4G9IGzsUJxlTm801Ljr6/58pc1kjZGDoeVjbk5Wum739D+yAdBPLtVb4Ojavti
+sIGJAnB9SMVK4+kiVCJNk7tCDK93nCOmfddhEc5lx/h//vXyqaNCMEAwHQYDVR0O
+BBYEFPtaSNCAIEDyqOkAB2kZd6fmw/TPMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMB
+Af8EBTADAQH/MAoGCCqGSM49BAMDA2gAMGUCMQC02C8Cif22TGK6Q04ThHK1rt0c
+3ta13FaPWEBaLd4gTCKDypOofu4SQMfWh0/434UCMBwUZOR8loMRnLDRWmFLpg9J
+0wD8ofzkpf9/rdcw0Md3f76BB1UwUCAU9Vc4CqgxUQ==
+-----END CERTIFICATE-----
+
+emSign ECC Root CA - G3
+-----BEGIN CERTIFICATE-----
+MIICTjCCAdOgAwIBAgIKPPYHqWhwDtqLhDAKBggqhkjOPQQDAzBrMQswCQYDVQQG
+EwJJTjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBUZWNo
+bm9sb2dpZXMgTGltaXRlZDEgMB4GA1UEAxMXZW1TaWduIEVDQyBSb290IENBIC0g
+RzMwHhcNMTgwMjE4MTgzMDAwWhcNNDMwMjE4MTgzMDAwWjBrMQswCQYDVQQGEwJJ
+TjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBUZWNobm9s
+b2dpZXMgTGltaXRlZDEgMB4GA1UEAxMXZW1TaWduIEVDQyBSb290IENBIC0gRzMw
+djAQBgcqhkjOPQIBBgUrgQQAIgNiAAQjpQy4LRL1KPOxst3iAhKAnjlfSU2fySU0
+WXTsuwYc58Byr+iuL+FBVIcUqEqy6HyC5ltqtdyzdc6LBtCGI79G1Y4PPwT01xyS
+fvalY8L1X44uT6EYGQIrMgqCZH0Wk9GjQjBAMB0GA1UdDgQWBBR8XQKEE9TMipuB
+zhccLikenEhjQjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAKBggq
+hkjOPQQDAwNpADBmAjEAvvNhzwIQHWSVB7gYboiFBS+DCBeQyh+KTOgNG3qxrdWB
+CUfvO6wIBHxcmbHtRwfSAjEAnbpV/KlK6O3t5nYBQnvI+GDZjVGLVTv7jHvrZQnD
++JbNR6iC8hZVdyR+EhCVBCyj
+-----END CERTIFICATE-----
+
+emSign Root CA - C1
+-----BEGIN CERTIFICATE-----
+MIIDczCCAlugAwIBAgILAK7PALrEzzL4Q7IwDQYJKoZIhvcNAQELBQAwVjELMAkG
+A1UEBhMCVVMxEzARBgNVBAsTCmVtU2lnbiBQS0kxFDASBgNVBAoTC2VNdWRocmEg
+SW5jMRwwGgYDVQQDExNlbVNpZ24gUm9vdCBDQSAtIEMxMB4XDTE4MDIxODE4MzAw
+MFoXDTQzMDIxODE4MzAwMFowVjELMAkGA1UEBhMCVVMxEzARBgNVBAsTCmVtU2ln
+biBQS0kxFDASBgNVBAoTC2VNdWRocmEgSW5jMRwwGgYDVQQDExNlbVNpZ24gUm9v
+dCBDQSAtIEMxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz+upufGZ
+BczYKCFK83M0UYRWEPWgTywS4/oTmifQz/l5GnRfHXk5/Fv4cI7gklL35CX5VIPZ
+HdPIWoU/Xse2B+4+wM6ar6xWQio5JXDWv7V7Nq2s9nPczdcdioOl+yuQFTdrHCZH
+3DspVpNqs8FqOp099cGXOFgFixwR4+S0uF2FHYP+eF8LRWgYSKVGczQ7/g/IdrvH
+GPMF0Ybzhe3nudkyrVWIzqa2kbBPrH4VI5b2P/AgNBbeCsbEBEV5f6f9vtKppa+c
+xSMq9zwhbL2vj07FOrLzNBL834AaSaTUqZX3noleoomslMuoaJuvimUnzYnu3Yy1
+aylwQ6BpC+S5DwIDAQABo0IwQDAdBgNVHQ4EFgQU/qHgcB4qAzlSWkK+XJGFehiq
+TbUwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEL
+BQADggEBAMJKVvoVIXsoounlHfv4LcQ5lkFMOycsxGwYFYDGrK9HWS8mC+M2sO87
+/kOXSTKZEhVb3xEp/6tT+LvBeA+snFOvV71ojD1pM/CjoCNjO2RnIkSt1XHLVip4
+kqNPEjE2NuLe/gDEo2APJ62gsIq1NnpSob0n9CAnYuhNlCQT5AoE6TyrLshDCUrG
+YQTlSTR+08TI9Q/Aqum6VF7zYytPT1DU/rl7mYw9wC68AivTxEDkigcxHpvOJpkT
++xHqmiIMERnHXhuBUDDIlhJu58tBf5E7oke3VIAb3ADMmpDqw8NQBmIMMMAVSKeo
+WXzhriKi4gp6D/piq1JM4fHfyr6DDUI=
+-----END CERTIFICATE-----
+
+emSign Root CA - G1
+-----BEGIN CERTIFICATE-----
+MIIDlDCCAnygAwIBAgIKMfXkYgxsWO3W2DANBgkqhkiG9w0BAQsFADBnMQswCQYD
+VQQGEwJJTjETMBEGA1UECxMKZW1TaWduIFBLSTElMCMGA1UEChMcZU11ZGhyYSBU
+ZWNobm9sb2dpZXMgTGltaXRlZDEcMBoGA1UEAxMTZW1TaWduIFJvb3QgQ0EgLSBH
+MTAeFw0xODAyMTgxODMwMDBaFw00MzAyMTgxODMwMDBaMGcxCzAJBgNVBAYTAklO
+MRMwEQYDVQQLEwplbVNpZ24gUEtJMSUwIwYDVQQKExxlTXVkaHJhIFRlY2hub2xv
+Z2llcyBMaW1pdGVkMRwwGgYDVQQDExNlbVNpZ24gUm9vdCBDQSAtIEcxMIIBIjAN
+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAk0u76WaK7p1b1TST0Bsew+eeuGQz
+f2N4aLTNLnF115sgxk0pvLZoYIr3IZpWNVrzdr3YzZr/k1ZLpVkGoZM0Kd0WNHVO
+8oG0x5ZOrRkVUkr+PHB1cM2vK6sVmjM8qrOLqs1D/fXqcP/tzxE7lM5OMhbTI0Aq
+d7OvPAEsbO2ZLIvZTmmYsvePQbAyeGHWDV/D+qJAkh1cF+ZwPjXnorfCYuKrpDhM
+tTk1b+oDafo6VGiFbdbyL0NVHpENDtjVaqSW0RM8LHhQ6DqS0hdW5TUaQBw+jSzt
+Od9C4INBdN+jzcKGYEho42kLVACL5HZpIQ15TjQIXhTCzLG3rdd8cIrHhQIDAQAB
+o0IwQDAdBgNVHQ4EFgQU++8Nhp6w492pufEhF38+/PB3KxowDgYDVR0PAQH/BAQD
+AgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAFn/8oz1h31x
+PaOfG1vR2vjTnGs2vZupYeveFix0PZ7mddrXuqe8QhfnPZHr5X3dPpzxz5KsbEjM
+wiI/aTvFthUvozXGaCocV685743QNcMYDHsAVhzNixl03r4PEuDQqqE/AjSxcM6d
+GNYIAwlG7mDgfrbESQRRfXBgvKqy/3lyeqYdPV8q+Mri/Tm3R7nrft8EI6/6nAYH
+6ftjk4BAtcZsCjEozgyfz7MjNYBBjWzEN3uBL4ChQEKF6dk4jeihU80Bv2noWgby
+RQuQ+q7hv53yrlc8pa6yVvSLZUDp/TGBLPQ5Cdjua6e0ph0VpZj3AYHYhX3zUVxx
+iN66zB+Afko=
+-----END CERTIFICATE-----
+
diff --git a/src/etc/services/supervisord/openmotics.conf b/src/etc/services/supervisord/openmotics.conf
new file mode 100644
index 00000000..9e04e8f9
--- /dev/null
+++ b/src/etc/services/supervisord/openmotics.conf
@@ -0,0 +1,13 @@
+[program:openmotics]
+autorestart=true
+autostart=true
+command=/opt/openmotics/versions/venv/current/venv/bin/gw-service
+directory=/opt/openmotics/python
+environment=OPENMOTICS_PREFIX=/opt/openmotics
+startsecs=10
+stderr_logfile=/var/log/supervisor/%(program_name)s_stderr.log
+stderr_logfile_maxbytes=1MB
+stderr_logfile_backups=2
+stdout_logfile=/var/log/supervisor/%(program_name)s_stdout.log
+stdout_logfile_maxbytes=3MB
+stdout_logfile_backups=2
diff --git a/src/etc/services/supervisord/sha256.json b/src/etc/services/supervisord/sha256.json
new file mode 100644
index 00000000..01446a91
--- /dev/null
+++ b/src/etc/services/supervisord/sha256.json
@@ -0,0 +1,5 @@
+{
+    "openmotics": "f980e0b5fe1c83120d08809912bebc70fc309b502b82d4c9d7a323730b115ad0",
+    "vpn_service": "c64a466866a5e1ff513cc2716581e4a8920b59dc61e585e9fe8340fd50668cb2",
+    "watchdog": "02d180af8dd5e4f5850330020761864cbaeb9b64b628342dae408f68c939585f"
+}
diff --git a/src/etc/services/supervisord/vpn_service.conf b/src/etc/services/supervisord/vpn_service.conf
new file mode 100644
index 00000000..a0e700fd
--- /dev/null
+++ b/src/etc/services/supervisord/vpn_service.conf
@@ -0,0 +1,13 @@
+[program:vpn_service]
+autorestart=true
+autostart=true
+command=/opt/openmotics/versions/venv/current/venv/bin/gw-vpn-service
+directory=/opt/openmotics/python
+environment=OPENMOTICS_PREFIX=/opt/openmotics
+startsecs=10
+stderr_logfile=/var/log/supervisor/%(program_name)s_stderr.log
+stderr_logfile_maxbytes=1MB
+stderr_logfile_backups=2
+stdout_logfile=/var/log/supervisor/%(program_name)s_stdout.log
+stdout_logfile_maxbytes=3MB
+stdout_logfile_backups=2
diff --git a/src/etc/services/supervisord/watchdog.conf b/src/etc/services/supervisord/watchdog.conf
new file mode 100644
index 00000000..3231a9ec
--- /dev/null
+++ b/src/etc/services/supervisord/watchdog.conf
@@ -0,0 +1,13 @@
+[program:watchdog]
+autorestart=true
+autostart=true
+command=/opt/openmotics/versions/venv/current/venv/bin/gw-watchdog
+directory=/opt/openmotics/python
+environment=OPENMOTICS_PREFIX=/opt/openmotics
+startsecs=10
+stderr_logfile=/var/log/supervisor/%(program_name)s_stderr.log
+stderr_logfile_maxbytes=1MB
+stderr_logfile_backups=2
+stdout_logfile=/var/log/supervisor/%(program_name)s_stdout.log
+stdout_logfile_maxbytes=3MB
+stdout_logfile_backups=2
diff --git a/src/etc/services/systemd/openmotics-api.service b/src/etc/services/systemd/openmotics-api.service
new file mode 100644
index 00000000..ba1b2372
--- /dev/null
+++ b/src/etc/services/systemd/openmotics-api.service
@@ -0,0 +1,23 @@
+[Unit]
+Description=OpenMotics Gateway API
+After=openmotics.service network.target
+PartOf=openmotics.service
+Requires=openmotics.service
+
+[Service]
+User=root
+ExecStart=/opt/openmotics/versions/venv/current/venv/bin/gw-service
+WorkingDirectory=/opt/openmotics/python
+SyslogIdentifier=openmotics-api
+StandardOutput=syslog
+StandardError=syslog
+KillMode=process
+TimeoutStopSec=15
+Restart=always
+RestartSec=10
+TimeoutSec=5
+
+Environment="OPENMOTICS_PREFIX=/opt/openmotics"
+
+[Install]
+WantedBy=openmotics.service
diff --git a/src/etc/services/systemd/openmotics-vpn.service b/src/etc/services/systemd/openmotics-vpn.service
new file mode 100644
index 00000000..990d7f04
--- /dev/null
+++ b/src/etc/services/systemd/openmotics-vpn.service
@@ -0,0 +1,17 @@
+[Unit]
+Description=OpenMotics Gateway VPN
+After=openmotics.service network-online.target
+PartOf=openmotics.service
+Requires=openmotics.service
+
+[Service]
+User=root
+ExecStart=/opt/openmotics/versions/venv/current/venv/bin/gw-vpn-service
+WorkingDirectory=/opt/openmotics/python
+Restart=always
+RestartSec=10
+TimeoutSec=5
+Environment="OPENMOTICS_PREFIX=/opt/openmotics"
+
+[Install]
+WantedBy=openmotics.service
diff --git a/src/etc/services/systemd/openmotics-watchdog.service b/src/etc/services/systemd/openmotics-watchdog.service
new file mode 100644
index 00000000..43dd7ace
--- /dev/null
+++ b/src/etc/services/systemd/openmotics-watchdog.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=OpenMotics Watchdog
+After=network.target
+
+[Service]
+User=root
+ExecStart=/opt/openmotics/versions/venv/current/venv/bin/gw-watchdog
+WorkingDirectory=/opt/openmotics/python
+Restart=always
+RestartSec=10
+
+[Install]
+WantedBy=multi-user.target
diff --git a/src/etc/services/systemd/sha256.json b/src/etc/services/systemd/sha256.json
new file mode 100644
index 00000000..00972f7c
--- /dev/null
+++ b/src/etc/services/systemd/sha256.json
@@ -0,0 +1,5 @@
+{
+    "openmotics": "64e8ddced23426fc5a40966da515f9dd2ef39358e573ac6ad4b04744a94a1ff1",
+    "vpn_service": "fc331289496b454fe135e653658113acb7cf173f4a3e682d00629e6a992b5d50",
+    "watchdog": "3f59cb7759025105820c3e5718555047fee6fdce946370b8e65bfa3c61ab433c"
+}
diff --git a/src/gateway/__init__.py b/src/gateway/__init__.py
index b0b68160..0bd2bb62 100644
--- a/src/gateway/__init__.py
+++ b/src/gateway/__init__.py
@@ -14,4 +14,4 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 """ Module containing the functionality provided by the gateway. """
 
-__version__ = '2.25.4'
+__version__ = '2.99.0'
diff --git a/src/gateway/alembic/versions/0f6ba3c709b6_valve_driver.py b/src/gateway/alembic/versions/0f6ba3c709b6_valve_driver.py
new file mode 100644
index 00000000..941afc15
--- /dev/null
+++ b/src/gateway/alembic/versions/0f6ba3c709b6_valve_driver.py
@@ -0,0 +1,62 @@
+"""valve_driver
+
+Revision ID: 0f6ba3c709b6
+Revises: dd7b74eca352
+Create Date: 2022-08-23 16:33:18.326993
+
+"""
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = '0f6ba3c709b6'
+down_revision = 'dd7b74eca352'
+branch_labels = None
+depends_on = None
+
+
+def upgrade():
+    # ### commands auto generated by Alembic - please adjust! ###
+    new_table = op.create_table('indoor_link_valves',
+    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
+    sa.Column('thermostat_link_id', sa.Integer(), nullable=True),
+    sa.Column('valve_id', sa.Integer(), nullable=False),
+    sa.Column('mode', sa.String(length=255), nullable=False),
+    sa.ForeignKeyConstraint(['thermostat_link_id'], ['thermostat.id'], name=op.f('fk_indoor_link_valves_thermostat_link_id_thermostat'), ondelete='CASCADE'),
+    sa.ForeignKeyConstraint(['valve_id'], ['valve.id'], name=op.f('fk_indoor_link_valves_valve_id_valve'), ondelete='CASCADE'),
+    sa.PrimaryKeyConstraint('id', name=op.f('pk_indoor_link_valves')),
+    sqlite_autoincrement=True
+    )
+    # ### end Alembic commands ###
+
+    # ### start migrate old data into new table ###
+    # fetch old data
+    conn = op.get_bind()
+    res = conn.execute("select thermostat_id, valve_id, mode from valvetothermostat")
+    results = res.fetchall()
+
+    # Prepare an old_info object to insert into the new table.
+    old_info = [{'thermostat_link_id': r[0], 'valve_id': r[1], 'mode': r[2]} for r in results]
+
+    # Insert old_info into new farminfo table.
+    op.bulk_insert(new_table, old_info)
+
+    # ### end migrate old data into new table ###
+
+    op.drop_table('valvetothermostat')
+
+
+def downgrade():
+    # ### commands auto generated by Alembic - please adjust! ###
+    op.create_table('valvetothermostat',
+    sa.Column('thermostat_id', sa.INTEGER(), nullable=False),
+    sa.Column('valve_id', sa.INTEGER(), nullable=False),
+    sa.Column('mode', sa.VARCHAR(length=255), nullable=False),
+    sa.Column('priority', sa.INTEGER(), nullable=False),
+    sa.ForeignKeyConstraint(['thermostat_id'], ['thermostat.id'], name='fk_valvetothermostat_thermostat_id_thermostat', ondelete='CASCADE'),
+    sa.ForeignKeyConstraint(['valve_id'], ['valve.id'], name='fk_valvetothermostat_valve_id_valve', ondelete='CASCADE'),
+    sa.PrimaryKeyConstraint('thermostat_id', 'valve_id', 'mode', name='pk_valvetothermostat')
+    )
+    op.drop_table('indoor_link_valves')
+    # ### end Alembic commands ###
diff --git a/src/gateway/alembic/versions/9813cf3ca8f3_added_screens.py b/src/gateway/alembic/versions/9813cf3ca8f3_added_screens.py
new file mode 100644
index 00000000..c6018862
--- /dev/null
+++ b/src/gateway/alembic/versions/9813cf3ca8f3_added_screens.py
@@ -0,0 +1,39 @@
+"""Added screens
+
+Revision ID: 9813cf3ca8f3
+Revises: 916a8d2791e5
+Create Date: 2022-06-08 13:09:18.554392
+
+"""
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = '9813cf3ca8f3'
+down_revision = '916a8d2791e5'
+branch_labels = None
+depends_on = None
+
+
+def upgrade():
+    op.create_table('screen',
+        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
+        sa.Column('room_id', sa.Integer(), nullable=True),
+        sa.Column('name', sa.String(length=255), nullable=False),
+        sa.Column('in_use', sa.Boolean(), nullable=False),
+        sa.Column('type', sa.String(length=255), nullable=False),
+        sa.Column('translational_steps', sa.Integer(), nullable=True),
+        sa.Column('rotational_steps', sa.Integer(), nullable=True),
+        sa.Column('source', sa.String(length=255), nullable=False),
+        sa.Column('external_id', sa.String(length=255), nullable=False),
+        sa.Column('plugin_id', sa.Integer(), nullable=True),
+        sa.ForeignKeyConstraint(['plugin_id'], ['plugin.id'], name=op.f('fk_screen_plugin_id_plugin'), ondelete='CASCADE'),
+        sa.ForeignKeyConstraint(['room_id'], ['room.id'], name=op.f('fk_screen_room_id_room'), ondelete='SET NULL'),
+        sa.PrimaryKeyConstraint('id', name=op.f('pk_screen')),
+        sqlite_autoincrement=True
+    )
+
+
+def downgrade():
+    op.drop_table('screen')
diff --git a/src/gateway/alembic/versions/dd7b74eca352_hvac_drivers.py b/src/gateway/alembic/versions/dd7b74eca352_hvac_drivers.py
new file mode 100644
index 00000000..e7959119
--- /dev/null
+++ b/src/gateway/alembic/versions/dd7b74eca352_hvac_drivers.py
@@ -0,0 +1,65 @@
+"""hvac_drivers
+
+Revision ID: dd7b74eca352
+Revises: 9813cf3ca8f3
+Create Date: 2022-08-16 18:29:49.568444
+
+"""
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = 'dd7b74eca352'
+down_revision = '9813cf3ca8f3'
+branch_labels = None
+depends_on = None
+
+
+def upgrade():
+    # ### commands auto generated by Alembic - please adjust! ###
+    new_table = op.create_table('hvac_output_link',
+    sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
+    sa.Column('hvac_id', sa.Integer(), nullable=False),
+    sa.Column('output_id', sa.Integer(), nullable=False),
+    sa.Column('mode', sa.String(), nullable=False),
+    sa.Column('value', sa.Integer(), nullable=False),
+    sa.ForeignKeyConstraint(['hvac_id'], ['thermostatgroup.id'], name=op.f('fk_hvac_output_link_hvac_id_thermostatgroup'), ondelete='CASCADE'),
+    sa.ForeignKeyConstraint(['output_id'], ['output.id'], name=op.f('fk_hvac_output_link_output_id_output'), ondelete='CASCADE'),
+    sa.PrimaryKeyConstraint('id', name=op.f('pk_hvac_output_link')),
+    sa.UniqueConstraint('hvac_id', 'output_id', 'mode', name=op.f('uq_hvac_output_link_hvac_id')),
+    sqlite_autoincrement=True
+    )
+    # ### end Alembic commands ###
+
+    # ### start migrate old data into new table ###
+    # fetch old data
+    conn = op.get_bind()
+    res = conn.execute("select output_id, thermostat_group_id, mode, value from outputtothermostatgroup")
+    results = res.fetchall()
+
+    # Prepare an old_info object to insert into the new table.
+    old_info = [{'output_id': r[0], 'hvac_id': r[1], 'mode': r[2], 'value': r[3]} for r in results]
+
+    # Insert old_info into new farminfo table.
+    op.bulk_insert(new_table, old_info)
+
+    # ### end migrate old data into new table ###
+    
+    op.drop_table('outputtothermostatgroup')
+
+
+def downgrade():
+    # ### commands auto generated by Alembic - please adjust! ###
+    op.create_table('outputtothermostatgroup',
+    sa.Column('output_id', sa.INTEGER(), nullable=False),
+    sa.Column('thermostat_group_id', sa.INTEGER(), nullable=False),
+    sa.Column('mode', sa.VARCHAR(length=255), nullable=False),
+    sa.Column('index', sa.INTEGER(), nullable=False),
+    sa.Column('value', sa.INTEGER(), nullable=False),
+    sa.ForeignKeyConstraint(['output_id'], ['output.id'], name='fk_outputtothermostatgroup_output_id_output', ondelete='CASCADE'),
+    sa.ForeignKeyConstraint(['thermostat_group_id'], ['thermostatgroup.id'], name='fk_outputtothermostatgroup_thermostat_group_id_thermostatgroup', ondelete='CASCADE'),
+    sa.PrimaryKeyConstraint('output_id', 'thermostat_group_id', 'mode', name='pk_outputtothermostatgroup')
+    )
+    op.drop_table('hvac_output_link')
+    # ### end Alembic commands ###
diff --git a/src/gateway/api/V1/__init__.py b/src/gateway/api/V1/__init__.py
index 1c964e0d..780d3e5b 100644
--- a/src/gateway/api/V1/__init__.py
+++ b/src/gateway/api/V1/__init__.py
@@ -16,9 +16,10 @@
 V1 api init file
 """
 
-from gateway.api.V1.notifications import Notifications, PluginNotification
+from gateway.api.V1.notifications import Notifications
 from gateway.api.V1.rooms import Rooms
 from gateway.api.V1.schema import Schema
-from gateway.api.V1.sensors import PluginSensor, Sensors
-from gateway.api.V1.ventilation_units import PluginVentilation, \
-    VentilationUnits
+from gateway.api.V1.screens import Screens
+from gateway.api.V1.sensors import Sensors
+from gateway.api.V1.ventilation_units import VentilationUnits
+from gateway.api.V1.shutters import Shutters
diff --git a/src/gateway/api/V1/notifications.py b/src/gateway/api/V1/notifications.py
index ffa6355c..6b8d5bea 100644
--- a/src/gateway/api/V1/notifications.py
+++ b/src/gateway/api/V1/notifications.py
@@ -18,24 +18,15 @@ Users api description
 from __future__ import absolute_import
 
 import logging
-import uuid
-
 import cherrypy
 
-from gateway.api.V1.schema import SCHEMA
 from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, \
     openmotics_api_v1
 from ioc import INJECTED, Inject
-from gateway.events import GatewayEvent
 from cloud.events import EventSender
 
 logger = logging.getLogger(__name__)
 
-if False:  # MyPy
-    from typing import Dict, List, Any
-    from gateway.dto import UserDTO
-    from gateway.authentication_controller import AuthenticationToken
-
 
 @expose
 class Notifications(RestAPIEndpoint):
@@ -54,61 +45,3 @@ class Notifications(RestAPIEndpoint):
     @openmotics_api_v1(auth=True)
     def list(self):
         return ApiResponse(body=[])
-
-
-@expose
-class PluginNotification(RestAPIEndpoint):
-    API_ENDPOINT = '/plugin/notification'
-
-    @Inject
-    def __init__(self, event_sender=INJECTED):
-        # type: (EventSender) -> None
-        super(PluginNotification, self).__init__()
-        self.event_sender = event_sender
-        self.route_dispatcher = cherrypy.dispatch.RoutesDispatcher()
-        self.route_dispatcher.connect('create', '',
-                                      controller=self, action='create',
-                                      conditions={'method': ['POST', 'OPTIONS']})
-
-    @openmotics_api_v1(auth=True, expect_body_type='JSON')
-    def create(self, request_body):
-        """
-        {"source": "plugin", "plugin": "DummyPlugin", "topic": "warning", "message": "Something happened", "type": "USER"}
-        """
-        schema = {
-            "type": "object",
-            "required": ["source"],
-            "properties": {
-                "source": {
-                    "enum": ["plugin"]
-                }
-            },
-            "dependencies": {
-                "source": {
-                    "oneOf": [
-                        {
-                            "required": ["source", "plugin", "topic", "message"],
-                            "properties": {
-                                "source": {"const": "plugin"},
-                                "plugin": {"type": "string"},
-                                "topic": {"type": "string"},
-                                "message": {"type": "string"},
-                                "type": {"type": "string"}
-                            }
-                        }
-                    ]
-                }
-            }
-        }
-        # validate(request_body, schema)
-        source, topic, message = request_body['source'], request_body['topic'], request_body['message']
-        type = request_body.get('type', 'USER')
-        plugin = request_body.get('plugin')
-        gateway_event = GatewayEvent(event_type=GatewayEvent.Types.NOTIFICATION,
-                                     data={'source': source,
-                                           'plugin': plugin,
-                                           'type': type,
-                                           'topic': topic,
-                                           'message': message})
-        self.event_sender.enqueue_event(gateway_event)
-        return ApiResponse(body={})  # TODO
diff --git a/src/gateway/api/V1/rooms.py b/src/gateway/api/V1/rooms.py
index 05b1f56d..162326ac 100644
--- a/src/gateway/api/V1/rooms.py
+++ b/src/gateway/api/V1/rooms.py
@@ -22,7 +22,6 @@ import uuid
 
 import cherrypy
 
-from gateway.api.V1.schema import SCHEMA
 from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, \
     openmotics_api_v1
 from gateway.exceptions import ItemDoesNotExistException
diff --git a/src/gateway/api/V1/schema.py b/src/gateway/api/V1/schema.py
index f227253e..6fd550f7 100644
--- a/src/gateway/api/V1/schema.py
+++ b/src/gateway/api/V1/schema.py
@@ -1,113 +1,8 @@
-import logging
-import uuid
-
 import cherrypy
 
 from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, \
     openmotics_api_v1
-
-
-SCHEMA = {
-    "room": {
-        "type": "object",
-        "required": ["id"],
-        "actions": ["list"],
-        "properties": {
-            "id": {
-                "type": "integer",
-                "maximum": 254,
-                "readOnly": True
-            },
-            "name": {
-                "type": "string",
-                "maxLength": 255
-            }
-        },
-        "definitions": {
-        }
-    },
-    "ventilation_unit": {
-        "type": "object",
-        "required": ["id", "name", "room"],
-        "actions": ["list", "update"],
-        "properties": {
-            "id": {
-                "type": "integer",
-                "readOnly": True
-            },
-            "name": {
-                "type": "string",
-                "maxLength": 255
-            },
-            "room": {
-                "$ref": "#/definitions/room_id"
-            },
-            "amount_of_levels": {
-                "type": "integer",
-                "readOnly": True
-            },
-            "source": {
-                "enum": ["plugin"],
-                "readOnly": True
-            },
-            "device": {
-                "type": "object",
-                "properties": {
-                    "vendor": {
-                        "type": "string",
-                        "default": "",
-                        "readOnly": True
-                    },
-                    "type": {
-                        "type": "string",
-                        "default": "",
-                        "readOnly": True
-                    },
-                    "serial": {
-                        "type": "string",
-                        "default": "",
-                        "readOnly": True
-                    }
-                }
-            }
-        },
-        "dependencies": {
-            "source": {
-                "oneOf": [
-                    {
-                        "properties": {
-                            "source": {"const": "plugin"},
-                            "plugin": {
-                                "$ref": "#/definitions/plugin_id",
-                                "readOnly": True
-                            },
-                            "external_id": {
-                                "type": "string",
-                                "readOnly": True
-                            }
-                        }
-                    }
-                ]
-            }
-        },
-        "definitions": {
-            "room_id": {
-                "type": ["integer", "null"],
-                "maximum": 254,
-                "format": "entity-dropdown",
-                "format:options": {
-                    "empty": True
-                },
-                "entity": "rooms"
-            },
-            "plugin_id": {
-                "type": ["integer"],
-                "format": "entity-dropdown",
-                "entity": "plugins"
-            }
-        }
-    }
-}
+from gateway.api.V1.schemas import ROOM_SCHEMA, VENTILATION_UNIT_SCHEMA, SHUTTER_SCHEMA
 
 
 @expose
@@ -124,4 +19,7 @@ class Schema(RestAPIEndpoint):
 
     @openmotics_api_v1(auth=False)
     def retrieve(self):
-        return ApiResponse(body=SCHEMA)
+        schema = {'room': ROOM_SCHEMA,
+                  'ventilation_unit': VENTILATION_UNIT_SCHEMA,
+                  'shutter': SHUTTER_SCHEMA}
+        return ApiResponse(body=schema)
diff --git a/src/gateway/api/V1/schemas/__init__.py b/src/gateway/api/V1/schemas/__init__.py
new file mode 100644
index 00000000..495f5446
--- /dev/null
+++ b/src/gateway/api/V1/schemas/__init__.py
@@ -0,0 +1,3 @@
+from gateway.api.V1.schemas.room import ROOM_SCHEMA
+from gateway.api.V1.schemas.shutter import SHUTTER_SCHEMA
+from gateway.api.V1.schemas.ventilation_unit import VENTILATION_UNIT_SCHEMA
diff --git a/src/gateway/api/V1/schemas/room.py b/src/gateway/api/V1/schemas/room.py
new file mode 100644
index 00000000..33047b43
--- /dev/null
+++ b/src/gateway/api/V1/schemas/room.py
@@ -0,0 +1,18 @@
+ROOM_SCHEMA = {
+    "type": "object",
+    "required": ["id"],
+    "actions": ["list"],
+    "properties": {
+        "id": {
+            "type": "integer",
+            "maximum": 254,
+            "readOnly": True
+        },
+        "name": {
+            "type": "string",
+            "maxLength": 255
+        }
+    },
+    "definitions": {
+    }
+}
diff --git a/src/gateway/api/V1/schemas/shutter.py b/src/gateway/api/V1/schemas/shutter.py
new file mode 100644
index 00000000..156f364e
--- /dev/null
+++ b/src/gateway/api/V1/schemas/shutter.py
@@ -0,0 +1,146 @@
+from platform_utils import Platform
+
+SHUTTER_SCHEMA = {
+    "type": "object",
+    "required": ["id", "name", "room_id", "inverted", "group_1", "group_2", "steps", "in_use", "timer_up", "timer_down"],
+    "actions": ["list", "update"],
+    "properties": {
+        "id": {
+            "type": "integer",
+            "readOnly": True
+        },
+        "name": {
+            "type": "string",
+            "maxLength": 255
+        },
+        "timer_up": {
+            "$ref": "#/definitions/timer",
+            "required": True
+        },
+        "timer_down": {
+            "$ref": "#/definitions/timer",
+            "required": True
+        },
+        "inverted": {
+            "type": "boolean"
+        },
+        "group_1": {
+            "type": ["integer", "null"],
+            "maximum": 254,
+            "minimum": 0
+        },
+        "group_2": {
+            "type": ["integer", "null"],
+            "maximum": 254,
+            "minimum": 0
+        },
+        "room_id": {
+            "$ref": "#/definitions/room_id"
+        },
+        "steps": {
+            "type": ["integer", "null"],
+            "maximum": 255 * 255 - 1,
+            "minimum": 0
+        },
+        "in_use": {
+            "type": "boolean"
+        },
+        "module": {
+            "$ref": "#/definitions/module",
+            "readOnly": True,
+        }
+    },
+    "dependencies": {},
+    "definitions": {
+        "room_id": {
+            "type": ["integer", "null"],
+            "maximum": 254,
+            "format": "entity-dropdown",
+            "format:options": {
+                "empty": True
+            },
+            "entity": "rooms"
+        },
+        "module": {
+            "type": ["object", "null"],
+            "required": ["hardware_type", "hardware_module", "module_id"],
+            "properties": {
+                "hardware_type": {
+                    "type": "string",
+                    "enum": ["virtual", "physical", "emulated", "internal"]
+                },
+                "hardware_module": {
+                    "type": "string",
+                    "enum": ["sensor", "input", "output", "shutter", "dim_control", "can_control", "open_collector",
+                             "ucan",
+                             "energy", "power", "p1_concentrator",
+                             "master_core", "master_classic",
+                             "unknown"]
+                },
+                "module_id": {
+                    "type": "integer"
+                }
+            }
+        },
+        "timer": {
+            "type": "object",
+            "properties": {
+                "type": {
+                    "type": "string",
+                    "enum": ["disabled", "seconds"] +
+                            (["milliseconds", "minutes"] if Platform.get_platform() in Platform.CoreTypes else [])
+                }
+            },
+            "dependencies": {
+                "type": {
+                    "oneOf": [
+                        {
+                            "properties": {
+                                "type": {
+                                    "enum": ["disabled"]
+                                },
+                            }
+                        },
+                        {
+                            "properties": {
+                                "type": {
+                                    "enum": ["seconds"]
+                                },
+                                "seconds": {
+                                    "type": "integer",
+                                    "minimum": 0,
+                                    "maximum": 65535
+                                }
+                            }
+                        }
+                    ] + ([
+                        {
+                            "properties": {
+                                "type": {
+                                    "enum": ["milliseconds"]
+                                },
+                                "milliseconds": {
+                                    "type": "integer",
+                                    "minimum": 0,
+                                    "maximum": 65535
+                                }
+                            }
+                        },
+                        {
+                            "properties": {
+                                "type": {
+                                    "enum": ["minutes"]
+                                },
+                                "minutes": {
+                                    "type": "integer",
+                                    "minimum": 0,
+                                    "maximum": 65535
+                                }
+                            }
+                        }
+                    ] if Platform.get_platform() in Platform.CoreTypes else [])
+                }
+            }
+        }
+    }
+}
diff --git a/src/gateway/api/V1/schemas/ventilation_unit.py b/src/gateway/api/V1/schemas/ventilation_unit.py
new file mode 100644
index 00000000..08d31d3d
--- /dev/null
+++ b/src/gateway/api/V1/schemas/ventilation_unit.py
@@ -0,0 +1,76 @@
+VENTILATION_UNIT_SCHEMA = {
+    "type": "object",
+    "required": ["id", "name", "room"],
+    "actions": ["list", "update"],
+    "properties": {
+        "id": {
+            "type": "integer",
+            "readOnly": True
+        },
+        "name": {
+            "type": "string",
+            "maxLength": 255
+        },
+        "room": {
+            "$ref": "#/definitions/room_id"
+        },
+        "source": {
+            "enum": ["plugin"],
+            "readOnly": True
+        },
+    },
+    "dependencies": {
+        "source": {
+            "oneOf": [
+                {
+                    "properties": {
+                        "source": {"const": "plugin"},
+                        "plugin": {
+                            "type": "string",
+                            "readOnly": True
+                        },
+                        "external_id": {
+                            "type": "string",
+                            "readOnly": True
+                        },
+                        "amount_of_levels": {
+                            "type": "integer",
+                            "readOnly": True
+                        },
+                        "device": {
+                            "type": "object",
+                            "properties": {
+                                "vendor": {
+                                    "type": "string",
+                                    "default": "",
+                                    "readOnly": True
+                                },
+                                "type": {
+                                    "type": "string",
+                                    "default": "",
+                                    "readOnly": True
+                                },
+                                "serial": {
+                                    "type": "string",
+                                    "default": "",
+                                    "readOnly": True
+                                }
+                            }
+                        }
+                    }
+                }
+            ]
+        }
+    },
+    "definitions": {
+        "room_id": {
+            "type": ["integer", "null"],
+            "maximum": 254,
+            "format": "entity-dropdown",
+            "format:options": {
+                "empty": True
+            },
+            "entity": "rooms"
+        },
+    }
+}
diff --git a/src/gateway/api/V1/screens.py b/src/gateway/api/V1/screens.py
new file mode 100644
index 00000000..d81f1314
--- /dev/null
+++ b/src/gateway/api/V1/screens.py
@@ -0,0 +1,95 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Screens api description
+"""
+from __future__ import absolute_import
+
+import logging
+import cherrypy
+
+from gateway.api.V1.serializers.screen import ScreenApiSerializer
+from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, openmotics_api_v1
+from gateway.screen_controller import ScreenController
+from ioc import INJECTED, Inject
+
+logger = logging.getLogger(__name__)
+
+
+@expose
+class Screens(RestAPIEndpoint):
+    API_ENDPOINT = '/api/screens'
+
+    @Inject
+    def __init__(self, screen_controller=INJECTED):
+        # type: (ScreenController) -> None
+        super(Screens, self).__init__()
+        self._screen_controller = screen_controller
+        self.route_dispatcher = cherrypy.dispatch.RoutesDispatcher()
+        self.route_dispatcher.connect('list', '',
+                                      controller=self, action='list',
+                                      conditions={'method': ['GET']})
+        self.route_dispatcher.connect('sync', '/sync',
+                                      controller=self, action='sync',
+                                      conditions={'method': ['GET']})
+        self.route_dispatcher.connect('retrieve', '/:screen_id',
+                                      controller=self, action='retrieve',
+                                      conditions={'method': ['GET']})
+        for action in ['stop', 'open', 'close']:
+            self.route_dispatcher.connect(action, '/:screen_id/{0}'.format(action),
+                                          controller=self, action=action,
+                                          conditions={'method': ['POST']})
+        self.route_dispatcher.connect('goto_position', '/:screen_id/goto_position',
+                                      controller=self, action='goto_position',
+                                      conditions={'method': ['POST']})
+
+    @openmotics_api_v1(auth=True)
+    def list(self):
+        screens = self._screen_controller.load_screens()
+        data = [ScreenApiSerializer.serialize(screen) for screen in screens]
+        return ApiResponse(body=data)
+
+    @openmotics_api_v1(auth=True)
+    def sync(self):
+        screens = self._screen_controller.load_screens()
+        data = [ScreenApiSerializer.serialize(screen) for screen in screens]
+        return ApiResponse(body=data)
+
+    @openmotics_api_v1(auth=True, check={'screen_id': int})
+    def retrieve(self, screen_id):
+        screen = self._screen_controller.load_screen(screen_id=screen_id)
+        return ApiResponse(body=ScreenApiSerializer.serialize(screen))
+
+    @openmotics_api_v1(auth=True, check={'screen_id': int})
+    def open(self, screen_id):
+        self._screen_controller.screen_open(screen_id=screen_id)
+        return ApiResponse()
+
+    @openmotics_api_v1(auth=True, check={'screen_id': int})
+    def close(self, screen_id):
+        self._screen_controller.screen_close(screen_id=screen_id)
+        return ApiResponse()
+
+    @openmotics_api_v1(auth=True, check={'screen_id': int})
+    def stop(self, screen_id):
+        self._screen_controller.screen_stop(screen_id=screen_id)
+        return ApiResponse()
+
+    @openmotics_api_v1(auth=True, check={'screen_id': int, 'translational_position': int, 'rotational_position': int})
+    def goto_position(self, screen_id, translational_position=None, rotational_position=None):
+        self._screen_controller.screen_goto_position(screen_id=screen_id,
+                                                     translational_position=translational_position,
+                                                     rotational_position=rotational_position)
+        return ApiResponse()
diff --git a/src/gateway/api/V1/sensors.py b/src/gateway/api/V1/sensors.py
index 84f8e68d..d5cb37fc 100644
--- a/src/gateway/api/V1/sensors.py
+++ b/src/gateway/api/V1/sensors.py
@@ -22,11 +22,10 @@ import uuid
 
 import cherrypy
 
-from gateway.api.V1.schema import SCHEMA
 from gateway.api.V1.serializers.sensor import SensorApiSerializer
 from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, \
     openmotics_api_v1
-from gateway.dto.sensor import SensorDTO, SensorSourceDTO
+from gateway.dto import SensorDTO, SourceDTO
 from gateway.exceptions import ItemDoesNotExistException
 from gateway.models import Database, Ventilation
 from gateway.sensor_controller import SensorController
@@ -65,61 +64,3 @@ class Sensors(RestAPIEndpoint):
         sensors = self.sensor_controller.load_sensors()
         data = [SensorApiSerializer.serialize(sensor) for sensor in sensors]
         return ApiResponse(body=data)
-
-
-@expose
-class PluginSensor(RestAPIEndpoint):
-    API_ENDPOINT = '/plugin/sensor'
-
-    @Inject
-    def __init__(self, sensor_controller=INJECTED):
-        # type: (SensorController) -> None
-        super(PluginSensor, self).__init__()
-        self.sensor_controller = sensor_controller
-        self.route_dispatcher = cherrypy.dispatch.RoutesDispatcher()
-        self.route_dispatcher.connect('register', '/register',
-                                      controller=self, action='register',
-                                      conditions={'method': ['POST', 'OPTIONS']})
-
-    @openmotics_api_v1(auth=True, expect_body_type='JSON')
-    def register(self, request_body):
-        """
-        {"source": "plugin", "plugin": "DummyPlugin", "external_id": "AAAAAA", "physical_quantity": "temperature", "config": {}}
-        """
-        schema = {
-            "type": "object",
-            "required": ["source"],
-            "properties": {
-                "source": {
-                    "enum": ["plugin"]
-                }
-            },
-            "dependencies": {
-                "source": {
-                    "oneOf": [
-                        {
-                            "required": ["source", "plugin", "external_id", "physical_quantity"],
-                            "properties": {
-                                "source": {"const": "plugin"},
-                                "plugin": {"type": "string"},
-                                "external_id": {"type": "string"},
-                                "physical_quantity": {"type": "string"},
-                                "config": {"type": "object"}
-                            }
-                        }
-                    ]
-                }
-            }
-        }
-        # validate(request_body, schema)
-        try:
-            source = SensorSourceDTO(request_body['source'])
-            if source.type == 'plugin':
-                source.name = request_body['plugin']
-            external_id, physical_quantity, unit = request_body['external_id'], request_body['physical_quantity'], request_body['unit']
-            config = request_body.get('config', {})
-            sensor = self.sensor_controller.register_sensor(source, external_id, physical_quantity, unit, config)
-            return ApiResponse(body=SensorApiSerializer.serialize(sensor))
-        except Exception:
-            logger.error('Failed to register %s', request_body)
-            raise
diff --git a/src/gateway/api/V1/serializers/screen.py b/src/gateway/api/V1/serializers/screen.py
new file mode 100644
index 00000000..cc8a0b4e
--- /dev/null
+++ b/src/gateway/api/V1/serializers/screen.py
@@ -0,0 +1,18 @@
+from __future__ import absolute_import
+
+from gateway.dto import ScreenDTO
+
+if False:  # MYPY
+    from typing import Any, Dict
+
+
+class ScreenApiSerializer(object):
+    @staticmethod
+    def serialize(screen_dto):
+        # type: (ScreenDTO) -> Dict[str,Any]
+        # There's no need to include `external_id` or other internal source-related fields.
+        data = {'id': screen_dto.id,
+                'name': screen_dto.name,
+                'translational_steps': screen_dto.translational_steps,
+                'rotational_steps': screen_dto.rotational_steps}
+        return data
diff --git a/src/gateway/api/V1/serializers/ventilation.py b/src/gateway/api/V1/serializers/ventilation.py
index 5e1c44ec..e9816b74 100644
--- a/src/gateway/api/V1/serializers/ventilation.py
+++ b/src/gateway/api/V1/serializers/ventilation.py
@@ -1,6 +1,6 @@
 from __future__ import absolute_import
 
-from gateway.dto.ventilation import VentilationDTO, VentilationSourceDTO
+from gateway.dto.ventilation import VentilationDTO
 
 if False:  # MYPY
     from typing import Any, Dict
@@ -27,8 +27,9 @@ class VentilationConfigSerializer(object):
                 'name': ventilation_dto.name,
                 'room': ventilation_dto.room,
                 'amount_of_levels': ventilation_dto.amount_of_levels,
-                'source': ventilation_dto.source.type if ventilation_dto.source else None}
-        if ventilation_dto.source and ventilation_dto.source.type == 'plugin':
+                'source': ventilation_dto.source.source if ventilation_dto.source else None}
+        if ventilation_dto.plugin and ventilation_dto.source.is_plugin:
+            data['plugin'] = ventilation_dto.plugin.name
             data['external_id'] = ventilation_dto.external_id
         if ventilation_dto.device_vendor:
             data['device'] = {'vendor': ventilation_dto.device_vendor,
diff --git a/src/gateway/api/V1/shutters.py b/src/gateway/api/V1/shutters.py
new file mode 100644
index 00000000..885875c8
--- /dev/null
+++ b/src/gateway/api/V1/shutters.py
@@ -0,0 +1,58 @@
+# Copyright (C) 2021 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Shutters api description
+"""
+from __future__ import absolute_import
+
+import logging
+import cherrypy
+
+# from gateway.api.V1.serializers.shutter import ShutterApiSerializer
+from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, openmotics_api_v1
+from gateway.shutter_controller import ShutterController
+from ioc import INJECTED, Inject
+
+logger = logging.getLogger(__name__)
+
+
+@expose
+class Shutters(RestAPIEndpoint):
+    API_ENDPOINT = '/api/shutters'
+
+    @Inject
+    def __init__(self, shutter_controller=INJECTED):
+        # type: (ShutterController) -> None
+        super(Shutters, self).__init__()
+        self.shutter_controller = shutter_controller
+        self.route_dispatcher = cherrypy.dispatch.RoutesDispatcher()
+        self.route_dispatcher.connect('list', '',
+                                      controller=self, action='list',
+                                      conditions={'method': ['GET']})
+        self.route_dispatcher.connect('sync', '/sync',
+                                      controller=self, action='sync',
+                                      conditions={'method': ['GET']})
+
+    @openmotics_api_v1(auth=True)
+    def list(self):
+        shutters = self.shutter_controller.load_shutters()
+        # data = [ShutterApiSerializer.serialize(shutter) for shutter in shutters]
+        return ApiResponse(body=[])
+
+    @openmotics_api_v1(auth=True)
+    def sync(self):
+        shutters = self.shutter_controller.load_shutters()
+        # data = [ShutterApiSerializer.serialize(shutter) for shutter in shutters]
+        return ApiResponse(body=[])
diff --git a/src/gateway/api/V1/ventilation_units.py b/src/gateway/api/V1/ventilation_units.py
index 60f15e9f..0a28df26 100644
--- a/src/gateway/api/V1/ventilation_units.py
+++ b/src/gateway/api/V1/ventilation_units.py
@@ -18,27 +18,18 @@ Users api description
 from __future__ import absolute_import
 
 import logging
-import uuid
-
 import cherrypy
 
-from gateway.api.V1.schema import SCHEMA
+from gateway.api.V1.schemas import VENTILATION_UNIT_SCHEMA
 from gateway.api.V1.serializers.ventilation import VentilationConfigSerializer, \
     VentilationApiSerializer
 from gateway.api.V1.webservice import ApiResponse, RestAPIEndpoint, expose, \
     openmotics_api_v1
-from gateway.dto.ventilation import VentilationDTO, VentilationSourceDTO
-from gateway.exceptions import ItemDoesNotExistException
-from gateway.models import Database, Ventilation
 from gateway.ventilation_controller import VentilationController
 from ioc import INJECTED, Inject
 
 logger = logging.getLogger(__name__)
 
-if False:  # MyPy
-    from typing import Dict, List, Any
-    from gateway.dto import UserDTO
-    from gateway.authentication_controller import AuthenticationToken
 
 @expose
 class VentilationUnits(RestAPIEndpoint):
@@ -77,7 +68,7 @@ class VentilationUnits(RestAPIEndpoint):
     @openmotics_api_v1(auth=True, expect_body_type='JSON', check={'ventilation_id': int})
     def update(self, ventilation_id, request_body):
         request_body.update({'id': ventilation_id})
-        # validate(request_body, SCHEMA['ventilation_unit'])
+        # validate(request_body, VENTILATION_UNIT_SCHEMA)
         unit = VentilationConfigSerializer.deserialize(request_body)
         unit = self.ventilation_controller.save_ventilation(unit)
         return ApiResponse(body=VentilationConfigSerializer.serialize(unit))
@@ -87,60 +78,3 @@ class VentilationUnits(RestAPIEndpoint):
         units = self.ventilation_controller.load_ventilations()
         data = [VentilationApiSerializer.serialize(unit) for unit in units]
         return ApiResponse(body=data)
-
-
-@expose
-class PluginVentilation(RestAPIEndpoint):
-    API_ENDPOINT = '/plugin/ventilation'
-
-    @Inject
-    def __init__(self, ventilation_controller=INJECTED):
-        # type: (VentilationController) -> None
-        super(PluginVentilation, self).__init__()
-        self.ventilation_controller = ventilation_controller
-        self.route_dispatcher = cherrypy.dispatch.RoutesDispatcher()
-        self.route_dispatcher.connect('register', '/register',
-                                      controller=self, action='register',
-                                      conditions={'method': ['POST', 'OPTIONS']})
-
-    @openmotics_api_v1(auth=True, expect_body_type='JSON')
-    def register(self, request_body):
-        """
-        {"source": "plugin", "plugin": "DummyPlugin", "external_id": "AAAAAA", "config": {}}
-        """
-        schema = {
-            "type": "object",
-            "required": ["source"],
-            "properties": {
-                "source": {
-                    "enum": ["plugin"]
-                }
-            },
-            "dependencies": {
-                "source": {
-                    "oneOf": [
-                        {
-                            "required": ["source", "plugin", "external_id"],
-                            "properties": {
-                                "source": {"const": "plugin"},
-                                "plugin": {"type": "string"},
-                                "external_id": {"type": "string"},
-                                "config": {"type": "object"}
-                            }
-                        }
-                    ]
-                }
-            }
-        }
-        # validate(request_body, schema)
-        try:
-            source = VentilationSourceDTO(request_body['source'])
-            if source.type == 'plugin':
-                source.name = request_body['plugin']
-            external_id = request_body['external_id']
-            config = request_body.get('config', {})
-            unit = self.ventilation_controller.register_ventilation(source, external_id, config)
-            return ApiResponse(body=VentilationApiSerializer.serialize(unit))
-        except Exception:
-            logger.error('Failed to register %s', request_body)
-            raise
diff --git a/src/gateway/api/serializers/__init__.py b/src/gateway/api/serializers/__init__.py
index 8b4eb8ec..d7b5f711 100644
--- a/src/gateway/api/serializers/__init__.py
+++ b/src/gateway/api/serializers/__init__.py
@@ -22,17 +22,14 @@ from gateway.api.serializers.output import DimmerConfigurationSerializer, \
     OutputSerializer, OutputStateSerializer
 from gateway.api.serializers.pulse_counter import PulseCounterSerializer
 from gateway.api.serializers.room import RoomSerializer
-from gateway.api.serializers.rtd10 import GlobalRTD10Serializer, \
-    RTD10Serializer
 from gateway.api.serializers.schedule import ScheduleSerializer
 from gateway.api.serializers.sensor import SensorSerializer, \
     SensorStatusSerializer
 from gateway.api.serializers.shutter import ShutterSerializer
 from gateway.api.serializers.shutter_group import ShutterGroupSerializer
 from gateway.api.serializers.thermostat import LegacyThermostatGroupStatusSerializer, \
-    PumpGroupSerializer, ThermostatAircoStatusSerializer, \
-    ThermostatGroupSerializer, ThermostatGroupStatusSerializer, \
-    ThermostatSerializer
+    PumpGroupSerializer, ThermostatGroupSerializer, \
+    ThermostatGroupStatusSerializer, ThermostatSerializer
 from gateway.api.serializers.user import UserSerializer
 from gateway.api.serializers.ventilation import VentilationSerializer, \
     VentilationStatusSerializer
diff --git a/src/gateway/api/serializers/rtd10.py b/src/gateway/api/serializers/rtd10.py
deleted file mode 100644
index 3c646069..00000000
--- a/src/gateway/api/serializers/rtd10.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# Copyright (C) 2020 OpenMotics BV
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Affero General Public License as
-# published by the Free Software Foundation, either version 3 of the
-# License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Affero General Public License for more details.
-#
-# You should have received a copy of the GNU Affero General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-"""
-RTD10 (de)serializer
-"""
-from toolbox import Toolbox
-from gateway.api.serializers.base import SerializerToolbox
-from gateway.dto import GlobalRTD10DTO, RTD10DTO
-
-if False:  # MYPY
-    from typing import Dict, Optional, List, Tuple, Any
-
-
-class GlobalRTD10Serializer(object):
-    BYTE_MAX = 255
-
-    @staticmethod
-    def _temp_to_str(temp):
-        return str(temp).replace('.', '_').replace('_0', '')
-
-    @staticmethod
-    def serialize(global_rtd10_dto, fields):  # type: (GlobalRTD10DTO, Optional[List[str]]) -> Dict[str, Any]
-        data = {}
-        for temperature in GlobalRTD10DTO.TEMPERATURES:
-            formatted_temp = GlobalRTD10Serializer._temp_to_str(temperature)
-            data['output_value_heating_{0}'.format(formatted_temp)] = global_rtd10_dto.heating_values.get(temperature, GlobalRTD10Serializer.BYTE_MAX)
-            data['output_value_cooling_{0}'.format(formatted_temp)] = global_rtd10_dto.cooling_values.get(temperature, GlobalRTD10Serializer.BYTE_MAX)
-        return SerializerToolbox.filter_fields(data, fields)
-
-    @staticmethod
-    def deserialize(api_data):  # type: (Dict) -> GlobalRTD10DTO
-        heating_values = {}
-        cooling_values = {}
-        for temperature in GlobalRTD10DTO.TEMPERATURES:
-            field = 'output_value_heating_{0}'.format(GlobalRTD10Serializer._temp_to_str(temperature))
-            heating_values[temperature] = api_data[field]
-            field = 'output_value_cooling_{0}'.format(GlobalRTD10Serializer._temp_to_str(temperature))
-            cooling_values[temperature] = api_data[field]
-        pump_group_dto = GlobalRTD10DTO(heating_values=heating_values,
-                                        cooling_values=cooling_values)
-        return pump_group_dto
-
-
-class RTD10Serializer(object):
-    BYTE_MAX = 255
-
-    @staticmethod
-    def serialize(rtd10_dto, fields):  # type: (RTD10DTO, Optional[List[str]]) -> Dict
-        data = {'id': rtd10_dto.id}
-        for field in ['temp_setpoint_output', 'ventilation_speed_output', 'ventilation_speed_value',
-                      'mode_output', 'mode_value', 'on_off_output', 'poke_angle_output',
-                      'poke_angle_value', 'room']:
-            data[field] = Toolbox.denonify(getattr(rtd10_dto, field), RTD10Serializer.BYTE_MAX)
-        return SerializerToolbox.filter_fields(data, fields)
-
-    @staticmethod
-    def deserialize(api_data):  # type: (Dict) -> RTD10DTO
-        shutter_dto = RTD10DTO(api_data['id'])
-        SerializerToolbox.deserialize(
-            dto=shutter_dto,  # Referenced
-            api_data=api_data,
-            mapping={field: (field, RTD10Serializer.BYTE_MAX)
-                     for field in ['temp_setpoint_output', 'ventilation_speed_output', 'ventilation_speed_value',
-                                   'mode_output', 'mode_value', 'on_off_output', 'poke_angle_output',
-                                   'poke_angle_value', 'room']}
-        )
-        return shutter_dto
diff --git a/src/gateway/api/serializers/sensor.py b/src/gateway/api/serializers/sensor.py
index f743efa8..e365c409 100644
--- a/src/gateway/api/serializers/sensor.py
+++ b/src/gateway/api/serializers/sensor.py
@@ -19,45 +19,23 @@ Sensor (de)serializer
 from __future__ import absolute_import
 
 from gateway.api.serializers.base import SerializerToolbox
-from gateway.dto import SensorDTO, SensorSourceDTO, SensorStatusDTO
-from gateway.models import Sensor
+from gateway.api.serializers.source import SourceSerializer
+from gateway.dto import SensorDTO, SensorStateDTO
+from gateway.enums import SensorEnums
 from toolbox import Toolbox
 
 if False:  # MYPY
-    from typing import Any, Dict, List, Optional, Tuple
+    from typing import Any, Dict, List, Optional
 
 
 class SensorSerializer(object):
     BYTE_MAX = 255
 
-    PHYSICAL_QUANTITIES = [
-        Sensor.PhysicalQuantities.TEMPERATURE,
-        Sensor.PhysicalQuantities.HUMIDITY,
-        Sensor.PhysicalQuantities.BRIGHTNESS,
-        Sensor.PhysicalQuantities.SOUND,
-        Sensor.PhysicalQuantities.DUST,
-        Sensor.PhysicalQuantities.COMFORT_INDEX,
-        Sensor.PhysicalQuantities.AQI,
-        Sensor.PhysicalQuantities.CO2,
-        Sensor.PhysicalQuantities.VOC,
-    ]
-
-    UNITS = [
-        Sensor.Units.NONE,
-        Sensor.Units.CELCIUS,
-        Sensor.Units.PERCENT,
-        Sensor.Units.DECIBEL,
-        Sensor.Units.LUX,
-        Sensor.Units.MICRO_GRAM_PER_CUBIC_METER,
-        Sensor.Units.PARTS_PER_MILLION,
-    ]
-
     @staticmethod
     def serialize(sensor_dto, fields):  # type: (SensorDTO, Optional[List[str]]) -> Dict
-        source = None
-        if sensor_dto.source:
-            source = {'type': sensor_dto.source.type,
-                      'name': sensor_dto.source.name}
+        source = None  # type: Optional[Dict[str, Any]]
+        if sensor_dto.source is not None:
+            source = SourceSerializer.serialize(sensor_dto.source, fields=None)
         data = {'id': sensor_dto.id,
                 'source': source,
                 'external_id': sensor_dto.external_id,
@@ -75,11 +53,9 @@ class SensorSerializer(object):
         sensor_id = None  # type: Optional[int]
         if 'id' in api_data:
             sensor_id = api_data['id']
-        sensor_dto = SensorDTO(sensor_id)
+        sensor_dto = SensorDTO(id=sensor_id)
         if 'source' in api_data:
-            source_name = api_data['source'].get('name') or None
-            sensor_dto.source = SensorSourceDTO(api_data['source']['type'],
-                                                name=source_name)
+            sensor_dto.source = SourceSerializer.deserialize(api_data=api_data['source'])
         SerializerToolbox.deserialize(
             dto=sensor_dto,  # Referenced
             api_data=api_data,
@@ -94,10 +70,10 @@ class SensorSerializer(object):
         )
         field = 'physical_quantity'
         if field in sensor_dto.loaded_fields:
-            SensorSerializer._validate_values(sensor_dto, field, SensorSerializer.PHYSICAL_QUANTITIES)
+            SensorSerializer._validate_values(sensor_dto, field, SensorEnums.ALL_PHYSICAL_QUANTITIES)
         field = 'unit'
         if field in sensor_dto.loaded_fields:
-            SensorSerializer._validate_values(sensor_dto, field, SensorSerializer.UNITS)
+            SensorSerializer._validate_values(sensor_dto, field, SensorEnums.ALL_UNITS)
         return sensor_dto
 
     @staticmethod
@@ -109,15 +85,15 @@ class SensorSerializer(object):
 
 class SensorStatusSerializer(object):
     @staticmethod
-    def serialize(status_dto, fields):  # type: (SensorStatusDTO, Optional[List[str]]) -> Dict
+    def serialize(status_dto, fields):  # type: (SensorStateDTO, Optional[List[str]]) -> Dict
         data = {'id': status_dto.id,
                 'value': status_dto.value}
         return SerializerToolbox.filter_fields(data, fields)
 
     @staticmethod
-    def deserialize(api_data):  # type: (Dict) -> SensorStatusDTO
+    def deserialize(api_data):  # type: (Dict) -> SensorStateDTO
         sensor_id = int(api_data['id'])
-        status_dto = SensorStatusDTO(sensor_id)
+        status_dto = SensorStateDTO(sensor_id)
         SerializerToolbox.deserialize(
             dto=status_dto,
             api_data=api_data,
diff --git a/src/gateway/api/serializers/source.py b/src/gateway/api/serializers/source.py
new file mode 100644
index 00000000..2f547281
--- /dev/null
+++ b/src/gateway/api/serializers/source.py
@@ -0,0 +1,56 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+"""
+Source (de)serializer
+"""
+from __future__ import absolute_import
+
+import logging
+
+from gateway.api.serializers.base import SerializerToolbox
+from gateway.dto import SourceDTO
+from gateway.enums import Source
+from gateway.models import Database, Plugin
+from toolbox import Toolbox
+
+if False:  # MYPY
+    from typing import Any, Dict, Optional, List
+
+logger = logging.getLogger(__name__)
+
+
+class SourceSerializer(object):
+    BYTE_MAX = 255
+
+    @staticmethod
+    def serialize(source_dto, fields):
+        # type: (SourceDTO, Optional[List[str]]) -> Dict[str,Any]
+        name = None
+        if source_dto.is_plugin:
+            with Database.get_session() as db:
+                name = db.query(Plugin).filter_by(id=source_dto.source_id).one().name
+        data = {'type': source_dto.source,
+                'name': name}
+        return SerializerToolbox.filter_fields(data, fields)
+
+    @staticmethod
+    def deserialize(api_data):  # type: (Dict[str,Any]) -> SourceDTO
+        source_id = None  # type: Optional[int]
+        if api_data['type'] == Source.PLUGIN:
+            with Database.get_session() as db:
+                source_id = db.query(Plugin).filter_by(name=api_data['name']).one().id
+        return SourceDTO(source=api_data['type'],
+                         source_id=source_id)
diff --git a/src/gateway/api/serializers/thermostat.py b/src/gateway/api/serializers/thermostat.py
index 8ea31713..8aad607a 100644
--- a/src/gateway/api/serializers/thermostat.py
+++ b/src/gateway/api/serializers/thermostat.py
@@ -16,11 +16,10 @@
 """
 Heating thermostat (de)serializer
 """
-from toolbox import Toolbox
 from gateway.api.serializers.base import SerializerToolbox
-from gateway.dto import ThermostatAircoStatusDTO, ThermostatDTO, \
-    ThermostatGroupDTO, ThermostatScheduleDTO, ThermostatGroupStatusDTO, \
-    PumpGroupDTO
+from gateway.dto import PumpGroupDTO, ThermostatDTO, ThermostatGroupDTO, \
+    ThermostatGroupStatusDTO, ThermostatScheduleDTO
+from toolbox import Toolbox
 
 if False:  # MYPY
     from typing import Dict, Optional, List, Tuple, Any
@@ -185,13 +184,6 @@ class ThermostatGroupStatusSerializer(object):
         return data
 
 
-class ThermostatAircoStatusSerializer(object):
-    @staticmethod
-    def serialize(thermostat_airco_status_dto):  # type: (ThermostatAircoStatusDTO) -> Dict[str, Any]
-        return {'ASB{0}'.format(i): 1 if thermostat_airco_status_dto.status[i] else 0
-                for i in range(32)}
-
-
 class PumpGroupSerializer(object):
     BYTE_MAX = 255
 
diff --git a/src/gateway/api/serializers/ventilation.py b/src/gateway/api/serializers/ventilation.py
index 8ab5178b..4f75cf71 100644
--- a/src/gateway/api/serializers/ventilation.py
+++ b/src/gateway/api/serializers/ventilation.py
@@ -21,12 +21,13 @@ from __future__ import absolute_import
 import logging
 
 from gateway.api.serializers.base import SerializerToolbox
-from gateway.dto import VentilationDTO, VentilationSourceDTO, \
-    VentilationStatusDTO
+from gateway.api.serializers.source import SourceSerializer
+from gateway.dto import VentilationDTO, \
+    VentilationStatusDTO, SourceDTO
 from toolbox import Toolbox
 
 if False:  # MYPY
-    from typing import Any, Dict, Optional, List, Tuple
+    from typing import Any, Dict, Optional, List
 
 logger = logging.getLogger(__name__)
 
@@ -39,8 +40,7 @@ class VentilationSerializer(object):
         # type: (VentilationDTO, Optional[List[str]]) -> Dict[str,Any]
         data = {'id': ventilation_dto.id,
                 'external_id': Toolbox.denonify(ventilation_dto.external_id, ''),
-                'source': {'type': ventilation_dto.source.type,
-                           'name': ventilation_dto.source.name},
+                'source': SourceSerializer.serialize(ventilation_dto.source, fields=None),
                 'name': Toolbox.denonify(ventilation_dto.name, ''),
                 'room': Toolbox.denonify(ventilation_dto.room, VentilationSerializer.BYTE_MAX),
                 'amount_of_levels': Toolbox.denonify(ventilation_dto.amount_of_levels, 0),
@@ -55,10 +55,9 @@ class VentilationSerializer(object):
         ventilation_id = None  # type: Optional[int]
         if 'id' in api_data:
             ventilation_id = api_data['id']
-        source_dto = None  # type: Optional[VentilationSourceDTO]
+        source_dto = None  # type: Optional[SourceDTO]
         if 'source' in api_data:
-            source_dto = VentilationSourceDTO(api_data['source']['type'],
-                                              name=api_data['source']['name'])
+            source_dto = SourceSerializer.deserialize(api_data=api_data['source'])
         ventilation_dto = VentilationDTO(id=ventilation_id, source=source_dto)
         if 'external_id' in api_data:
             ventilation_dto.external_id = Toolbox.nonify(api_data['external_id'], '')
@@ -86,7 +85,6 @@ class VentilationStatusSerializer(object):
                 'mode': status_dto.mode,
                 'level': status_dto.level,
                 'remaining_time': status_dto.remaining_time,
-                'timer': status_dto.timer,
                 'connected': status_dto.is_connected}
         return SerializerToolbox.filter_fields(data, fields)
 
@@ -96,8 +94,6 @@ class VentilationStatusSerializer(object):
                                           mode=api_data['mode'])
         if 'level' in api_data:
             status_dto.level = Toolbox.nonify(api_data['level'], 0)
-        if 'timer' in api_data:
-            status_dto.timer = Toolbox.nonify(api_data['timer'], 0)
         if 'remaining_time' in api_data:
             status_dto.remaining_time = Toolbox.nonify(api_data['remaining_time'], 0)
         return status_dto
diff --git a/src/gateway/daemon_thread.py b/src/gateway/daemon_thread.py
index 7c8318e4..974bbbe1 100644
--- a/src/gateway/daemon_thread.py
+++ b/src/gateway/daemon_thread.py
@@ -45,6 +45,7 @@ class DaemonThread(object):
         self._interval = interval
         self._delay = delay
         self._name = name
+        self._is_started = False
         self._target = target
         self._tick = threading.Event()
         self._stop = threading.Event()
@@ -55,6 +56,11 @@ class DaemonThread(object):
         # type: () -> None
         logger.info('Starting daemon {}'.format(self._name))
         self._thread.start()
+        self._is_started = True
+
+    @property
+    def is_started(self):
+        return self._is_started
 
     def stop(self):
         # type: () -> None
@@ -108,7 +114,7 @@ class DaemonThread(object):
         while not self._stop.is_set():
             start = time.time()
             if not self._parent.is_alive():
-                logger.info('Aborting daemon {}'.format(self._name))
+                logger.info('Aborting daemon {} because parent {}'.format(self._name, self._parent))
                 return
             try:
                 self._tick.clear()
diff --git a/src/gateway/dto/__init__.py b/src/gateway/dto/__init__.py
index 57496bf6..2efc85ee 100644
--- a/src/gateway/dto/__init__.py
+++ b/src/gateway/dto/__init__.py
@@ -15,7 +15,6 @@
 
 from gateway.dto.energy import EnergyModuleDTO, RealtimeEnergyDTO, \
     TotalEnergyDTO
-from gateway.dto.energy import RealtimeEnergyDTO, TotalEnergyDTO, EnergyModuleDTO
 from gateway.dto.feedback_led import FeedbackLedDTO
 from gateway.dto.global_feedback import GlobalFeedbackDTO
 from gateway.dto.group_action import GroupActionDTO
@@ -23,18 +22,23 @@ from gateway.dto.input import InputDTO, InputStatusDTO
 from gateway.dto.module import ModuleDTO
 from gateway.dto.output import DimmerConfigurationDTO, OutputDTO, \
     OutputStatusDTO
+from gateway.dto.plugin import PluginActionDTO, PluginDTO, PluginStatusEvent
 from gateway.dto.pulse_counter import PulseCounterDTO
 from gateway.dto.room import RoomDTO
-from gateway.dto.rtd10 import RTD10DTO, GlobalRTD10DTO
 from gateway.dto.schedule import ScheduleDTO, ScheduleSetpointDTO
-from gateway.dto.sensor import MasterSensorDTO, SensorDTO, SensorSourceDTO, \
-    SensorStatusDTO
+from gateway.dto.screen import PluginScreenDTO, ScreenDTO, ScreenStateDTO
+from gateway.dto.sensor import MasterSensorDTO, PluginSensorDTO, SensorDTO, \
+    SensorStateDTO
 from gateway.dto.shutter import ShutterDTO
 from gateway.dto.shutter_group import ShutterGroupDTO
-from gateway.dto.thermostat import PumpGroupDTO, ThermostatAircoStatusDTO, \
-    ThermostatDTO, ThermostatGroupDTO, ThermostatGroupStatusDTO, \
-    ThermostatStatusDTO
+from gateway.dto.source import SourceDTO
+from gateway.dto.thermostat import PumpGroupDTO, ThermostatDTO, \
+    ThermostatGroupDTO, ThermostatGroupStatusDTO, ThermostatStatusDTO
 from gateway.dto.thermostat_schedule import ThermostatScheduleDTO
 from gateway.dto.user import UserDTO
-from gateway.dto.ventilation import VentilationDTO, VentilationSourceDTO, \
+from gateway.dto.ventilation import PluginVentilationDTO, VentilationDTO, \
     VentilationStatusDTO
+
+PLUGIN_IPC_SERIALIZABLE = [PluginActionDTO, PluginStatusEvent,
+                           PluginScreenDTO, ScreenStateDTO,
+                           PluginVentilationDTO, PluginSensorDTO]
diff --git a/src/gateway/dto/hvac_driver.py b/src/gateway/dto/hvac_driver.py
new file mode 100644
index 00000000..be15a484
--- /dev/null
+++ b/src/gateway/dto/hvac_driver.py
@@ -0,0 +1,11 @@
+from gateway.dto.base import BaseDTO
+
+if False:  # MYPY
+    from typing import Any, Optional
+
+
+class HvacContactDTO(BaseDTO):
+    def __init__(self, output_id, mode, value):
+        self.output_id = output_id  # type: int
+        self.mode = mode  # type: str
+        self.value = value  # type: int
\ No newline at end of file
diff --git a/src/gateway/dto/plugin.py b/src/gateway/dto/plugin.py
new file mode 100644
index 00000000..b6e2b90b
--- /dev/null
+++ b/src/gateway/dto/plugin.py
@@ -0,0 +1,71 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+"""
+Plugin DTO
+"""
+from gateway.dto.base import BaseDTO
+
+if False:  # MYPY
+    from typing import Optional, List, Any
+
+
+class PluginDTO(BaseDTO):
+    def __init__(self, id, name, version=None, interfaces=None, status=None):
+        self.id = id  # type: int
+        self.name = name  # type: str
+        self.version = version  # type: str
+        self.interfaces = interfaces  # List[Any]
+        self.status = status  # type: str
+
+
+class PluginActionDTO(BaseDTO):
+    def __init__(self, action, payload=None, action_version=None):
+        # type: (str, Any, Optional[int]) -> None
+        self.action = action
+        self.payload = payload
+        self.action_version = action_version
+
+    def __str__(self):
+        return str(self.serialize())
+
+    def serialize(self):
+        return {'action': self.action,
+                'payload': self.payload,
+                'action_version': self.action_version}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(action=data['action'],
+                   payload=data['payload'],
+                   action_version=data['action_version'])
+
+
+class PluginStatusEvent(BaseDTO):
+    def __init__(self, type, data):
+        self.type = type
+        self.data = data
+
+    def __str__(self):
+        return str(self.serialize())
+
+    def serialize(self):
+        return {'type': self.type,
+                'data': self.data}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(type=data['type'],
+                   data=data['data'])
diff --git a/src/gateway/dto/rtd10.py b/src/gateway/dto/rtd10.py
deleted file mode 100644
index fc1e520a..00000000
--- a/src/gateway/dto/rtd10.py
+++ /dev/null
@@ -1,60 +0,0 @@
-# Copyright (C) 2020 OpenMotics BV
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Affero General Public License as
-# published by the Free Software Foundation, either version 3 of the
-# License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Affero General Public License for more details.
-#
-# You should have received a copy of the GNU Affero General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-"""
-RTD10 related DTO
-"""
-
-from collections import defaultdict
-from gateway.dto.base import BaseDTO
-
-if False:
-    from typing import Dict, Optional
-
-
-class GlobalRTD10DTO(BaseDTO):
-    TEMPERATURES = [16.0, 16.5, 17.0, 17.5, 18.0, 18.5, 19.0, 19.5, 20.0, 20.5,
-                    21.0, 21.5, 22.0, 22.5, 23.0, 23.5, 24.0]
-
-    def __init__(self, heating_values=None, cooling_values=None):
-        # type: (Optional[Dict[float, int]], Optional[Dict[float, int]]) -> None
-        self.heating_values = defaultdict(lambda: 0)  # type: Dict[float, int]
-        self.cooling_values = defaultdict(lambda: 0)  # type: Dict[float, int]
-        if heating_values is not None:
-            self.heating_values.update({i: heating_values[i]
-                                        for i in GlobalRTD10DTO.TEMPERATURES
-                                        if i in heating_values})
-        if cooling_values is not None:
-            self.cooling_values.update({i: cooling_values[i]
-                                        for i in GlobalRTD10DTO.TEMPERATURES
-                                        if i in cooling_values})
-
-
-class RTD10DTO(BaseDTO):
-    def __init__(self, id, temp_setpoint_output=None,
-                 ventilation_speed_output=None, ventilation_speed_value=None,
-                 mode_output=None, mode_value=None,
-                 on_off_output=None, poke_angle_output=None, poke_angle_value=None, room=None):
-        # type: (int, Optional[int], Optional[int], Optional[int], Optional[int], Optional[int], Optional[int], Optional[int], Optional[int], Optional[int]) -> None
-        self.id = id
-        self.temp_setpoint_output = temp_setpoint_output
-        self.ventilation_speed_output = ventilation_speed_output
-        self.ventilation_speed_value = ventilation_speed_value
-        self.mode_output = mode_output
-        self.mode_value = mode_value
-        self.on_off_output = on_off_output
-        self.poke_angle_output = poke_angle_output
-        self.poke_angle_value = poke_angle_value
-        self.room = room
diff --git a/src/gateway/dto/screen.py b/src/gateway/dto/screen.py
new file mode 100644
index 00000000..637b6cb0
--- /dev/null
+++ b/src/gateway/dto/screen.py
@@ -0,0 +1,84 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+"""
+Screen DTOs
+"""
+from gateway.dto.base import BaseDTO
+from gateway.enums import ScreenEnums
+
+if False:  # MYPY
+    from typing import Optional
+    from gateway.dto import RoomDTO
+
+
+class ScreenDTO(BaseDTO):
+    def __init__(self, id, external_id, name, type, room=None, translational_steps=None, rotational_steps=None):
+        self.id = id  # type: int
+        self.external_id = external_id  # type: str
+        self.name = name  # type: str
+        self.type = type  # type: str
+        self.room = room  # type: Optional[RoomDTO]
+        self.translational_steps = translational_steps  # type: Optional[int]
+        self.rotational_steps = rotational_steps  # type: Optional[int]
+
+
+class PluginScreenDTO(BaseDTO):
+    def __init__(self, name, type, id=None, external_id=None, translational_steps=None, rotational_steps=None):
+        self.name = name  # type: str
+        self.type = type  # type: str
+        self.id = id  # type: Optional[int]
+        self.external_id = external_id  # type: Optional[str]
+        self.translational_steps = translational_steps  # type: Optional[int]
+        self.rotational_steps = rotational_steps  # type: Optional[int]
+
+    def __str__(self):
+        return str(self.serialize())
+
+    def serialize(self):
+        return {'id': self.id,
+                'external_id': self.external_id,
+                'name': self.name,
+                'type': self.type,
+                'translational_steps': self.translational_steps,
+                'rotational_steps': self.rotational_steps}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(id=data['id'],
+                   external_id=data['external_id'],
+                   name=data['name'],
+                   type=data['type'],
+                   translational_steps=data['translational_steps'],
+                   rotational_steps=data['rotational_steps'])
+
+
+class ScreenStateDTO(BaseDTO):
+    def __init__(self, position=None, state=None):
+        # type: (Optional[int], Optional[str]) -> None
+        self.position = position
+        self.state = state
+
+    def __str__(self):
+        return str(self.serialize())
+
+    def serialize(self):
+        return {'position': self.position,
+                'state': self.state}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(position=data['position'],
+                   state=data['state'])
diff --git a/src/gateway/dto/sensor.py b/src/gateway/dto/sensor.py
index c68e9930..59bac41f 100644
--- a/src/gateway/dto/sensor.py
+++ b/src/gateway/dto/sensor.py
@@ -17,7 +17,8 @@
 Sensor DTO
 """
 from gateway.dto.base import BaseDTO
-from gateway.models import Sensor
+from gateway.dto.source import SourceDTO
+from gateway.enums import Source
 
 if False:  # MYPY
     from typing import Any, Optional
@@ -27,7 +28,7 @@ class SensorDTO(BaseDTO):
     def __init__(self, id, external_id=None, source=None, physical_quantity=None, unit=None, name='', room=None, offset=None, virtual=False, in_use=True):
         self.id = id  # type: int
         self.external_id = external_id  # type: str
-        self.source = source  # type: SensorSourceDTO
+        self.source = source  # type: SourceDTO
         self.physical_quantity = physical_quantity  # type: Optional[str]
         self.unit = unit  # type: Optional[str]
         self.name = name  # type: str
@@ -37,22 +38,7 @@ class SensorDTO(BaseDTO):
         self.virtual = virtual  # type: bool
 
 
-class SensorSourceDTO(BaseDTO):
-    def __init__(self, type, name=None):
-        # type: (str, str) -> None
-        self.type = type
-        self.name = name
-
-    @property
-    def is_master(self):
-        return self.type == Sensor.Sources.MASTER
-
-    @property
-    def is_plugin(self):
-        return self.type == Sensor.Sources.PLUGIN
-
-
-class SensorStatusDTO(BaseDTO):
+class SensorStateDTO(BaseDTO):
     def __init__(self, id, value=None):
         # type: (int, Optional[float]) -> None
         self.id = id
@@ -60,12 +46,33 @@ class SensorStatusDTO(BaseDTO):
 
     def __eq__(self, other):
         # type: (Any) -> bool
-        if not isinstance(other, SensorStatusDTO):
+        if not isinstance(other, SensorStateDTO):
             return False
         return (self.id == other.id and
                 self.value == other.value)
 
 
+class PluginSensorDTO(BaseDTO):
+    def __init__(self, external_id=None, physical_quantity=None, unit=None, name=''):
+        self.external_id = external_id  # type: str
+        self.physical_quantity = physical_quantity  # type: Optional[str]
+        self.unit = unit  # type: Optional[str]
+        self.name = name  # type: str
+
+    def serialize(self):
+        return {'external_id': self.external_id,
+                'physical_quantity': self.physical_quantity,
+                'unit': self.unit,
+                'name': self.name}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(external_id=data['external_id'],
+                   physical_quantity=data['physical_quantity'],
+                   unit=data['unit'],
+                   name=data['name'])
+
+
 class MasterSensorDTO(BaseDTO):
     def __init__(self, id, name='', offset=None, virtual=False):
         self.id = id  # type: int
diff --git a/src/gateway/dto/source.py b/src/gateway/dto/source.py
new file mode 100644
index 00000000..eda7146d
--- /dev/null
+++ b/src/gateway/dto/source.py
@@ -0,0 +1,50 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+"""
+Source DTO
+"""
+from gateway.dto.base import BaseDTO
+from gateway.enums import Source
+
+if False:  # MYPY
+    from typing import Optional
+
+
+class SourceDTO(BaseDTO):
+
+    def __init__(self, source, source_id=None):
+        self.source = source  # type: str
+        self.source_id = source_id  # type: Optional[int]
+
+    @property
+    def is_plugin(self):
+        return self.source == Source.PLUGIN
+
+    @property
+    def is_master(self):
+        return self.source == Source.MASTER
+
+    def __eq__(self, other):
+        if not isinstance(other, SourceDTO):
+            return False
+        return (self.source == other.source and
+                self.source_id == other.source_id)
+
+    def __hash__(self):
+        return hash('{0}.{1}'.format(self.source, self.source_id))
+
+    def __str__(self):
+        return "Source('{0}.{1}')".format(self.source.lower(), self.source_id)
diff --git a/src/gateway/dto/thermostat.py b/src/gateway/dto/thermostat.py
index 8bec5c16..2341bc80 100644
--- a/src/gateway/dto/thermostat.py
+++ b/src/gateway/dto/thermostat.py
@@ -114,12 +114,6 @@ class ThermostatGroupStatusDTO(BaseDTO):
         self.statusses = statusses if statusses is not None else []  # type: List[ThermostatStatusDTO]
 
 
-class ThermostatAircoStatusDTO(BaseDTO):
-    def __init__(self, status):
-        # type: (Dict[int, bool]) -> None
-        self.status = status
-
-
 class PumpGroupDTO(BaseDTO):
     def __init__(self, id, pump_output_id=None, valve_output_ids=None, room_id=None):
         # type: (int, Optional[int], Optional[List[int]], Optional[int]) -> None
diff --git a/src/gateway/dto/ventilation.py b/src/gateway/dto/ventilation.py
index d501014b..3ccca7fd 100644
--- a/src/gateway/dto/ventilation.py
+++ b/src/gateway/dto/ventilation.py
@@ -18,16 +18,19 @@ Output DTO
 """
 import time
 from gateway.dto.base import BaseDTO
+from gateway.dto.source import SourceDTO
+from gateway.dto.plugin import PluginDTO
 
 if False:  # MYPY
     from typing import Any, Optional
 
 
 class VentilationDTO(BaseDTO):
-    def __init__(self, id, source=None, external_id='', name='', room=None, amount_of_levels=0,
+    def __init__(self, id, source=None, plugin=None, external_id='', name='', room=None, amount_of_levels=0,
                  device_vendor='', device_type='', device_serial=''):
         self.id = id  # type: int
-        self.source = source  # type: VentilationSourceDTO
+        self.source = source  # type: SourceDTO
+        self.plugin = plugin  # type: Optional[PluginDTO]
         self.external_id = external_id  # type: str
         self.name = name  # type: str
         self.room = room  # type: Optional[int]
@@ -37,32 +40,51 @@ class VentilationDTO(BaseDTO):
         self.device_serial = device_serial  # type: str
 
 
-class VentilationSourceDTO(BaseDTO):
-    class Type(object):
-        PLUGIN = 'plugin'
-
-    def __init__(self, type, id=None, name=''):
-        self.type = type  # type: str
-        self.id = id  # type: int
+class PluginVentilationDTO(BaseDTO):
+    def __init__(self, name, amount_of_levels, device_type, device_vendor, device_serial, id=None, external_id=None):
         self.name = name  # type: str
+        self.amount_of_levels = amount_of_levels  # type: int
+        self.device_type = device_type  # type: str
+        self.device_serial = device_serial  # type: str
+        self.device_vendor = device_vendor  # type: str
+        self.id = id  # type: Optional[int]
+        self.external_id = external_id  # type: Optional[str]
 
-    @property
-    def is_plugin(self):
-        return self.type == VentilationSourceDTO.Type.PLUGIN
+    def __str__(self):
+        return str(self.serialize())
+
+    def serialize(self):
+        return {'id': self.id,
+                'external_id': self.external_id,
+                'name': self.name,
+                'amount_of_levels': self.amount_of_levels,
+                'device_type': self.device_type,
+                'device_serial': self.device_serial,
+                'device_vendor': self.device_vendor}
+
+    @classmethod
+    def deserialize(cls, data):
+        return cls(id=data['id'],
+                   external_id=data['external_id'],
+                   name=data['name'],
+                   amount_of_levels=data['amount_of_levels'],
+                   device_type=data['device_type'],
+                   device_serial=data['device_serial'],
+                   device_vendor=data['device_vendor'])
 
 
 class VentilationStatusDTO(BaseDTO):
     STATUS_TIMEOUT = 300  # Seconds until the last status is invalid
+
     class Mode(object):
         AUTO = 'auto'
         MANUAL = 'manual'
 
-    def __init__(self, id, mode, level=None, timer=None, remaining_time=None, last_seen=None):
-        # type: (int, Optional[str], Optional[int], Optional[float], Optional[float], Optional[float]) -> None
+    def __init__(self, id, mode, level=None, remaining_time=None, last_seen=None):
+        # type: (int, Optional[str], Optional[int], Optional[float], Optional[float]) -> None
         self.id = id
         self.mode = mode
         self.level = level
-        self.timer = timer
         self.remaining_time = remaining_time
         self.last_seen = last_seen or time.time()
 
@@ -75,8 +97,6 @@ class VentilationStatusDTO(BaseDTO):
         # type: (Any) -> bool
         if not isinstance(other, VentilationStatusDTO):
             return False
-        if self.timer:  # is write only
-            return False
         return (self.id == other.id and
                 self.mode == other.mode and
                 self.level == other.level and
diff --git a/src/gateway/energy/energy_command.py b/src/gateway/energy/energy_command.py
index 92eff84f..9c82ba9a 100644
--- a/src/gateway/energy/energy_command.py
+++ b/src/gateway/energy/energy_command.py
@@ -169,8 +169,6 @@ class EnergyCommand(object):
         Parse the output using the output_format.
         :param data: string containing the data.
         """
-        if sys.version_info[:3] <= (2, 7, 3):
-            data = str(data)
         if self.output_format is None:
             return struct.unpack('%dB' % len(data), data)
         else:
diff --git a/src/gateway/energy/energy_communicator.py b/src/gateway/energy/energy_communicator.py
index 33327d61..0584ba0f 100644
--- a/src/gateway/energy/energy_communicator.py
+++ b/src/gateway/energy/energy_communicator.py
@@ -165,7 +165,7 @@ class EnergyCommunicator(object):
         self.__communication_stats_bytes['bytes_written'] += len(data)
         threshold = time.time() - self.__debug_buffer_duration
         self.__debug_buffer['write'][time.time()] = str(Printable(data))
-        for t in self.__debug_buffer['write'].keys():
+        for t in list(self.__debug_buffer['write'].keys()):
             if t < threshold:
                 del self.__debug_buffer['write'][t]
 
@@ -464,7 +464,7 @@ class EnergyCommunicator(object):
 
         threshold = time.time() - self.__debug_buffer_duration
         self.__debug_buffer['read'][time.time()] = str(Printable(command))
-        for t in self.__debug_buffer['read'].keys():
+        for t in list(self.__debug_buffer['read'].keys()):
             if t < threshold:
                 del self.__debug_buffer['read'][t]
 
diff --git a/src/gateway/energy/energy_module_updater.py b/src/gateway/energy/energy_module_updater.py
index 33b64012..e9dfa0ee 100644
--- a/src/gateway/energy/energy_module_updater.py
+++ b/src/gateway/energy/energy_module_updater.py
@@ -43,19 +43,20 @@ class EnergyModuleUpdater(object):
         self._energy_communicator = energy_communicator
 
     def get_module_firmware_version(self, module_address, module_version):  # type: (int, int) -> Tuple[str, Optional[str]]
-        raw_version = self._energy_communicator.do_command(module_address, EnergyAPI.get_version(module_version))
+        response = self._energy_communicator.do_command(module_address, EnergyAPI.get_version(module_version))
         if module_version == EnergyEnums.Version.P1_CONCENTRATOR:
-            if len(raw_version) != 4:
-                raise RuntimeError('Unexpected response: {0}'.format(raw_version))
-            return '{0}.{1}.{2}'.format(raw_version[1], raw_version[2], raw_version[3]), str(raw_version[0])
+            if len(response) != 4:
+                raise RuntimeError('Unexpected response: {0}'.format(response))
+            return '{0}.{1}.{2}'.format(response[1], response[2], response[3]), str(response[0])
         else:
-            if len(raw_version) != 1:
-                raise RuntimeError('Unexpected response: {0}'.format(raw_version))
-            cleaned_version = raw_version[0].split('\x00', 1)[0]
-            parsed_version = cleaned_version.split('_')
+            if len(response) != 1:
+                raise RuntimeError('Unexpected response: {0}'.format(response))
+            raw_version = response[0].split(bytearray([0]))[0]
+            parsed_version = raw_version.decode().split('_')
             if len(parsed_version) != 4:
-                return cleaned_version, None
-            return '{0}.{1}.{2}'.format(parsed_version[1], parsed_version[2], parsed_version[3]), str(parsed_version[0])
+                return raw_version.decode(), None
+            else:
+                return '{0}.{1}.{2}'.format(*parsed_version[1:]), str(parsed_version[0])
 
     def bootload_module(self, module_version, module_address, hex_filename, firmware_version):
         if not os.path.exists(hex_filename):
@@ -162,15 +163,19 @@ class HexReader(object):
     """ Reads the hex from file and returns it in the OpenMotics format. """
 
     def __init__(self, hex_file):
+        # type: (str) -> None
         """ Constructor with the name of the hex file. """
         self._hex = intelhex.IntelHex(hex_file)
         self._crc = 0
 
     def get_bytes_version_8(self, address):
+        # type: (int) -> bytearray
         """ Get the 192 bytes from the hex file, with 3 address bytes prepended. """
-        data_bytes = [address % 256,
-                      (address % 65536) / 256,
-                      address / 65536]
+        data_bytes = bytearray([
+            address % 256,
+            (address % 65536) // 256,
+            address // 65536
+        ])
 
         iaddress = address * 2
         for i in range(64):
@@ -190,18 +195,25 @@ class HexReader(object):
 
         if address == 43904:  # Add the CRC at the end of the program
             data_bytes[-1] = self._crc % 256
-            data_bytes[-2] = (self._crc % (256 * 256)) / 256
-            data_bytes[-3] = (self._crc % (256 * 256 * 256)) / (256 * 256)
-            data_bytes[-4] = (self._crc % (256 * 256 * 256 * 256)) / (256 * 256 * 256)
+            data_bytes[-2] = (self._crc % (256 * 256)) // 256
+            data_bytes[-3] = (self._crc % (256 * 256 * 256)) // (256 * 256)
+            data_bytes[-4] = (self._crc % (256 * 256 * 256 * 256)) // (256 * 256 * 256)
 
         return data_bytes
 
     @staticmethod
     def int_to_array_12(integer):
+        # type: (int) -> bytearray
         """ Convert an integer to an array for the 12 port energy module. """
-        return [integer % 256, (integer % 65536) / 256, (integer / 65536) % 256, (integer / 65536) / 256]
+        return bytearray([
+            integer % 256,
+            (integer % 65536) // 256,
+            (integer // 65536) % 256,
+            (integer // 65536) // 256
+        ])
 
     def get_bytes_version_12(self, address):
+        # type: (int) -> bytearray
         """ Get the 128 bytes from the hex file, with 4 address bytes prepended. """
         data_bytes = self.int_to_array_12(address)
 
@@ -226,5 +238,6 @@ class HexReader(object):
         return data_bytes
 
     def get_crc(self):
+        # type: () -> int
         """ Get the crc for the block that have been read from the HexReader. """
         return self._crc
diff --git a/src/gateway/energy/module_helper_energy.py b/src/gateway/energy/module_helper_energy.py
index 6e95ad2a..4c24ecbe 100644
--- a/src/gateway/energy/module_helper_energy.py
+++ b/src/gateway/energy/module_helper_energy.py
@@ -63,11 +63,11 @@ class EnergyModuleHelper(ModuleHelper):
         # TODO: Add more information in some kind of EnergyModuleInformationDTO
         cmd = EnergyAPI.get_version(energy_module.version)
         try:
-            raw_version = self._energy_communicator.do_command(int(energy_module.module.address), cmd)
-            cleaned_version = raw_version[0].split('\x00', 1)[0]
-            parsed_version = cleaned_version.split('_')
+            response = self._energy_communicator.do_command(int(energy_module.module.address), cmd)[0]  # type: bytes
+            raw_version = response.split(bytearray([0]))[0]
+            parsed_version = raw_version.decode().split('_')
             if len(parsed_version) != 4:
-                firmware_version = cleaned_version
+                firmware_version = raw_version.decode()
             else:
                 firmware_version = '{0}.{1}.{2}'.format(*parsed_version[1:])
             return True, firmware_version
diff --git a/src/gateway/energy/module_helper_p1c.py b/src/gateway/energy/module_helper_p1c.py
index 174c1608..37263e5a 100644
--- a/src/gateway/energy/module_helper_p1c.py
+++ b/src/gateway/energy/module_helper_p1c.py
@@ -110,9 +110,9 @@ class P1ConcentratorHelper(ModuleHelper):
                                'module_id': energy_module.number,
                                'port_id': port_id,
                                'timestamp': timestamps[port_id],
-                               'gas': {'ean': eans2[port_id].strip(),
+                               'gas': {'ean': eans2[port_id],
                                        'consumption': gas_consumptions[port_id]},
-                               'electricity': {'ean': eans1[port_id].strip(),
+                               'electricity': {'ean': eans1[port_id],
                                                'current': currents[port_id],
                                                'voltage': voltages[port_id],
                                                'consumption_tariff1': consumptions1[port_id],
@@ -189,14 +189,14 @@ class P1ConcentratorHelper(ModuleHelper):
         _ = self, energy_module
         return [0.0 for _ in range(P1ConcentratorHelper.NUMBER_OF_PORTS)]
 
-    def _get_meter(self, energy_module, meter_type=1):  # type: (EnergyModule, int) -> List[str]
+    def _get_meter(self, energy_module, meter_type=1):  # type: (EnergyModule, int) -> List[Optional[str]]
         cmd = EnergyAPI.get_meter_p1(energy_module.version, meter_type=meter_type)
-        return [value or ''
-                for value in self._parse_payload(cmd=cmd,
-                                                 energy_module=energy_module,
-                                                 field_length=28,
-                                                 padding_length=0,
-                                                 filter_status=False)]
+        return self._parse_payload(cmd=cmd,
+                                   energy_module=energy_module,
+                                   field_length=28,
+                                   padding_length=0,
+                                   filter_status=False,
+                                   cast=lambda x: x.decode('utf-8').strip() or None)
 
     def _get_timestamp(self, energy_module):  # type: (EnergyModule) -> List[Optional[float]]
         cmd = EnergyAPI.get_timestamp_p1(energy_module.version)
@@ -238,7 +238,7 @@ class P1ConcentratorHelper(ModuleHelper):
                                    padding_length=0,
                                    cast=float)
 
-    def _parse_payload(self, cmd, energy_module, field_length, padding_length, cast=None, filter_status=True):  # type: (EnergyCommand, EnergyModule, int, int, Optional[Callable[[Any], Any]], bool) -> List[Optional[Any]]
+    def _parse_payload(self, cmd, energy_module, field_length, padding_length, cast=None, filter_status=True):  # type: (EnergyCommand, EnergyModule, int, int, Optional[Callable[[Any], Any]], bool) -> List[Any]
         statuses = [] if filter_status is False else self._get_statuses(energy_module=energy_module)
         part_length = field_length + padding_length
         payload = self._energy_communicator.do_command(int(energy_module.module.address), cmd)[0]
diff --git a/src/gateway/enums.py b/src/gateway/enums.py
index b12cd2c3..039cf32c 100644
--- a/src/gateway/enums.py
+++ b/src/gateway/enums.py
@@ -74,6 +74,72 @@ class ShutterEnums(object):
         DOWN = 'down'
 
 
+class ScreenEnums(object):
+    class State(object):
+        OPEN = 'open'
+        CLOSED = 'closed'
+        OPENING = 'opening'
+        CLOSING = 'closing'
+        STOPPED = 'stopped'
+        UNKNOWN = 'unknown'
+
+    STATES = [State.OPEN, State.OPENING,
+              State.CLOSED, State.CLOSING,
+              State.STOPPED, State.UNKNOWN]
+
+    class Type(object):
+        # Vertical is e.g. a shutter that moves up/down where the `blades` (if any) are horizontal
+        VERTICAL_TRANSLATIONAL = 'vertical_translational'
+        VERTICAL_ROTATIONAL = 'vertical_rotational'
+        VERTICAL_TRANSLATIONAL_ROTATIONAL = 'vertical_translational_rotational'
+        # Horizontal is e.g. a curtain that moves left/right where the `blades` (if any) are vertical
+        HORIZONTAL_TRANSLATIONAL = 'horizontal_translational'
+        HORIZONTAL_ROTATIONAL = 'horizontal_rotational'
+        HORIZONTAL_TRANSLATIONAL_ROTATIONAL = 'horizontal_translational_rotational'
+        # Roof is e.g. a patio cover that moves flat in respect to the ground where the blades (if any) rotate from standing up to laying flat
+        ROOF_TRANSLATIONAL = 'roof_translational'
+        ROOF_ROTATIONAL = 'roof_rotational'
+        ROOF_TRANSLATIONAL_ROTATIONAL = 'roof_translational_rotational'
+
+    TYPES = [Type.VERTICAL_TRANSLATIONAL, Type.VERTICAL_ROTATIONAL, Type.VERTICAL_TRANSLATIONAL_ROTATIONAL,
+             Type.HORIZONTAL_TRANSLATIONAL, Type.HORIZONTAL_ROTATIONAL, Type.HORIZONTAL_TRANSLATIONAL_ROTATIONAL,
+             Type.ROOF_TRANSLATIONAL, Type.ROOF_ROTATIONAL, Type.ROOF_TRANSLATIONAL_ROTATIONAL]
+
+    class Action(object):
+        GOTO_POSITION = 'goto_position'
+        OPEN = 'open'
+        CLOSE = 'close'
+        STOP = 'stop'
+
+    class CallbackAction(object):
+        REGISTER = 'register'
+        REPORT_STATUS = 'report_status'
+        LOAD_SCREENS = 'load_screens'
+        GOTO_POSITION = 'goto_position'
+        OPEN = 'open'
+        CLOSE = 'close'
+        STOP = 'stop'
+
+
+class MetricsEnums(object):
+    class Action(object):
+        DELIVER_METRICS = 'deliver_metrics'
+
+    class CallbackAction(object):
+        DELIVER_METRICS = 'deliver_metrics'
+        SUBSCRIBE_METRICS = 'subscribe_metrics'
+
+
+class VentilationEnums(object):
+    class Action(object):
+        SET_AUTO = 'set_auto'
+        SET_MANUAL = 'set_manual'
+
+    class CallbackAction(object):
+        REGISTER = 'register'
+        REPORT_STATUS = 'report_status'
+
+
 class UserEnums(object):
     class AuthenticationErrors(object):
         INVALID_CREDENTIALS = 'invalid_credentials'
@@ -84,6 +150,7 @@ class UserEnums(object):
 
 
 class ThermostatMode(object):
+    OFF     = 'off'      # type: Literal['off']
     COOLING = 'cooling'  # type: Literal['cooling']
     HEATING = 'heating'  # type: Literal['heating']
 
@@ -99,6 +166,127 @@ class IndicateType(object):
     SENSOR = 2
 
 
+class SensorEnums(object):
+
+    class PhysicalQuantities(object):
+        TEMPERATURE = 'temperature'
+        HUMIDITY = 'humidity'
+        BRIGHTNESS = 'brightness'
+        SOUND = 'sound'
+        DUST = 'dust'
+        COMFORT_INDEX = 'comfort_index'
+        AQI = 'aqi'
+        CO2 = 'co2'
+        VOC = 'voc'
+        ELECTRIC_POTENTIAL = 'electric_potential'
+        ELECTRIC_CURRENT = 'electric_current'
+        FREQUENCY = 'frequency'
+        ENERGY = 'energy'
+        POWER = 'power'
+
+    ALL_PHYSICAL_QUANTITIES = [PhysicalQuantities.TEMPERATURE, PhysicalQuantities.HUMIDITY,
+                               PhysicalQuantities.BRIGHTNESS, PhysicalQuantities.SOUND,
+                               PhysicalQuantities.DUST, PhysicalQuantities.COMFORT_INDEX,
+                               PhysicalQuantities.AQI, PhysicalQuantities.CO2, PhysicalQuantities.VOC,
+                               PhysicalQuantities.ELECTRIC_POTENTIAL, PhysicalQuantities.ELECTRIC_CURRENT,
+                               PhysicalQuantities.FREQUENCY, PhysicalQuantities.ELECTRIC_CURRENT,
+                               PhysicalQuantities.ENERGY, PhysicalQuantities.POWER]
+
+    class Units(object):
+        NONE = 'none'
+        CELCIUS = 'celcius'
+        PERCENT = 'percent'
+        DECIBEL = 'decibel'
+        LUX = 'lux'
+        MICRO_GRAM_PER_CUBIC_METER = 'micro_gram_per_cubic_meter'
+        PARTS_PER_MILLION = 'parts_per_million'
+        VOLT = 'volt'
+        AMPERE = 'ampere'
+        HERTZ = 'hertz'
+        KILO_WATT_HOUR = 'kilo_watt_hour'
+        JOULE = 'joule'
+        WATT = 'watt'
+
+    ALL_UNITS = [Units.NONE, Units.CELCIUS, Units.PERCENT, Units.DECIBEL, Units.LUX,
+                 Units.MICRO_GRAM_PER_CUBIC_METER, Units.PARTS_PER_MILLION,
+                 Units.VOLT, Units.AMPERE, Units.HERTZ, Units.KILO_WATT_HOUR,
+                 Units.JOULE, Units.WATT]
+
+    class CallbackAction(object):
+        REGISTER = 'register'
+        REPORT_STATUS = 'report_status'
+
+
+class Source(object):
+    MASTER = 'master'
+    PLUGIN = 'plugin'
+
+
+class PluginEnums(object):
+    class State(object):
+        RUNNING = 'RUNNING'
+        STOPPED = 'STOPPED'
+
+
+class PluginActionEnums(object):
+    class Action(object):
+        # Technical
+        LOGS = 'logs'
+        START = 'start'
+        STOP = 'stop'
+        PING = 'ping'
+        REMOVE = 'remove'
+
+        # Legacy master `EV` event
+        RECEIVE_EVENTS = 'receive_events'
+
+        # API requests
+        REQUEST = 'request'
+
+        # Connector actions & callback actions
+        SENSOR_ACTION = 'sensor_action'
+        SENSOR_CALLBACK_ACTION = 'sensor_callback_action'
+        SCREEN_ACTION = 'screen_action'
+        SCREEN_CALLBACK_ACTION = 'screen_callback_action'
+        METRIC_ACTION = 'metric_action'
+        METRIC_CALLBACK_ACTION = 'metric_callback_action'
+        VENTILATION_ACTION = 'ventilation_action'
+        VENTILATION_CALLBACK_ACTION = 'ventilation_callback_action'
+        NOTIFICATION_CALLBACK_ACTION = 'notification_callback_action'
+
+        # Connector status events
+        PROCESS_STATUS_EVENT = 'process_status_event'
+        SUBSCRIBE_STATUS_EVENT = 'subscribe_status_event'
+
+    CONNECTOR_ACTIONS = [Action.SCREEN_ACTION, Action.METRIC_ACTION, Action.VENTILATION_ACTION]
+
+    class StatusEventType(BaseEnum):
+        INPUT_CHANGE = 'INPUT_CHANGE'
+        OUTPUT_CHANGE = 'OUTPUT_CHANGE'
+        SENSOR_CHANGE = 'SENSOR_CHANGE'
+        SHUTTER_CHANGE = 'SHUTTER_CHANGE'
+        SCREEN_CHANGE = 'SCREEN_CHANGE'
+        THERMOSTAT_CHANGE = 'THERMOSTAT_CHANGE'
+        THERMOSTAT_GROUP_CHANGE = 'THERMOSTAT_GROUP_CHANGE'
+        VENTILATION_CHANGE = 'VENTILATION_CHANGE'
+
+    STATUS_EVENT_TYPES = [StatusEventType.INPUT_CHANGE, StatusEventType.OUTPUT_CHANGE, StatusEventType.SENSOR_CHANGE,
+                          StatusEventType.SHUTTER_CHANGE, StatusEventType.SCREEN_CHANGE,
+                          StatusEventType.THERMOSTAT_CHANGE, StatusEventType.THERMOSTAT_GROUP_CHANGE,
+                          StatusEventType.VENTILATION_CHANGE]
+
+
+class NotificationEnums(object):
+    class Type(object):
+        USER = 'USER'
+        SYSTEM = 'SYSTEM'
+
+    TYPES = [Type.USER, Type.SYSTEM]
+
+    class CallbackAction(object):
+        SEND = 'send'
+
+
 class EnergyEnums(object):
     class Version(object):
         POWER_MODULE = 8
@@ -203,3 +391,25 @@ class UpdateEnums(object):
         FORCED = 'FORCED'
         MANUAL = 'MANUAL'
         AUTOMATIC = 'AUTOMATIC'
+
+
+class Firmwares(object):
+    PYTHON_INTERPRETER = 'python_interpreter'
+    PYTHON_DEPENDENCIES = 'python_dependencies'
+    GATEWAY_SERVICE = 'gateway_service'
+    VIRTUAL_ENVIRONMENT = 'virtual_environment'
+    GATEWAY_FRONTEND = 'gateway_frontend'
+    MASTER_CLASSIC = 'master_classic'
+    MASTER_COREPLUS = 'master_coreplus'
+    ENERGY = 'energy'
+    P1_CONCENTRATOR = 'p1_concentrator'
+    INPUT = 'input'
+    INPUT_GEN3 = 'input_gen3'
+    OUTPUT = 'output'
+    OUTPUT_GEN3 = 'output_gen3'
+    DIMMER = 'dimmer'
+    DIMMER_GEN3 = 'dimmer_gen3'
+    TEMPERATURE = 'temperature'
+    CAN = 'can'
+    CAN_GEN3 = 'can_gen3'
+    UCAN = 'ucan'
diff --git a/src/gateway/events.py b/src/gateway/events.py
index 8a4c5fae..1564de77 100644
--- a/src/gateway/events.py
+++ b/src/gateway/events.py
@@ -138,6 +138,13 @@ class GatewayEvent(BaseEvent):
                   'last_change': int}         # timestamp of last change
        'location': {'room_id': int}}          # Room ID
 
+    * SCREEN_CHANGE
+      {'id': int,                                        # Screen ID
+       'status: {'translational': {'position': int,      # Position 0 - <steps> (optional)
+                                   'state': str},        # State: `open`, `opening`, `close`, `closing`, `stopped`, `unknown`
+                 'rotational': {'position': int,         # Similar to `translational`. Note that both `translational`
+                                'state': str}}}          # and `rotatational` properties are optional, depending on capabilities
+
     * SENSOR_CHANGE
       {'id': int,       # Sensor ID
        'plugin': str,   # Target Plugin
@@ -164,6 +171,8 @@ class GatewayEvent(BaseEvent):
         OUTPUT_CHANGE = 'OUTPUT_CHANGE'
         SENSOR_CHANGE = 'SENSOR_CHANGE'
         SHUTTER_CHANGE = 'SHUTTER_CHANGE'
+        SCREEN_CHANGE = 'SCREEN_CHANGE'
+        PLUGIN_CHANGE = 'PLUGIN_CHANGE'
         THERMOSTAT_CHANGE = 'THERMOSTAT_CHANGE'
         THERMOSTAT_GROUP_CHANGE = 'THERMOSTAT_GROUP_CHANGE'
         VENTILATION_CHANGE = 'VENTILATION_CHANGE'
@@ -171,3 +180,8 @@ class GatewayEvent(BaseEvent):
         ACTION = 'ACTION'
         PING = 'PING'
         PONG = 'PONG'
+
+    STATUS_EVENT_TYPES = [Types.INPUT_CHANGE, Types.OUTPUT_CHANGE, Types.SENSOR_CHANGE,
+                          Types.SHUTTER_CHANGE, Types.SCREEN_CHANGE,
+                          Types.THERMOSTAT_CHANGE, Types.THERMOSTAT_GROUP_CHANGE,
+                          Types.VENTILATION_CHANGE]
diff --git a/src/gateway/exceptions.py b/src/gateway/exceptions.py
index 4beefb5c..36b4af22 100644
--- a/src/gateway/exceptions.py
+++ b/src/gateway/exceptions.py
@@ -101,3 +101,13 @@ class InMaintenanceModeException(CommunicationFailure):
 
 class MasterUnavailable(CommunicationFailure):
     pass
+
+
+class PluginCommunicationTimeout(Exception):
+    pass
+
+
+class PluginException(Exception):
+    def __init__(self, message, stacktrace):
+        super(PluginException, self).__init__(message)
+        self.stacktrace = stacktrace
diff --git a/src/gateway/hal/mappers_classic/__init__.py b/src/gateway/hal/mappers_classic/__init__.py
index 8fd091a5..7c7d1533 100644
--- a/src/gateway/hal/mappers_classic/__init__.py
+++ b/src/gateway/hal/mappers_classic/__init__.py
@@ -19,7 +19,6 @@ from gateway.hal.mappers_classic.input import InputMapper
 from gateway.hal.mappers_classic.output import DimmerConfigurationMapper, \
     OutputMapper
 from gateway.hal.mappers_classic.pulse_counter import PulseCounterMapper
-from gateway.hal.mappers_classic.rtd10 import GlobalRTD10Mapper, RTD10Mapper
 from gateway.hal.mappers_classic.sensor import SensorMapper
 from gateway.hal.mappers_classic.shutter import ShutterMapper
 from gateway.hal.mappers_classic.shutter_group import ShutterGroupMapper
diff --git a/src/gateway/hal/mappers_classic/rtd10.py b/src/gateway/hal/mappers_classic/rtd10.py
deleted file mode 100644
index a6f1a739..00000000
--- a/src/gateway/hal/mappers_classic/rtd10.py
+++ /dev/null
@@ -1,78 +0,0 @@
-# Copyright (C) 2020 OpenMotics BV
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Affero General Public License as
-# published by the Free Software Foundation, either version 3 of the
-# License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Affero General Public License for more details.
-#
-# You should have received a copy of the GNU Affero General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-"""
-RTD10 Mapper
-"""
-from toolbox import Toolbox
-from gateway.dto import GlobalRTD10DTO, RTD10DTO
-from master.classic.eeprom_controller import EepromModel
-from master.classic.eeprom_models import GlobalRTD10Configuration
-
-if False:  # MYPY
-    from typing import List, Type
-
-
-class GlobalRTD10Mapper(object):
-    @staticmethod
-    def _temp_to_str(temp):
-        return str(temp).replace('.', '_').replace('_0', '')
-
-    @staticmethod
-    def orm_to_dto(orm_object):  # type: (EepromModel) -> GlobalRTD10DTO
-        data = orm_object.serialize()
-        heating_values = {}
-        cooling_values = {}
-        for temperature in GlobalRTD10DTO.TEMPERATURES:
-            field = 'output_value_heating_{0}'.format(GlobalRTD10Mapper._temp_to_str(temperature))
-            heating_values[temperature] = data[field]
-            field = 'output_value_cooling_{0}'.format(GlobalRTD10Mapper._temp_to_str(temperature))
-            cooling_values[temperature] = data[field]
-        return GlobalRTD10DTO(heating_values=heating_values,
-                              cooling_values=cooling_values)
-
-    @staticmethod
-    def dto_to_orm(global_rtd10_dto):  # type: (GlobalRTD10DTO) -> EepromModel
-        data = {}
-        for temperature in GlobalRTD10DTO.TEMPERATURES:
-            field = 'output_value_heating_{0}'.format(GlobalRTD10Mapper._temp_to_str(temperature))
-            data[field] = global_rtd10_dto.heating_values[temperature]
-            field = 'output_value_cooling_{0}'.format(GlobalRTD10Mapper._temp_to_str(temperature))
-            data[field] = global_rtd10_dto.cooling_values[temperature]
-        return GlobalRTD10Configuration.deserialize(data)
-
-
-class RTD10Mapper(object):
-    BYTE_MAX = 255
-
-    @staticmethod
-    def orm_to_dto(orm_object):  # type: (EepromModel) -> RTD10DTO
-        data = orm_object.serialize()
-        kwargs = {}
-        for field in ['temp_setpoint_output', 'ventilation_speed_output', 'ventilation_speed_value',
-                      'mode_output', 'mode_value', 'on_off_output', 'poke_angle_output',
-                      'poke_angle_value', 'room']:
-            kwargs[field] = Toolbox.nonify(data[field], RTD10Mapper.BYTE_MAX)
-        return RTD10DTO(id=data['id'], **kwargs)
-
-    @staticmethod
-    def dto_to_orm(model_type, rtd10_dto):  # type: (Type[EepromModel], RTD10DTO) -> EepromModel
-        data = {'id': rtd10_dto.id}
-        for field in ['temp_setpoint_output', 'ventilation_speed_output', 'ventilation_speed_value',
-                      'mode_output', 'mode_value', 'on_off_output', 'poke_angle_output',
-                      'poke_angle_value', 'room']:
-            if field in rtd10_dto.loaded_fields:
-                data[field] = Toolbox.denonify(getattr(rtd10_dto, field), RTD10Mapper.BYTE_MAX)
-        return model_type.deserialize(data)
diff --git a/src/gateway/hal/mappers_core/group_action.py b/src/gateway/hal/mappers_core/group_action.py
index 46be43dc..80cdf4f6 100644
--- a/src/gateway/hal/mappers_core/group_action.py
+++ b/src/gateway/hal/mappers_core/group_action.py
@@ -21,7 +21,7 @@ from toolbox import Toolbox
 from gateway.dto import GroupActionDTO
 from master.core.group_action import GroupAction
 from master.core.basic_action import BasicAction
-
+from master.core.system_value import Dimmer
 if False:  # MYPY
     from typing import List, Dict, Any, Optional, Tuple
 
@@ -302,16 +302,18 @@ class GroupActionMapper(object):
                 # ...
                 # 183: Light/Output x On with dimmer at 80% (x<240, with standard timer setting)
                 # 184: Light/Output x On with dimmer at 90% (x<240, with standard timer setting)
+                value = GroupActionMapper._action_type_to_gen3_dimmer(action_type)
                 actions.append(BasicAction(action_type=0, action=2, device_nr=action_number,
-                                           extra_parameter={176: 25, 177: 51, 178: 76, 179: 102, 180: 127, 181: 153, 182: 178, 183: 204, 184: 229}[action_type]))
+                                           extra_parameter=value))
             elif 185 <= action_type <= 194:
                 # 185: Toggle/Output light x with dimmer at 10% (x<240, with standard timer setting)
                 # 186: Toggle light/Output x with dimmer at 20% (x<240, with standard timer setting)
                 # ...
                 # 193: Toggle light/Output x with dimmer at 90% (x<240, with standard timer setting)
                 # 194: Toggle light/Output x with dimmer at 100% (x<240, with standard timer setting)
+                value = GroupActionMapper._action_type_to_gen3_dimmer(action_type)
                 actions.append(BasicAction(action_type=0, action=17, device_nr=action_number,
-                                           extra_parameter={185: 25, 186: 51, 187: 76, 188: 102, 189: 127, 190: 153, 191: 178, 192: 204, 193: 229, 194: 255}[action_type]))
+                                           extra_parameter=value))
             elif 195 <= action_type <= 200:
                 # 195: Light/Output x on with timer at 2 min 30 and overrule timer value when light is already switched on (x<240, with last dimmer value) - see #Timers
                 # 196: Light/Output x on with timer at 7 min 30 and overrule timer value when light is already switched on (x<240, with last dimmer value) - see #Timers
@@ -440,3 +442,19 @@ class GroupActionMapper(object):
                 # 254: Reset the Master
                 actions.append(BasicAction(action_type=254, action=0))
         return actions
+
+    @staticmethod       # BE-390: dimmer values fixed
+    def _action_type_to_gen3_dimmer(action_type):   # type: (int) -> int
+        # concatenating action types for toggling or turning dimmer on
+        action_types_turn_dimmer = [x for x in range(176, 185)]
+        action_types_toggle_dimmer = [x for x in range(185, 196)]
+        action_types = action_types_turn_dimmer + action_types_toggle_dimmer
+
+        # concatenating dimmer values for toggling or turning dimmer on
+        dimmer_values_turn_dimmer = [Dimmer.dimmer_to_system_value(x) for x in range(10, 100, 10)]
+        dimmer_values_toggle_dimmer = [Dimmer.dimmer_to_system_value(x) for x in range(10, 110, 10)]
+        dimmer_values = dimmer_values_turn_dimmer + dimmer_values_toggle_dimmer
+
+        # mapping action types to correct dimmer values
+        gen_2_to_3_dimmer_mapping = dict(zip(action_types, dimmer_values))
+        return gen_2_to_3_dimmer_mapping[action_type]
diff --git a/src/gateway/hal/master_controller.py b/src/gateway/hal/master_controller.py
index ea49311e..f934fba9 100644
--- a/src/gateway/hal/master_controller.py
+++ b/src/gateway/hal/master_controller.py
@@ -20,12 +20,12 @@ from __future__ import absolute_import
 from gateway.dto import DimmerConfigurationDTO, GlobalFeedbackDTO, \
     GroupActionDTO, InputDTO, InputStatusDTO, MasterSensorDTO, ModuleDTO, \
     OutputDTO, OutputStatusDTO, PulseCounterDTO, SensorDTO, ShutterDTO, \
-    ShutterGroupDTO, ThermostatAircoStatusDTO, ThermostatDTO, \
+    ShutterGroupDTO, ThermostatDTO, \
     ThermostatGroupDTO
 
 if False:  # MYPY
     from datetime import datetime
-    from typing import Any, Dict, List, Literal, Optional, Tuple, Set
+    from typing import Any, Dict, Iterable, List, Literal, Optional, Tuple, Set
 
     HEALTH = Literal['success', 'unstable', 'failure']
 
@@ -199,14 +199,6 @@ class MasterController(object):
         # type: () -> Dict[str,Any]
         raise NotImplementedError()
 
-    def load_airco_status(self):
-        # type: () -> ThermostatAircoStatusDTO
-        raise NotImplementedError()
-
-    def set_airco_status(self, thermostat_id, airco_on):
-        # type: (int, bool) -> None
-        raise NotImplementedError()
-
     def set_thermostat_tenant_manual(self, thermostat_id):
         # type: (int) -> None
         raise NotImplementedError()
@@ -245,46 +237,6 @@ class MasterController(object):
         # type: (List[Dict[str,Any]]) -> None
         raise NotImplementedError()
 
-    def get_global_rtd10_configuration(self, fields=None):
-        # type: (Optional[List[str]]) -> Dict[str,Any]
-        raise NotImplementedError()
-
-    def set_global_rtd10_configuration(self, config):
-        # type: (Dict[str,Any]) -> None
-        raise NotImplementedError()
-
-    def get_rtd10_heating_configuration(self, heating_id, fields=None):
-        # type: (int, Optional[List[str]]) -> Dict[str,Any]
-        raise NotImplementedError()
-
-    def get_rtd10_heating_configurations(self, fields=None):
-        # type: (Optional[List[str]]) -> List[Dict[str,Any]]
-        raise NotImplementedError()
-
-    def set_rtd10_heating_configuration(self, config):
-        # type: (Dict[str,Any]) -> None
-        raise NotImplementedError()
-
-    def set_rtd10_heating_configurations(self, config):
-        # type: (List[Dict[str,Any]]) -> None
-        raise NotImplementedError()
-
-    def get_rtd10_cooling_configuration(self, cooling_id, fields=None):
-        # type: (int, Optional[List[str]]) -> Dict[str,Any]
-        raise NotImplementedError()
-
-    def get_rtd10_cooling_configurations(self, fields=None):
-        # type: (Optional[List[str]]) -> List[Dict[str,Any]]
-        raise NotImplementedError()
-
-    def set_rtd10_cooling_configuration(self, config):
-        # type: (Dict[str,Any]) -> None
-        raise NotImplementedError()
-
-    def set_rtd10_cooling_configurations(self, config):
-        # type: (List[Dict[str,Any]]) -> None
-        raise NotImplementedError()
-
     def load_thermostat_group(self):
         # type: () -> ThermostatGroupDTO
         raise NotImplementedError()
@@ -418,10 +370,11 @@ class MasterController(object):
     def flash_leds(self, led_type, led_id):  # type: (int, int) -> str
         raise NotImplementedError()
 
-    def get_backup(self): # type: () -> bytearray
+    def get_backup(self): # type: () -> Iterable[bytearray]
         raise NotImplementedError()
 
     def restore(self, data):
+        # type: (bytearray) -> None
         raise NotImplementedError()
 
     def factory_reset(self, can):
@@ -534,3 +487,7 @@ class MasterController(object):
 
     def load_validation_bits(self):
         raise NotImplementedError()
+
+    def get_serial_number(self, update=False):
+        # type: (bool) -> Optional[str]
+        raise NotImplementedError()
diff --git a/src/gateway/hal/master_controller_classic.py b/src/gateway/hal/master_controller_classic.py
index bcaf24a4..44ea5483 100644
--- a/src/gateway/hal/master_controller_classic.py
+++ b/src/gateway/hal/master_controller_classic.py
@@ -29,19 +29,18 @@ import six
 
 from enums import HardwareType
 from gateway.daemon_thread import DaemonThread, DaemonThreadWait
-from gateway.dto import RTD10DTO, DimmerConfigurationDTO, GlobalFeedbackDTO, \
-    GlobalRTD10DTO, GroupActionDTO, InputDTO, InputStatusDTO, \
-    MasterSensorDTO, ModuleDTO, OutputDTO, OutputStatusDTO, PulseCounterDTO, \
-    PumpGroupDTO, ShutterDTO, ShutterGroupDTO, ThermostatAircoStatusDTO, \
-    ThermostatDTO, ThermostatGroupDTO
-from gateway.enums import ModuleType, ShutterEnums, ThermostatMode, ThermostatState
+from gateway.dto import DimmerConfigurationDTO, GlobalFeedbackDTO, \
+    GroupActionDTO, InputDTO, InputStatusDTO, MasterSensorDTO, ModuleDTO, \
+    OutputDTO, OutputStatusDTO, PulseCounterDTO, PumpGroupDTO, ShutterDTO, \
+    ShutterGroupDTO, ThermostatDTO, ThermostatGroupDTO
+from gateway.enums import ModuleType, ShutterEnums, ThermostatMode, \
+    ThermostatState
 from gateway.exceptions import CommunicationFailure, MasterUnavailable, \
     UnsupportedException
 from gateway.hal.mappers_classic import DimmerConfigurationMapper, \
-    GlobalFeedbackMapper, GlobalRTD10Mapper, GroupActionMapper, InputMapper, \
-    OutputMapper, PulseCounterMapper, PumpGroupMapper, RTD10Mapper, \
-    SensorMapper, ShutterGroupMapper, ShutterMapper, ThermostatGroupMapper, \
-    ThermostatMapper
+    GlobalFeedbackMapper, GroupActionMapper, InputMapper, OutputMapper, \
+    PulseCounterMapper, PumpGroupMapper, SensorMapper, ShutterGroupMapper, \
+    ShutterMapper, ThermostatGroupMapper, ThermostatMapper
 from gateway.hal.master_controller import MasterController
 from gateway.hal.master_event import MasterEvent
 from gateway.pubsub import PubSub
@@ -51,10 +50,9 @@ from master.classic import eeprom_models, master_api
 from master.classic.eeprom_controller import EepromAddress, EepromController
 from master.classic.eeprom_models import CoolingConfiguration, \
     CoolingPumpGroupConfiguration, DimmerConfiguration, \
-    GlobalRTD10Configuration, GlobalThermostatConfiguration, \
-    PumpGroupConfiguration, RTD10CoolingConfiguration, \
-    RTD10HeatingConfiguration, ScheduledActionConfiguration, \
-    StartupActionConfiguration, ThermostatConfiguration
+    GlobalThermostatConfiguration, PumpGroupConfiguration, \
+    ScheduledActionConfiguration, StartupActionConfiguration, \
+    ThermostatConfiguration
 from master.classic.master_command import DimmerFieldType
 from master.classic.master_communicator import BackgroundConsumer, \
     MasterCommunicator
@@ -64,7 +62,7 @@ from master.classic.validationbits import ValidationBitStatus
 from serial_utils import CommunicationTimedOutException
 
 if False:  # MYPY
-    from typing import Any, Dict, List, Literal, Optional, Tuple, Set, TypeVar, Union
+    from typing import Any, Dict, Iterable, List, Literal, Optional, Tuple, Set, TypeVar, Union
     from serial import Serial
     T_co = TypeVar('T_co', covariant=True)
 
@@ -771,19 +769,6 @@ class MasterClassicController(MasterController):
         # type: () -> Dict[str,Any]
         return self._master_communicator.do_command(master_api.thermostat_mode_list())
 
-    @communication_enabled
-    def load_airco_status(self):
-        # type: () -> ThermostatAircoStatusDTO
-        data = self._master_communicator.do_command(master_api.read_airco_status_bits())
-        return ThermostatAircoStatusDTO({i: data['ASB{0}'.format(i)] == 1 for i in range(32)})
-
-    @communication_enabled
-    def set_airco_status(self, thermostat_id, airco_on):
-        # type: (int, bool) -> None
-        self.do_basic_action(
-            master_api.BA_THERMOSTAT_AIRCO_STATUS, thermostat_id + (0 if airco_on else 100)
-        )
-
     @communication_enabled
     def load_heating_thermostat(self, thermostat_id):  # type: (int) -> ThermostatDTO
         classic_object = self._eeprom_controller.read(eeprom_models.ThermostatConfiguration, thermostat_id)
@@ -835,50 +820,6 @@ class MasterClassicController(MasterController):
             batch.append(PumpGroupMapper.dto_to_orm(CoolingPumpGroupConfiguration, pump_group))
         self._eeprom_controller.write_batch(batch)
 
-    @communication_enabled
-    def load_global_rtd10(self):  # type: () -> GlobalRTD10DTO
-        classic_object = self._eeprom_controller.read(GlobalRTD10Configuration)
-        return GlobalRTD10Mapper.orm_to_dto(classic_object)
-
-    @communication_enabled
-    def save_global_rtd10(self, global_rtd10):  # type: (GlobalRTD10DTO) -> None
-        classic_object = GlobalRTD10Mapper.dto_to_orm(global_rtd10)
-        self._eeprom_controller.write(classic_object)
-
-    @communication_enabled
-    def load_heating_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        classic_object = self._eeprom_controller.read(RTD10HeatingConfiguration, rtd10_id)
-        return RTD10Mapper.orm_to_dto(classic_object)
-
-    @communication_enabled
-    def load_heating_rtd10s(self):  # type: () -> List[RTD10DTO]
-        return [RTD10Mapper.orm_to_dto(o)
-                for o in self._eeprom_controller.read_all(RTD10HeatingConfiguration)]
-
-    @communication_enabled
-    def save_heating_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        batch = []
-        for rtd10_dto in rtd10s:
-            batch.append(RTD10Mapper.dto_to_orm(RTD10HeatingConfiguration, rtd10_dto))
-        self._eeprom_controller.write_batch(batch)
-
-    @communication_enabled
-    def load_cooling_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        classic_object = self._eeprom_controller.read(RTD10CoolingConfiguration, rtd10_id)
-        return RTD10Mapper.orm_to_dto(classic_object)
-
-    @communication_enabled
-    def load_cooling_rtd10s(self):  # type: () -> List[RTD10DTO]
-        return [RTD10Mapper.orm_to_dto(o)
-                for o in self._eeprom_controller.read_all(RTD10CoolingConfiguration)]
-
-    @communication_enabled
-    def save_cooling_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        batch = []
-        for rtd10_dto in rtd10s:
-            batch.append(RTD10Mapper.dto_to_orm(RTD10CoolingConfiguration, rtd10_dto))
-        self._eeprom_controller.write_batch(batch)
-
     @communication_enabled
     def load_thermostat_group(self):
         # type: () -> ThermostatGroupDTO
@@ -1180,21 +1121,21 @@ class MasterClassicController(MasterController):
 
     @communication_enabled
     def get_backup(self):
-        # type: () -> bytearray
+        # type: () -> Iterable[bytearray]
         """
         Get a backup of the eeprom of the master.
 
         :returns: String of bytes (size = 64kb).
         """
         retry = None
-        output = bytearray()
         bank = 0
         while bank < 256:
             try:
-                output += self._master_communicator.do_command(
+                response = self._master_communicator.do_command(
                     master_api.eeprom_list(),
                     {'bank': bank}
-                )['data']
+                )
+                yield bytearray(response['data'])
                 bank += 1
             except CommunicationTimedOutException:
                 if retry == bank:
@@ -1202,7 +1143,6 @@ class MasterClassicController(MasterController):
                 retry = bank
                 logger.warning('Got timeout reading bank {0}. Retrying...'.format(bank))
                 time.sleep(2)  # Doing heavy reads on eeprom can exhaust the master. Give it a bit room to breathe.
-        return output
 
     def factory_reset(self, can=False):
         # type: (bool) -> None
@@ -1212,7 +1152,7 @@ class MasterClassicController(MasterController):
         if can:
             self.can_control_factory_reset()
         # Wipe master EEPROM
-        data = chr(255) * (256 * 256)
+        data = bytearray([255] * (256 * 256))
         self.restore(data)
 
     def can_control_factory_reset(self):
@@ -1394,6 +1334,7 @@ class MasterClassicController(MasterController):
 
     @communication_enabled
     def restore(self, data):
+        # type: (bytearray) -> None
         """
         Restore a backup of the eeprom of the master.
 
@@ -1401,19 +1342,15 @@ class MasterClassicController(MasterController):
         :type data: string of bytes (size = 64 kb).
         :returns: dict with 'output' key (contains an array with the addresses that were written).
         """
-        ret = []
         (num_banks, bank_size, write_size) = (256, 256, 10)
-        backup_data = bytearray(ord(c) for c in data)
 
         for bank in range(0, num_banks):
             current_data = self._master_communicator.do_command(master_api.eeprom_list(),
                                                                 {'bank': bank})['data']
             for addr in range(0, bank_size, write_size):
                 current = current_data[addr:addr + write_size]
-                new = backup_data[bank * bank_size + addr: bank * bank_size + addr + len(current)]
+                new = data[bank * bank_size + addr: bank * bank_size + addr + len(current)]
                 if new != current:
-                    ret.append('B' + str(bank) + 'A' + str(addr))
-
                     self._master_communicator.do_command(
                         master_api.write_eeprom(),
                         {'bank': bank, 'address': addr, 'data': new}
@@ -1422,12 +1359,8 @@ class MasterClassicController(MasterController):
         self._master_communicator.do_command(master_api.activate_eeprom(), {'eep': 0},
                                              timeout=5)
         self.cold_reset()
-
-        ret.append('Activated eeprom')
         self._eeprom_controller.invalidate_cache()
 
-        return {'output': ret}
-
     @communication_enabled
     def set_datetime(self, dt):
         # type: (datetime) -> None
diff --git a/src/gateway/hal/master_controller_core.py b/src/gateway/hal/master_controller_core.py
index f3b30294..ed9a67fa 100644
--- a/src/gateway/hal/master_controller_core.py
+++ b/src/gateway/hal/master_controller_core.py
@@ -61,7 +61,7 @@ from platform_utils import Hardware
 from serial_utils import CommunicationStatus, CommunicationTimedOutException
 
 if False:  # MYPY
-    from typing import Any, Dict, List, Literal, Tuple, Optional, Type, Union, TypeVar, Set, Callable
+    from typing import Any, Dict, Iterable, List, Literal, Tuple, Optional, Type, Union, TypeVar, Set, Callable
     from master.core.core_updater import CoreUpdater
     T_co = TypeVar('T_co', bound=None, covariant=True)
     HEALTH = Literal['success', 'unstable', 'failure']
@@ -103,6 +103,7 @@ class MasterCoreController(MasterController):
         self._pulse_counter_values = {}  # type: Dict[int, Optional[int]]
         self._new_modules_found = False
         self._rogue_module_timer = None  # type: Optional[Timer]
+        self._master_serial_number = None  # type: Optional[str]
 
         self._pubsub.subscribe_master_events(PubSub.MasterTopics.EEPROM, self._handle_master_event)
 
@@ -228,6 +229,9 @@ class MasterCoreController(MasterController):
                 if core_event.data.get('type') == MasterCoreEvent.SystemEventTypes.STARTUP_COMPLETED:
                     self._master_communicator.report_blockage(blocker=CommunicationBlocker.RESTART,
                                                               active=False)
+                    # request the master serial number when the master has restarted
+                    self._read_serial_number()
+
             elif core_event.type == MasterCoreEvent.Types.FACTORY_RESET:
                 phase = core_event.data.get('phase')
                 active_map = {MasterCoreEvent.FactoryResetPhase.STARTED: True,
@@ -1600,20 +1604,20 @@ class MasterCoreController(MasterController):
                                    logger=individual_logger)
 
     def get_backup(self):
-        # type: () -> bytearray
-        data = bytearray()
+        # type: () -> Iterable[bytearray]
         pages, page_length = MemoryFile.SIZES[MemoryTypes.EEPROM]
         for page in range(pages):
             page_address = MemoryAddress(memory_type=MemoryTypes.EEPROM, page=page, offset=0, length=page_length)
-            data += self._memory_file.read([page_address])[page_address]
-        return data
+            data = self._memory_file.read([page_address])[page_address]
+            yield data
 
     def restore(self, data):
+        # type: (bytes) -> None
         amount_of_pages, page_length = MemoryFile.SIZES[MemoryTypes.EEPROM]
         current_page = amount_of_pages - 1
         while current_page >= 0:
             # Build page data
-            page_data = bytearray([ord(entry) for entry in data[current_page * page_length:(current_page + 1) * page_length]])
+            page_data = bytearray(data[current_page * page_length:(current_page + 1) * page_length])
             if len(page_data) < page_length:
                 page_data += bytearray([255] * (page_length - len(page_data)))
             # Write page data
@@ -1712,6 +1716,24 @@ class MasterCoreController(MasterController):
         # type: () -> DimmerConfigurationDTO
         return DimmerConfigurationDTO()  # All default values
 
+    def _read_serial_number(self):
+        # type: () -> str
+        cmd = CoreAPI.device_information_list_serial_number()
+        data = self._master_communicator.do_command(command=cmd, fields={})
+        serial_number = data.get('serial_number')
+        serial_number = "".join(["{:02}".format(x) for x in serial_number])
+        serial_number = serial_number[0:6:] + serial_number[7:]  # remove character 6 from the string (to make it conform the serial printout spec) (manufacturer is only one digit instead of 2)
+        serial_number = serial_number[0:7:] + serial_number[8:]  # remove character 8 from the string (to make it conform the serial printout spec) (serial counter does exist of 5 digits instead of 6)
+        self._master_serial_number = serial_number
+        logger.info("Requested master serial number: {}".format(serial_number))
+        return serial_number
+
+    def get_serial_number(self, update=False):
+        # type: (bool) -> Optional[str]
+        if update:
+            self._master_serial_number = self._read_serial_number()
+        return self._master_serial_number
+
 
 class MasterInputState(object):
     def __init__(self, interval=300):
diff --git a/src/gateway/hal/master_controller_core_dummy.py b/src/gateway/hal/master_controller_core_dummy.py
index 3b8cb3de..72ca4ad4 100644
--- a/src/gateway/hal/master_controller_core_dummy.py
+++ b/src/gateway/hal/master_controller_core_dummy.py
@@ -17,24 +17,29 @@ Module for communicating with the Master
 """
 from __future__ import absolute_import
 
-import logging
 import json
+import logging
 import os
 from datetime import datetime
+
 from six.moves.configparser import ConfigParser
 
 import constants
+from gateway.enums import ShutterEnums
 from gateway.hal.master_controller_core import MasterCoreController
-from master.core.core_communicator import CoreCommunicator
-from master.core.memory_models import GlobalConfiguration, InputConfiguration
+from gateway.hal.master_event import MasterEvent
+from gateway.pubsub import PubSub
+from ioc import INJECTED, Inject, Singleton
 from master.core.basic_action import BasicAction
-from master.core.fields import WordField, ByteField
 from master.core.core_api import CoreAPI
+from master.core.core_communicator import CoreCommunicator
+from master.core.fields import ByteField, WordField
 from master.core.group_action import GroupActionController
-from ioc import Inject, INJECTED, Singleton
+from master.core.memory_models import GlobalConfiguration, \
+    InputConfiguration, ShutterConfiguration
 
 if False:  # MYPY
-    from typing import List, Dict, Any, Union, Optional, TypeVar
+    from typing import Any, Dict, List, Union, Optional, TypeVar
     from master.core.memory_file import MemoryAddress
     from master.core.core_command import CoreCommandSpec
     from master.core.core_communicator import Consumer
@@ -100,8 +105,9 @@ class DummyCommunicator(object):
     """
 
     @Inject
-    def __init__(self, memory_file=INJECTED):
+    def __init__(self, memory_file=INJECTED, pubsub=INJECTED):
         self._memory_file = memory_file
+        self._pubsub = pubsub  # type: PubSub
         self._output_states = {}  # type: Dict[int, Dict[str, Any]]
         self._input_states = {}  # type: Dict[int, bool]
         self._consumers = []  # type: List[Consumer]
@@ -140,7 +146,8 @@ class DummyCommunicator(object):
         This method reads the command, executes actions and returns an appropriate response.
         """
         if command.instruction == b'GC':
-            if command.request_fields[0]._data == bytearray([0]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            instruction = command.request_fields[0]  # type: Any
+            if instruction._data == bytearray([0]):
                 global_configuration = GlobalConfiguration()
                 return {'type': 0,
                         'output': global_configuration.number_of_output_modules,
@@ -168,14 +175,15 @@ class DummyCommunicator(object):
                     'weekday': now.isoweekday(),
                     'day': now.day, 'month': now.month, 'year': now.year - 2000}
         if command.instruction == b'ST':
-            if command.request_fields[0]._data == bytearray([0]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            instruction = command.request_fields[0]
+            if instruction._data == bytearray([0]):
                 return {'info_type': 0,
                         'rs485_mode': 0,
                         'ba_debug_mode': 0}
-            if command.request_fields[0]._data == bytearray([1]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            if instruction._data == bytearray([1]):
                 return {'info_type': 1,
                         'version': '0.1.0'}
-            if command.request_fields[0]._data == bytearray([2]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            if instruction._data == bytearray([2]):
                 global_configuration = GlobalConfiguration()
                 return {'info_type': 2,
                         'amount_output_modules': global_configuration.number_of_output_modules,
@@ -183,11 +191,13 @@ class DummyCommunicator(object):
                         'amount_sensor_modules': global_configuration.number_of_sensor_modules,
                         'amount_can_control_modules': global_configuration.number_of_can_control_modules}
         if command.instruction == b'CD':
-            if command.request_fields[0]._data == bytearray([0]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            instruction = command.request_fields[0]
+            if instruction._data == bytearray([0]):
                 return {'amount_of_ucans': 0}
         if command.instruction == b'DL':
             global_configuration = GlobalConfiguration()
-            if command.request_fields[0]._data == bytearray([0]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            instruction = command.request_fields[0]
+            if instruction._data == bytearray([0]):
                 information = []
                 for module_id in range(global_configuration.number_of_output_modules):
                     output_byte = 0
@@ -198,7 +208,7 @@ class DummyCommunicator(object):
                             output_byte |= (1 << entry_id)
                     information.append(output_byte)
                 return {'type': 0, 'information': information}
-            if command.request_fields[0]._data == bytearray([1]):  # type: ignore  # It's not a `Field` but a `LiteralBytesField`
+            if instruction._data == bytearray([1]):
                 information = []
                 for module_id in range(global_configuration.number_of_input_modules):
                     input_byte = 0
@@ -208,6 +218,9 @@ class DummyCommunicator(object):
                             input_byte |= (1 << entry_id)
                     information.append(input_byte)
                 return {'type': 1, 'information': information}
+            if instruction._data == bytearray([2]):
+                serial_number = bytearray([20, 1, 1, 0, 0, 0, 1])
+                return {'type': 1, 'serial_number': serial_number, 'production_test_result': 0xff}
         if command.instruction == b'OD':
             output_id = fields['device_nr']
             output_state = self._output_states.get(output_id, {})
@@ -218,6 +231,39 @@ class DummyCommunicator(object):
                     'timer_type': output_state.get('timer_type', 0), 'timer_type_standard': 0,
                     'timer': output_state.get('timer', 0), 'timer_standard': 0,
                     'group_action': 255, 'dali_output': 255, 'output_lock': 0}
+        if command.instruction == b'SI':
+            global_configuration = GlobalConfiguration()
+            values = [None] * 8  # type: List[Any]
+            instruction = command.request_fields[1]
+            if instruction._data == bytearray([0]):
+                if global_configuration.number_of_sensor_modules:
+                    values[0] = 21.5
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+            if instruction._data == bytearray([1]):
+                if global_configuration.number_of_sensor_modules:
+                    values[0] = 50.0
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+            if instruction._data == bytearray([2]):
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+            if instruction._data == bytearray([3]):
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+            if instruction._data == bytearray([4]):
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+            if instruction._data == bytearray([5]):
+                return {'module_nr': fields['module_nr'],
+                        'values': values}
+        if command.instruction == b'tR':
+            sensornr = 'sensornr'
+            return {'sensornr': sensornr,
+                    'setpoint': 20.5,
+                    'mode': 1,
+                    'temperature': 20.5,
+                    'humidity': 50}
 
         logger.info('Got do_command({0}, {1}, {2}, {3})'.format(command, fields, timeout, bypass_blockers))
         return {}
@@ -278,6 +324,16 @@ class DummyCommunicator(object):
                 # Process press
                 self._process_input_press(basic_action.device_nr, pressed)
                 return
+        if basic_action.action_type == 10:
+            if basic_action.action == 0:
+                self._process_shutter_action(basic_action.device_nr, ShutterEnums.State.STOPPED)
+                return
+            if basic_action.action == 1:
+                self._process_shutter_action(basic_action.device_nr, ShutterEnums.State.GOING_UP)
+                return
+            if basic_action.action == 2:
+                self._process_shutter_action(basic_action.device_nr, ShutterEnums.State.GOING_DOWN)
+                return
         if basic_action.action_type == 19 and basic_action.action == 0:
             # Execute the group action's individual actions
             group_action = GroupActionController.load_group_action(basic_action.device_nr)
@@ -304,6 +360,28 @@ class DummyCommunicator(object):
             if not pressed and release_action.in_use:
                 self._process_basic_action(release_action)
 
+    def _process_shutter_action(self, shutter_id, state):
+        shutter = ShutterConfiguration(shutter_id)
+        if state == ShutterEnums.State.STOPPED:
+            outputs = [(shutter.outputs.output_0, False), (shutter.outputs.output_1, False)]
+        if state == ShutterEnums.State.GOING_UP:
+            outputs = [(shutter.outputs.output_0, True), (shutter.outputs.output_1, False)]
+        if state == ShutterEnums.State.GOING_DOWN:
+            outputs = [(shutter.outputs.output_0, False), (shutter.outputs.output_1, True)]
+
+        for output_id, output_state in outputs:
+            new_state = self._output_states.get(output_id, {})
+            new_state.update({'state': output_state})
+            # Send event
+            self._send_event(bytearray([0, 1 if new_state.get('state') else 0]) +  # action and type
+                             self._word_helper.encode(output_id) +  # device_nr
+                             bytearray([new_state.get('dimmer', 100),
+                                        new_state.get('timer_type', 0)]) +  # data 0 + 1
+                             self._word_helper.encode(new_state.get('timer', 0)))  # data 2 + 3
+        event_data = {'id': shutter_id, 'status': state}
+        master_event = MasterEvent(event_type=MasterEvent.Types.SHUTTER_CHANGE, data=event_data)
+        self._pubsub.publish_master_event(PubSub.MasterTopics.SHUTTER, master_event)
+
     def _send_event(self, event_payload):
         """
         Finds the correct consumer(s) and let them consume the event
@@ -360,3 +438,6 @@ class MasterCoreDummyController(MasterCoreController):
                         instance = klass.deserialize(entry)
                         instance.save()
         super(MasterCoreDummyController, self).start()
+
+    def cold_reset(self, power_on=True):
+        pass
diff --git a/src/gateway/hal/master_controller_dummy.py b/src/gateway/hal/master_controller_dummy.py
index 91b8bb51..eaa7803a 100644
--- a/src/gateway/hal/master_controller_dummy.py
+++ b/src/gateway/hal/master_controller_dummy.py
@@ -23,12 +23,12 @@ from datetime import datetime
 from gateway.dto import DimmerConfigurationDTO, GlobalFeedbackDTO, \
     GroupActionDTO, InputDTO, InputStatusDTO, MasterSensorDTO, ModuleDTO, \
     OutputDTO, OutputStatusDTO, PulseCounterDTO, PumpGroupDTO, ShutterDTO, \
-    ShutterGroupDTO, ThermostatAircoStatusDTO, ThermostatDTO
+    ShutterGroupDTO, ThermostatDTO
 from gateway.exceptions import UnsupportedException
 from gateway.hal.master_controller import MasterController
 
 if False:  # MYPY
-    from typing import Any, Dict, List, Literal, Optional, Tuple, Set
+    from typing import Any, Dict, Iterable, List, Literal, Optional, Tuple, Set
     from plugins.base import PluginController
 
 logger = logging.getLogger(__name__)
@@ -104,8 +104,8 @@ class MasterDummyController(MasterController):
                 'hw_version': 0}
 
     def get_backup(self):
-        # type: () -> bytearray
-        return bytearray([255, 255, 255, 255, 255, 255, 255, 255])
+        # type: () -> Iterable[bytearray]
+        yield bytearray([255, 255, 255, 255, 255, 255, 255, 255])
 
     def set_datetime(self, dt):
         # type: (datetime) -> None
@@ -181,10 +181,6 @@ class MasterDummyController(MasterController):
         # type: () -> List[ThermostatDTO]
         return []
 
-    def read_airco_status_bits(self):
-        # type: () -> Dict[str,Any]
-        return {}
-
     def get_pump_group_configurations(self, fields=None):
         # type: (Optional[List[str]]) -> List[Dict[str,Any]]
         return []
@@ -249,10 +245,6 @@ class MasterDummyController(MasterController):
         # type: (str, str, str, str) -> Optional[str]
         return None
 
-    def load_airco_status(self):
-        # type: () -> ThermostatAircoStatusDTO
-        return ThermostatAircoStatusDTO({})
-
     def load_dimmer_configuration(self):
         # type: () -> DimmerConfigurationDTO
         return DimmerConfigurationDTO()  # All default values
diff --git a/src/gateway/hvac_controller.py b/src/gateway/hvac_controller.py
new file mode 100644
index 00000000..d3ee79e7
--- /dev/null
+++ b/src/gateway/hvac_controller.py
@@ -0,0 +1,57 @@
+# Copyright (C) 2020 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+import logging
+from gateway.base_controller import BaseController
+from master.core.core_api import CoreAPI
+from ioc import INJECTED, Inject, Injectable, Singleton
+
+logger = logging.getLogger(__name__)
+
+
+@Injectable.named('hvac_controller')
+@Singleton
+class HvacController(BaseController):
+    """
+    Controls everything related to hvac temperature setpoint.
+
+    Important assumptions:
+    * A HVAC can heat and cool
+    * The setpoint (float) is the temperature setpoint for the water supplied by the hvac.
+    * A setpoint can be set for heating and one for cooling. Mode 0 indicates heating, 1 means cooling
+
+    """
+    @Inject
+    def __init__(self, master_communicator=INJECTED):
+        self._master_communicator = master_communicator
+
+    def save_hvac_setpoint(self, sensornr, setpoint, mode):  
+        '''
+        type: (float) -> SetpointDTO, (0/1) -> heating/cooling
+        '''
+        response = self._master_communicator.do_command(command=CoreAPI.write_hvac_setpoint(),
+                                                    fields={'sensornr': sensornr,
+                                                            'setpoint': setpoint,
+                                                            'mode': mode})
+        return response
+
+    def load_hvac_setpoint(self, sensornr):
+        '''
+        type: (float) -> SetpointDTO, (0/1) -> heating/cooling
+        '''
+        response = self._master_communicator.do_command(command=CoreAPI.read_hvac_setpoint(),
+                                                    fields={'sensornr': sensornr})
+
+        return response
+
diff --git a/src/gateway/initialize.py b/src/gateway/initialize.py
index 01d46c5d..b0ad71c5 100644
--- a/src/gateway/initialize.py
+++ b/src/gateway/initialize.py
@@ -60,9 +60,6 @@ from platform_utils import Platform, System
 from serial_utils import RS485
 
 
-
-
-
 if False:  # MYPY
     from typing import Any, Optional
     from gateway.hal.master_controller import MasterController
@@ -98,6 +95,8 @@ def initialize(message_client_name):
 def lock_file(file):
     # type: (str) -> Any
     with open(file, 'a+') as fd:
+        # BE-515 upgrade from python 2 to 3 requires seek(0)
+        fd.seek(0)
         fcntl.flock(fd, fcntl.LOCK_EX)
         try:
             yield fd
@@ -204,18 +203,20 @@ def setup_target_platform(target_platform, message_client_name):
     # abstract implementations depending on e.g. the platform (classic vs core) or certain settings (classic
     # thermostats vs gateway thermostats)
     from plugins import base
-    from gateway import (metrics_controller, webservice, scheduling_controller, metrics_collector,
+    from gateway import (metrics_controller, hvac_controller, webservice, scheduling_controller, metrics_collector,
                          maintenance_controller, user_controller, pulse_counter_controller,
                          metrics_caching, watchdog, output_controller, room_controller, sensor_controller,
                          shutter_controller, system_controller, group_action_controller, module_controller,
-                         ventilation_controller, energy_module_controller, update_controller)
+                         ventilation_controller, energy_module_controller, notification_controller)
+    from gateway.updates import update_controller
     from gateway.api.V1.webservice import webservice as webservice_v1
     from cloud import events
-    _ = (metrics_controller, webservice, scheduling_controller, metrics_collector,
+    _ = (metrics_controller, hvac_controller, webservice, scheduling_controller, metrics_collector,
          maintenance_controller, base, events, user_controller,
          pulse_counter_controller, metrics_caching, watchdog, output_controller, room_controller,
          sensor_controller, shutter_controller, system_controller, group_action_controller, module_controller,
-         ventilation_controller, webservice_v1, energy_module_controller, update_controller)
+         ventilation_controller, webservice_v1, energy_module_controller, update_controller,
+         notification_controller)
 
     # V1 api
     # This will parse all the V1 api files that are included in the __init__.py file in the
diff --git a/src/gateway/mappers/screen.py b/src/gateway/mappers/screen.py
new file mode 100644
index 00000000..5364556e
--- /dev/null
+++ b/src/gateway/mappers/screen.py
@@ -0,0 +1,58 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+"""
+Screen Mapper
+"""
+from __future__ import absolute_import
+
+import logging
+
+from gateway.dto import ScreenDTO
+from gateway.models import Screen
+from gateway.mappers.room import RoomMapper
+
+if False:  # MYPY
+    from typing import Any
+
+logger = logging.getLogger(__name__)
+
+
+class ScreenMapper(object):
+    def __init__(self, db):
+        self._db = db
+        self._room_mapper = RoomMapper(self._db)
+
+    def orm_to_dto(self, screen):  # type: (Screen) -> ScreenDTO
+        return ScreenDTO(id=screen.id,
+                         external_id=screen.external_id,
+                         name=screen.name,
+                         type=screen.type,
+                         room=(self._room_mapper.orm_to_dto(screen.room)
+                               if screen.room is not None else None),
+                         translational_steps=screen.translational_steps,
+                         rotational_steps=screen.rotational_steps)
+
+    def dto_to_orm(self, screen_dto):  # type: (ScreenDTO) -> Screen
+        screen = self._db.query(Screen).filter_by(id=screen_dto.id).one()  # type: Screen
+        for field in ['name', 'translational_steps', 'rotational_steps']:
+            if field in screen_dto.loaded_fields:
+                value = getattr(screen_dto, field)  # type: Any
+                if field in ['translational_steps', 'rotational_steps'] and value is not None:
+                    value = max(0, int(value))
+                    if value == 0:
+                        value = None
+                setattr(screen, field, value)
+        return screen
diff --git a/src/gateway/mappers/sensor.py b/src/gateway/mappers/sensor.py
index a33e894b..b15d501e 100644
--- a/src/gateway/mappers/sensor.py
+++ b/src/gateway/mappers/sensor.py
@@ -20,8 +20,9 @@ from __future__ import absolute_import
 
 import logging
 
-from gateway.dto.sensor import MasterSensorDTO, SensorDTO, SensorSourceDTO
-from gateway.models import Database, Plugin, Room, Sensor
+from gateway.dto import MasterSensorDTO, SensorDTO, SourceDTO
+from gateway.enums import SensorEnums, Source
+from gateway.models import Room, Sensor
 
 if False:  # MYPY
     from typing import Optional
@@ -36,11 +37,9 @@ class SensorMapper(object):
         self._db = db
 
     def orm_to_dto(self, sensor):  # type: (Sensor) -> SensorDTO
-        source_dto = SensorSourceDTO(type=sensor.source)
-        plugin = sensor.plugin
-        if sensor.source == Sensor.Sources.PLUGIN and plugin is not None:
-            source_dto.id = plugin.id
-            source_dto.name = plugin.name
+        source_dto = SourceDTO(source=sensor.source)
+        if sensor.source == Source.PLUGIN and sensor.plugin:
+            source_dto.source_id = sensor.plugin.id
         room = sensor.room.number if sensor.room else None
         return SensorDTO(sensor.id,
                          source=source_dto,
@@ -76,7 +75,7 @@ class SensorMapper(object):
                 master_dto.name = sensor_dto.name
             if 'virtual' in sensor_dto.loaded_fields:
                 master_dto.virtual = sensor_dto.virtual
-            if 'offset' in sensor_dto.loaded_fields and sensor_dto.physical_quantity == Sensor.PhysicalQuantities.TEMPERATURE:
+            if 'offset' in sensor_dto.loaded_fields and sensor_dto.physical_quantity == SensorEnums.PhysicalQuantities.TEMPERATURE:
                 master_dto.offset = sensor_dto.offset
             return master_dto
         else:
diff --git a/src/gateway/mappers/thermostat.py b/src/gateway/mappers/thermostat.py
index 41e750a1..18d9d6f9 100644
--- a/src/gateway/mappers/thermostat.py
+++ b/src/gateway/mappers/thermostat.py
@@ -20,11 +20,10 @@ import datetime
 import logging
 import time
 
-from sqlalchemy import func, select
-
 from gateway.dto import ThermostatDTO, ThermostatScheduleDTO
+from gateway.enums import SensorEnums
 from gateway.models import DaySchedule, Output, Preset, Room, Sensor, \
-    Thermostat, ThermostatGroup, Valve, ValveToThermostatAssociation
+    Thermostat, ThermostatGroup, Valve, IndoorLinkValves
 
 if False:  # MYPY
     from typing import Any, Dict, Iterator, List, Literal, Optional, Tuple
@@ -112,17 +111,18 @@ class ThermostatMapper(object):
                 thermostat.sensor = None  # type: ignore
             else:
                 thermostat.sensor = self._db.get(Sensor, thermostat_dto.sensor)
-        if thermostat.sensor and thermostat.sensor.physical_quantity != Sensor.PhysicalQuantities.TEMPERATURE:
+        if thermostat.sensor and thermostat.sensor.physical_quantity != SensorEnums.PhysicalQuantities.TEMPERATURE:
             raise ValueError('Invalid <Sensor {}> {} for thermostats'.format(thermostat.sensor.id, thermostat.sensor.physical_quantity))
         return thermostat
 
-    def get_valve_links(self, thermostat_dto, mode):  # type: (ThermostatDTO, str) -> Tuple[List[ValveToThermostatAssociation], List[ValveToThermostatAssociation]]
+    def get_valve_links(self, thermostat_dto, mode):  # type: (ThermostatDTO, str) -> Tuple[List[IndoorLinkValves], List[IndoorLinkValves]]
+        # in the return tuple, the first List contains updated IndoorLinkValves and the second List contains removed IndoorLinkValves
         thermostat = self._db.query(Thermostat) \
             .where(Thermostat.number == thermostat_dto.id) \
             .one()  # type: Thermostat
 
         outputs = {x.number: x for x in self._db.query(Output).join(Valve, isouter=True)}  # type: Dict[int,Output]
-        valve_associations = iter(getattr(thermostat, '{0}_valve_associations'.format(mode))) # type: Iterator[ValveToThermostatAssociation]
+        valve_associations = iter(getattr(thermostat, '{0}_valve_associations'.format(mode))) # type: Iterator[IndoorLinkValves]
 
         links = []
         for field, priority in [('output0', 0),
@@ -135,16 +135,15 @@ class ThermostatMapper(object):
                         valve = Valve(output=output, name='Valve (output {0})'.format(output.number))
                     association = next(valve_associations, None)
                     if association is None:
-                        links.append(ValveToThermostatAssociation(
-                            thermostat=thermostat,
+                        links.append(IndoorLinkValves(
+                            thermostat_link_id=thermostat.id,
                             valve=valve,
-                            priority=priority,
                             mode=mode,
                         ))
                     else:
-                        if association.valve_id != valve.id or association.priority != priority:
+                        # if association.valve_id != valve.id or association.priority != priority: (this is the old if)
+                        if association.valve_id != valve.id:
                             association.valve = valve
-                            association.priority = priority
                             links.append(association)
         return links, list(valve_associations)
 
diff --git a/src/gateway/mappers/ventilation.py b/src/gateway/mappers/ventilation.py
index a5565c61..e82158e4 100644
--- a/src/gateway/mappers/ventilation.py
+++ b/src/gateway/mappers/ventilation.py
@@ -20,11 +20,11 @@ from __future__ import absolute_import
 
 import logging
 
-from gateway.dto.ventilation import VentilationDTO, VentilationSourceDTO
-from gateway.models import Plugin, Ventilation
+from gateway.dto import PluginDTO, SourceDTO, VentilationDTO
+from gateway.models import Plugin, Room, Ventilation
 
 if False:  # MYPY
-    from typing import Any, Dict, List
+    from typing import Any, Dict, List, Optional
 
 logger = logging.getLogger(__name__)
 
@@ -35,15 +35,18 @@ class VentilationMapper(object):
 
     def orm_to_dto(self, orm_object):
         # type: (Ventilation) -> VentilationDTO
-        source_dto = VentilationSourceDTO(orm_object.source)
+        source_dto = SourceDTO(source=orm_object.source)
+        plugin_dto = None
         if orm_object.source == Ventilation.Sources.PLUGIN and orm_object.plugin:
-            source_dto.id = orm_object.plugin.id
-            source_dto.name = orm_object.plugin.name
+            plugin_dto = PluginDTO(orm_object.plugin.id, name=orm_object.plugin.name)
+            source_dto.source_id = plugin_dto.id
+        room_id = orm_object.room.number if orm_object.room else None
         return VentilationDTO(orm_object.id,
                               source=source_dto,
+                              plugin=plugin_dto,
                               external_id=orm_object.external_id,
                               name=orm_object.name,
-                              room=orm_object.room_id,
+                              room=room_id,
                               amount_of_levels=orm_object.amount_of_levels,
                               device_vendor=orm_object.device_vendor,
                               device_type=orm_object.device_type,
@@ -56,7 +59,10 @@ class VentilationMapper(object):
         if 'name' in ventilation_dto.loaded_fields:
             ventilation.name = ventilation_dto.name
         if 'room' in ventilation_dto.loaded_fields:
-            ventilation.room_id = ventilation_dto.room
+            room = None  # type: Optional[Room]
+            if ventilation_dto.room is not None:
+                room = self._db.query(Room).filter_by(number=ventilation_dto.room).one()
+            ventilation.room = room
         if 'amount_of_levels' in ventilation_dto.loaded_fields:
             ventilation.amount_of_levels = ventilation_dto.amount_of_levels
         if 'device_vendor' in ventilation_dto.loaded_fields and 'device_type' in ventilation_dto.loaded_fields:
diff --git a/src/gateway/metrics_collector.py b/src/gateway/metrics_collector.py
index 5460b1f4..07003582 100644
--- a/src/gateway/metrics_collector.py
+++ b/src/gateway/metrics_collector.py
@@ -461,7 +461,7 @@ class MetricsCollector(object):
                                           timestamp=now)
                     assert self._plugin_controller
                     for plugin in self._plugin_controller.get_plugins():
-                        plugin_values = {'queue_length': plugin.get_queue_length()}
+                        plugin_values = {}
                         if plugin.name in plugin_system_metrics:
                             plugin_values.update(plugin_system_metrics[plugin.name])
                         self._enqueue_metrics(metric_type=metric_type,
diff --git a/src/gateway/metrics_controller.py b/src/gateway/metrics_controller.py
index 658f0138..8420f706 100644
--- a/src/gateway/metrics_controller.py
+++ b/src/gateway/metrics_controller.py
@@ -21,25 +21,24 @@ from __future__ import absolute_import
 import logging
 import re
 import time
-from collections import deque
+from collections import deque, defaultdict
 
 import six
 
 from bus.om_bus_events import OMBusEvents
 from gateway.daemon_thread import DaemonThread, DaemonThreadWait
-from gateway.models import Config
+from gateway.dto import SourceDTO
+from gateway.enums import MetricsEnums
+from gateway.models import Database, Config, Plugin
 from ioc import INJECTED, Inject, Injectable, Singleton
-from platform_utils import System
 
-if False:  # MYPY
-    from typing import Any, Dict, Optional, List
-    from cloud.cloud_api_client import CloudAPIClient
-    from gateway.config_controller import ConfigurationController
-    from gateway.metrics_caching import MetricsCacheController
-    from gateway.metrics_collector import MetricsCollector
-    from plugins.base import PluginController
+from typing import Any, Dict, Optional, List
+from cloud.cloud_api_client import CloudAPIClient
+from gateway.metrics_caching import MetricsCacheController
+from gateway.metrics_collector import MetricsCollector
+from plugins.base import PluginController
 
-logger = logging.getLogger(__name__)
+global_logger = logging.getLogger(__name__)
 
 
 class MetricsDistributeFailed(Exception):
@@ -60,12 +59,11 @@ class MetricsController(object):
         self._plugin_controller = plugin_controller
         self._metrics_collector = metrics_collector
         self._metrics_cache_controller = metrics_cache_controller
-        self._persist_counters = {}  # type: Dict
-        self._buffer_counters = {}  # type: Dict
-        self.definitions = {}  # type: Dict
-        self._definition_filters = {'source': {}, 'metric_type': {}}  # type: Dict
+        self._persist_counters = {}  # type: Dict[str, Any]
+        self._buffer_counters = {}  # type: Dict[str, Any]
+        self.definitions = {}  # type: Dict[str, Any]
+        self._definition_filters = {'source': {}, 'metric_type': {}}  # type: Dict[str, Dict[str, Any]]
         self._metrics_cache = {}  # type: Dict
-        self._collector_plugins = None  # type: Optional[DaemonThread]
         self._collector_openmotics = None  # type: Optional[DaemonThread]
         self._internal_stats = None
         self._distributor_plugins = None  # type: Optional[DaemonThread]
@@ -89,6 +87,10 @@ class MetricsController(object):
                             'time_ago_send': 0,
                             'time_ago_try': 0}
 
+        self._plugin_controller.metrics_callback_action = self._plugin_metrics_callback_action
+        self._forwarding_metrics_subscriptions = defaultdict(lambda: dict())  # type: Dict[SourceDTO, Dict[str, Dict[str, Any]]]
+        self._plugin_name_cache = {}  # type: Dict[SourceDTO, str]
+
         # Metrics generated by the Metrics_Controller_ are also defined in the collector. Trying to get them in one place.
         for definition in self._metrics_collector.get_definitions():
             self.definitions.setdefault('OpenMotics', {})[definition['type']] = definition
@@ -98,10 +100,6 @@ class MetricsController(object):
 
     def start(self):
         self._refresh_cloud_interval()
-        self._collector_plugins = DaemonThread(name='metricplugincoll',
-                                               target=self._collect_plugins,
-                                               interval=1)
-        self._collector_plugins.start()
         self._collector_openmotics = DaemonThread(name='metricplugindist',
                                                   target=self._collect_openmotics,
                                                   interval=1)
@@ -117,8 +115,6 @@ class MetricsController(object):
 
     def stop(self):
         # type: () -> None
-        if self._collector_plugins is not None:
-            self._collector_plugins.stop()
         if self._collector_openmotics is not None:
             self._collector_openmotics.stop()
         if self._distributor_plugins is not None:
@@ -127,7 +123,7 @@ class MetricsController(object):
             self._distributor_openmotics.stop()
 
     def set_cloud_interval(self, metric_type, interval, save=True):
-        logger.info('Setting cloud interval {0}_{1}'.format(metric_type, interval))
+        global_logger.info('Setting cloud interval {0}_{1}'.format(metric_type, interval))
         self._metrics_collector.set_cloud_interval(metric_type, interval)
         if save:
             Config.set_entry('cloud_metrics_interval|{0}'.format(metric_type), interval)
@@ -147,7 +143,7 @@ class MetricsController(object):
         if filter_type == 'source':
             results = []
             re_filter = None if metric_filter is None else re.compile(metric_filter)
-            for source in self.definitions.keys():
+            for source in list(self.definitions.keys()):
                 if re_filter is None or re_filter.match(source):
                     results.append(source)
             results = set(results)
@@ -156,7 +152,7 @@ class MetricsController(object):
         if filter_type == 'metric_type':
             results = []
             re_filter = None if metric_filter is None else re.compile(metric_filter)
-            for source in self.definitions.keys():
+            for source in list(self.definitions.keys()):
                 for metric_type in self.definitions.get(source, []):
                     if re_filter is None or re_filter.match(metric_type):
                         results.append(metric_type)
@@ -164,7 +160,8 @@ class MetricsController(object):
             self._definition_filters['metric_type'][metric_filter] = results
             return results
 
-    def set_plugin_definitions(self, definitions):
+    def set_plugin_definitions(self, plugin_name, plugin_definitions):
+        # type: (str, List[Dict[str,Any]]) -> None
         # {
         #     "type": "energy",
         #     "tags": ["device", "id"],
@@ -175,56 +172,49 @@ class MetricsController(object):
         # }
         required_keys = {'type': six.string_types,
                          'metrics': list,
-                         'tags': list}
+                         'tags': list}  # type: Dict[str, Any]
         metrics_keys = {'name': six.string_types,
                         'description': six.string_types,
                         'type': six.string_types,
-                        'unit': six.string_types}
+                        'unit': six.string_types}  # type: Dict[str, Any]
         expected_plugins = []
-        for plugin, plugin_definitions in six.iteritems(definitions):
-            log = self._plugin_controller.get_logger(plugin)
-            for definition in plugin_definitions:
-                definition_ok = True
-                for key, key_type in required_keys.items():
-                    if key not in definition:
-                        log('Definitions should contain keys: {0}'.format(', '.join(list(required_keys.keys()))))
-                        definition_ok = False
-                        break
-                    if not isinstance(definition[key], key_type):
-                        log('Definitions key {0} should be of type {1}'.format(key, key_type))
-                        definition_ok = False
-                        break
-                    if key == 'metrics':
-                        for metric_definition in definition[key]:
-                            if definition_ok is False:
+        logger = self._plugin_controller._get_logger_for_plugin(plugin_name)
+        for definition in plugin_definitions:
+            definition_ok = True
+            for key, key_type in required_keys.items():
+                if key not in definition:
+                    logger.error('Definitions should contain keys: {0}'.format(', '.join(required_keys.keys())))
+                    definition_ok = False
+                    break
+                if not isinstance(definition[key], key_type):
+                    logger.error('Definitions key {0} should be of type {1}'.format(key, key_type))
+                    definition_ok = False
+                    break
+                if key == 'metrics':
+                    for metric_definition in definition[key]:
+                        if definition_ok is False:
+                            break
+                        if not isinstance(metric_definition, dict):
+                            logger.error('Metric definitions should be dictionaries')
+                            definition_ok = False
+                            break
+                        for mkey, mkey_type in metrics_keys.items():
+                            if mkey not in metric_definition:
+                                logger.error('Metric definitions should contain keys: {0}'.format(', '.join(list(metrics_keys.keys()))))
+                                definition_ok = False
                                 break
-                            if not isinstance(metric_definition, dict):
-                                log('Metric definitions should be dictionaries')
+                            if not isinstance(metric_definition[mkey], mkey_type):
+                                logger.error('Metric definitions key {0} should be of type {1}'.format(mkey, mkey_type))
                                 definition_ok = False
                                 break
-                            for mkey, mkey_type in metrics_keys.items():
-                                if mkey not in metric_definition:
-                                    log('Metric definitions should contain keys: {0}'.format(', '.join(list(metrics_keys.keys()))))
-                                    definition_ok = False
-                                    break
-                                if not isinstance(metric_definition[mkey], mkey_type):
-                                    log('Metric definitions key {0} should be of type {1}'.format(mkey, mkey_type))
-                                    definition_ok = False
-                                    break
-                    if definition_ok is False:
-                        break
-                if definition_ok is True:
-                    expected_plugins.append(plugin)
-                    self.definitions.setdefault(plugin, {})[definition['type']] = definition
-                    settings = MetricsController._parse_definition(definition)
-                    self._persist_counters.setdefault(plugin, {})[definition['type']] = settings['persist']
-                    self._buffer_counters.setdefault(plugin, {})[definition['type']] = settings['buffer']
-        for source in self.definitions.keys():
-            # Remove plugins from the self.definitions dict that are not found anymore
-            if source != 'OpenMotics' and source not in expected_plugins:
-                self.definitions.pop(source, None)
-                self._persist_counters.pop(source, None)
-                self._buffer_counters.pop(source, None)
+                if definition_ok is False:
+                    break
+            if definition_ok is True:
+                expected_plugins.append(plugin_name)
+                self.definitions.setdefault(plugin_name, {})[definition['type']] = definition
+                settings = MetricsController._parse_definition(definition)
+                self._persist_counters.setdefault(plugin_name, {})[definition['type']] = settings['persist']
+                self._buffer_counters.setdefault(plugin_name, {})[definition['type']] = settings['buffer']
         self._definition_filters['source'] = {}
         self._definition_filters['metric_type'] = {}
 
@@ -308,6 +298,7 @@ class MetricsController(object):
         metric_source = metric['source']
 
         if not self._needs_upload_to_cloud(metric):
+            global_logger.debug('Discarding metric %s', metric_type)
             return
 
         if metric_source == 'OpenMotics':
@@ -378,7 +369,7 @@ class MetricsController(object):
                 if self._throttled_down:
                     self._refresh_cloud_interval()
             except Exception as ex:
-                logger.exception('Error uploading metrics to cloud: {0}'.format(ex))
+                global_logger.exception('Error uploading metrics to cloud: {0}'.format(ex))
                 if time_ago_send > 60 * 60:
                     # Decrease metrics rate, but at least every 2 hours
                     # Decrease cloud try interval, but at least every hour
@@ -442,7 +433,31 @@ class MetricsController(object):
                                                                            timestamp=metric['timestamp'])
             metric['values'][counter] = counter_type(counter_value)
 
-    def _collect_plugins(self):
+    def _plugin_metrics_callback_action(self, source, action, action_payload):
+        # type: (SourceDTO, str, Any) -> Any
+        if action == MetricsEnums.CallbackAction.SUBSCRIBE_METRICS:
+            identifier = action_payload['identifier']
+            # Store subscription
+            self._forwarding_metrics_subscriptions[source][identifier] = action_payload
+            # Update plugin intervals
+            intervals = []
+            for subscription in self._forwarding_metrics_subscriptions.values():
+                for info in subscription.values():
+                    intervals.append(info)
+            self._metrics_collector.set_plugin_intervals(plugin_intervals=intervals)
+        elif action == MetricsEnums.CallbackAction.DELIVER_METRICS:
+            if not source.is_plugin:
+                raise RuntimeError('Only plugins should deliver metrics here')
+            if source not in self._plugin_name_cache:
+                with Database.get_session() as db:
+                    plugin_name = db.query(Plugin).filter_by(id=source.source_id).one().name
+                self._plugin_name_cache[source] = plugin_name
+            plugin_name = self._plugin_name_cache[source]
+            for metric in action_payload['metrics']:
+                metric['source'] = plugin_name
+                self._deliver_plugin_metric(metric=metric)
+
+    def _deliver_plugin_metric(self, metric):
         """
         > example_definition = {"type": "energy",
         >                       "tags": ["device", "id"],
@@ -457,55 +472,36 @@ class MetricsController(object):
         >                            "id": 0},
         >                   "values": {"power": 1234}}
         """
-        start = time.time()
-        for metric in self._plugin_controller.collect_metrics():
-            # Validation, part 1
-            source = metric['source']
-            log = self._plugin_controller.get_logger(source)
-            required_keys = {'type': six.string_types,
-                             'timestamp': (float, int),
-                             'values': dict,
-                             'tags': dict}
-            metric_ok = True
-            for key, key_type in required_keys.items():
-                if key not in metric:
-                    log('Metric should contain keys {0}'.format(', '.join(list(required_keys.keys()))))
-                    metric_ok = False
-                    break
-                if not isinstance(metric[key], key_type):
-                    log('Metric key {0} should be of type {1}'.format(key, key_type))
-                    metric_ok = False
-                    break
-            if metric_ok is False:
-                continue
-            # Get metric definition
-            definition = self.definitions.get(metric['source'], {}).get(metric['type'])
-            if definition is None:
-                log('No metric definitions for source {0} and type {1}'.format(metric['source'], metric['type']))
-                continue
-            # Validate metric based on definition
-            if len(metric['tags']) == 0:
-                log('At least one metric tag should be defined')
-                metric_ok = False
-            else:
-                for tag_name, tag_value in six.iteritems(metric['tags']):  # tags are optional but should be in the definition
-                    if tag_name not in definition['tags']:
-                        log('Metric tag {0} should be defined'.format(tag_name))
-                        metric_ok = False
-                    if tag_value is None:
-                        log('Metric tag {0} should not be None'.format(tag_name))
-                        metric_ok = False
-            metric_values = set(metric['values'].keys())
-            if len(metric_values) == 0:
-                log('Metric should have at least one value')
-                metric_ok = False
-            unknown_metrics = metric_values - set([mdef['name'] for mdef in definition['metrics']])
-            if len(unknown_metrics) > 0:
-                log('Metric contains unknown values: {0}'.format(', '.join(unknown_metrics)))
-                metric_ok = False
-            if metric_ok is False:
-                continue
-            self._put(metric)
+        # Validation, part 1
+        required_keys = {'type': six.string_types,
+                         'timestamp': (float, int),
+                         'values': dict,
+                         'tags': dict}  # type: Dict[str,Any]
+        for key, key_type in required_keys.items():
+            if key not in metric:
+                raise RuntimeError('Metric should contain keys {0}'.format(', '.join(list(required_keys.keys()))))
+            if not isinstance(metric[key], key_type):
+                raise RuntimeError('Metric key {0} should be of type {1}'.format(key, key_type))
+        # Get metric definition
+        definition = self.definitions.get(metric['source'], {}).get(metric['type'])
+        if definition is None:
+            raise RuntimeError('No metric definitions for source {0} and type {1}'.format(metric['source'], metric['type']))
+        # Validate metric based on definition
+        if len(metric['tags']) == 0:
+            raise RuntimeError('At least one metric tag should be defined')
+        else:
+            for tag_name, tag_value in six.iteritems(metric['tags']):  # tags are optional but should be in the definition
+                if tag_name not in definition['tags']:
+                    raise RuntimeError('Metric tag {0} should be defined'.format(tag_name))
+                if tag_value is None:
+                    raise RuntimeError('Metric tag {0} should not be None'.format(tag_name))
+        metric_values = set(metric['values'].keys())
+        if len(metric_values) == 0:
+            raise RuntimeError('Metric should have at least one value')
+        unknown_metrics = metric_values - set([mdef['name'] for mdef in definition['metrics']])
+        if len(unknown_metrics) > 0:
+            raise RuntimeError('Metric contains unknown values: {0}'.format(', '.join(unknown_metrics)))
+        self._put(metric)
 
     def _collect_openmotics(self):
         # type: () -> None
@@ -515,20 +511,42 @@ class MetricsController(object):
 
     def _distribute_plugins(self):
         try:
+            # Load metrics
             metrics = []
             try:
                 while len(metrics) < 250:
                     metrics.append(self.metrics_queue_plugins.pop())
             except IndexError:
                 pass
-            if metrics:
-                rates = self._plugin_controller.distribute_metrics(metrics)
-                for key, rate in six.iteritems(rates):
-                    if key not in self.outbound_rates:
-                        self.outbound_rates[key] = 0
-                    self.outbound_rates[key] += rate
-            else:
+            if not metrics:
                 raise DaemonThreadWait()
+
+            # Forward
+            rates = {'total': 0}
+            for source, subscription in self._forwarding_metrics_subscriptions.items():
+                try:
+                    for identifier, filters in subscription.items():
+                        metrics_to_deliver = []
+                        sources = self.get_filter('source', filters['source'])
+                        metrics_types = self.get_filter('metric_type', filters['metric_type'])
+                        for metric in metrics:
+                            if metric['source'] in sources and metric['type'] in metrics_types:
+                                metrics_to_deliver.append(metric)
+                                rate_key = '{0}.{1}'.format(metric['source'].lower(), metric['type'].lower())
+                                if rate_key not in rates:
+                                    rates[rate_key] = 0
+                                rates[rate_key] += 1
+                                rates['total'] += 1
+                        self._plugin_controller.execute_metric_action(action=MetricsEnums.Action.DELIVER_METRICS,
+                                                                      action_payload={'identifier': identifier,
+                                                                                      'metrics': metrics_to_deliver},
+                                                                      destination=source)
+                except Exception as ex:
+                    global_logger.error('Could not forward metrics to destination {0}: {1}'.format(source, ex))
+            for key, rate in six.iteritems(rates):
+                if key not in self.outbound_rates:
+                    self.outbound_rates[key] = 0
+                self.outbound_rates[key] += rate
         except DaemonThreadWait:
             raise
         except Exception as ex:
@@ -542,7 +560,7 @@ class MetricsController(object):
                 try:
                     receiver(metric)
                 except Exception as ex:
-                    logger.exception('error distributing metrics')
+                    global_logger.exception('error distributing metrics')
                     raise MetricsDistributeFailed('Error distributing metrics to internal receivers: {0}'.format(ex))
                 rate_key = '{0}.{1}'.format(metric['source'].lower(), metric['type'].lower())
                 if rate_key not in self.outbound_rates:
diff --git a/src/gateway/migrations/base_migrator.py b/src/gateway/migrations/base_migrator.py
index 057dd974..e918cade 100644
--- a/src/gateway/migrations/base_migrator.py
+++ b/src/gateway/migrations/base_migrator.py
@@ -33,7 +33,7 @@ class BaseMigrator(object):
         logger.log(level=level, msg=log_message)
 
     @classmethod
-    def migrate(cls):  # type: () -> None
+    def migrate(cls, fatal=False):  # type: (bool) -> None
         try:
             if cls.MIGRATION_KEY is None:
                 return
@@ -59,6 +59,8 @@ class BaseMigrator(object):
                 db.commit()
         except Exception:
             logger.exception('Unexpected error in {0}'.format(cls.__name__))
+            if fatal:
+                raise
 
     @classmethod
     def _migrate(cls):
diff --git a/src/gateway/migrations/defaults.py b/src/gateway/migrations/defaults.py
index 0444beaa..20e88a04 100644
--- a/src/gateway/migrations/defaults.py
+++ b/src/gateway/migrations/defaults.py
@@ -29,7 +29,7 @@ class DefaultsMigrator(BaseMigrator):
     MIGRATION_KEY = 'defaults'
 
     @classmethod
-    def migrate(cls):  # type: () -> None
+    def migrate(cls, fatal=False):  # type: (bool) -> None
         try:
             logger.info('Migrating ({0})...'.format(cls.__name__))
             with Database.get_session() as db:
@@ -38,6 +38,8 @@ class DefaultsMigrator(BaseMigrator):
             logger.info('Migrating ({0})... Done'.format(cls.__name__))
         except Exception:
             logger.exception('Unexpected error in {0}'.format(cls.__name__))
+            if fatal:
+                raise
 
     @classmethod
     def _seed_defaults(cls, db):  # type: (Any) -> None
diff --git a/src/gateway/migrations/thermostats.py b/src/gateway/migrations/thermostats.py
index 7f536910..bd8f4944 100644
--- a/src/gateway/migrations/thermostats.py
+++ b/src/gateway/migrations/thermostats.py
@@ -17,21 +17,31 @@ import logging
 import time
 from datetime import timedelta
 
+from gateway.enums import SensorEnums, Source
+from gateway.events import GatewayEvent
 from gateway.migrations.base_migrator import BaseMigrator
 from gateway.models import Database, DaySchedule, Feature, Output, \
-    OutputToThermostatGroupAssociation, Preset, Pump, PumpToValveAssociation, Room, Sensor, \
-    Thermostat, ThermostatGroup, Valve, ValveToThermostatAssociation, Session
+    Preset, Pump, PumpToValveAssociation, Room, Sensor, \
+    Thermostat, ThermostatGroup, Valve, IndoorLinkValves
+
+
+# removing OutputToThermostatGroupAssociation for transition period from thermostats V1 to V2
+# from gateway.models import OutputToThermostatGroupAssociation
+
+
 from ioc import INJECTED, Inject
 from master.classic import master_api
 from master.classic.eeprom_controller import CompositeDataType, EepromByte, \
     EepromCSV, EepromIBool, EepromId, EepromModel, EepromString, EepromTemp, \
     EepromTime, EextByte
 from platform_utils import Platform
+from logs import Logs
 
 if False:  # MYPY
     from typing import Any, List, Iterable, Tuple, Optional
     from master.classic.eeprom_controller import EepromController
     from master.classic.master_communicator import MasterCommunicator
+    from cloud.events import EventSender
 
 logger = logging.getLogger(__name__)
 
@@ -258,7 +268,10 @@ class ThermostatsMigrator(BaseMigrator):
     ]
 
     @classmethod
-    def _migrate(cls):
+    @Inject
+    def _migrate(cls, event_sender=INJECTED):
+        # type: (EventSender) -> None
+
         # Core(+) platforms only support gateway thermostats
         if Platform.get_platform() not in Platform.ClassicTypes:
             return
@@ -266,16 +279,17 @@ class ThermostatsMigrator(BaseMigrator):
         # Remove all existing gateway configuration
         with Database.get_session() as db:
             db.query(Thermostat).delete()
-            db.query(OutputToThermostatGroupAssociation).delete()
+            # db.query(OutputToThermostatGroupAssociation).delete()
             db.query(Pump).delete()
             db.query(Valve).delete()
+            db.query(Preset).delete()
 
-            thermostat_group = db.query(ThermostatGroup).limit(1).one()
+            thermostat_group = db.query(ThermostatGroup).one()
 
             for eeprom_object in cls._read_heating_configuration():
-                cls._migrate_thermostat(db, thermostat_group, ThermostatGroup.Modes.HEATING, eeprom_object)
+                cls._migrate_thermostat(db, thermostat_group, ThermostatGroup.Modes.HEATING, eeprom_object, event_sender)
             for eeprom_object in cls._read_cooling_configuration():
-                cls._migrate_thermostat(db, thermostat_group, ThermostatGroup.Modes.COOLING, eeprom_object)
+                cls._migrate_thermostat(db, thermostat_group, ThermostatGroup.Modes.COOLING, eeprom_object, event_sender)
 
             for eeprom_object in cls._read_pump_group_configuration():
                 cls._migrate_pump_group(db, eeprom_object)
@@ -293,29 +307,104 @@ class ThermostatsMigrator(BaseMigrator):
 
             db.commit()
 
+            report_logger = Logs.get_update_logger('thermostat_migrations', prefix='migrations')
+            report_logger.info('Migrated thermostat structure:')
+            report_logger.info('Thermostats:')
+            for thermostat in db.query(Thermostat):
+                report_logger.info('  * {0} ({1})'.format(thermostat.name, thermostat.number))
+                report_logger.info('    * Sensor: {0} ({1})'.format(thermostat.sensor.name, thermostat.sensor.external_id))
+                vas = thermostat.cooling_valve_associations
+                schedules = thermostat.cooling_schedules
+                if vas or schedules:
+                    report_logger.info('    * Cooling:')
+                    if vas:
+                        report_logger.info('      * Valves:')
+                        for va in vas:
+                            output = va.valve.output
+                            report_logger.info('        * {0} -> {1} ({2})'.format(va.valve.name, output.name, output.number))
+                    if schedules:
+                        report_logger.info('      * Schedules:')
+                        for schedule in schedules:
+                            report_logger.info('        * {0}'.format(schedule))
+                vas = thermostat.heating_valve_associations
+                schedules = thermostat.heating_schedules
+                if vas or schedules:
+                    report_logger.info('    * Heating:')
+                    if vas:
+                        report_logger.info('      * Valves:')
+                        for va in vas:
+                            output = va.valve.output
+                            report_logger.info('        * {0} -> {1} ({2})'.format(va.valve.name, output.name, output.number))
+                    if schedules:
+                        report_logger.info('      * Schedules:')
+                        for schedule in schedules:
+                            report_logger.info('        * {0}'.format(schedule))
+                report_logger.info('    * Presets:')
+                for preset in thermostat.presets:
+                    report_logger.info('      * {0}: heating {1}, cooling {2}{3}'.format(preset.type,
+                                                                                         preset.heating_setpoint, preset.cooling_setpoint,
+                                                                                         ': active' if preset.active else ''))
+            report_logger.info('Pumps:')
+            for pump in db.query(Pump):
+                report_logger.info('  * {0}'.format(pump.name))
+                report_logger.info('    * Output: {0} ({1})'.format(pump.output.name, pump.output.number))
+                report_logger.info('    * Valves:')
+                for valve in pump.valves:
+                    report_logger.info('        * {0} -> {1} ({2}) with {3}s delay'.format(valve.name, valve.output.name, valve.output.number, valve.delay))
+            report_logger.info('Thermostat Groups:')
+            for group in db.query(ThermostatGroup):
+                report_logger.info('  * {0}'.format(group.name))
+                report_logger.info('    * Sensor: {0} ({1})'.format(group.sensor.name, group.sensor.external_id))
+                report_logger.info('    * Threshold: {0}'.format(group.threshold_temperature))
+                report_logger.info('    * Current mode: {0}'.format(group.mode))
+                oas = group.heating_output_associations
+                if oas:
+                    report_logger.info('    * Heating outputs:')
+                    for oa in oas:
+                        report_logger.info('      * {0} ({1}) set to {2}'.format(oa.output.name, oa.output.number, oa.value))
+                oas = group.cooling_output_associations
+                if oas:
+                    report_logger.info('    * Cooling outputs:')
+                    for oa in oas:
+                        report_logger.info('      * {0} ({1}) set to {2}'.format(oa.output.name, oa.output.number, oa.value))
+            report_logger.info('---')
+
     @classmethod
-    def _migrate_thermostat(cls, db, thermostat_group, mode, eeprom_object):
-        # type: (Any, ThermostatGroup, str, Any) -> None
+    def _migrate_thermostat(cls, db, thermostat_group, mode, eeprom_object, event_sender):
+        # type: (Any, ThermostatGroup, str, Any, EventSender) -> None
         if eeprom_object.sensor == 240:
-            raise RuntimeError('Thermostat {} with timer only configuration, this can\'t be migrated'.format(eeprom_object.id))
+            gateway_event = GatewayEvent(event_type=GatewayEvent.Types.NOTIFICATION,
+                                         data={'source': 'gateway',
+                                               'type': 'USER',
+                                               'topic': 'Time Based Thermostats',
+                                               'message': 'Time Based Thermostats are no longer supported in the '
+                                                          'current version of your gateway software. '
+                                                          'Please consult your OpenMotics manual for more info on '
+                                                          'how to configure schedule based thermostats.'})
+            event_sender.enqueue_event(gateway_event)
+            return  # No time based thermostats
         if eeprom_object.sensor in (None, 255):
-            return
+            return  # No sensor
+        if eeprom_object.output0 in (None, 255) and eeprom_object.output1 in (None, 255):
+            return  # No valve(s)
 
-        temperature = Sensor.PhysicalQuantities.TEMPERATURE
+        temperature = SensorEnums.PhysicalQuantities.TEMPERATURE
         sensor = db.query(Sensor).where((Sensor.physical_quantity == temperature) &
                                         (Sensor.external_id == str(eeprom_object.sensor))).one_or_none()
         if sensor is None:
-            sensor = db.query(Sensor).where((Sensor.physical_quantity is None) &
+            sensor = db.query(Sensor).where((Sensor.physical_quantity == None) &
                                             (Sensor.external_id == str(eeprom_object.sensor))).one_or_none()
             if sensor is None:
                 sensor = Sensor(physical_quantity=temperature,
-                                unit=Sensor.Units.CELCIUS,
+                                source=Source.MASTER,
+                                name='Sensor {0}'.format(eeprom_object.sensor),
+                                unit=SensorEnums.Units.CELCIUS,
                                 external_id=str(eeprom_object.sensor))
                 db.add(sensor)
                 db.commit()
         if sensor is None:
             raise ValueError('Thermostat <Sensor external_id={}> does not exist'.format(eeprom_object.sensor))
-        if sensor.source != Sensor.Sources.MASTER:
+        if sensor.source != Source.MASTER:
             raise ValueError('Unexpected <Sensor {}> {} for thermostats'.format(sensor.id, sensor.source))
         room = db.query(Room).where(Room.number == eeprom_object.room).one_or_none()
 
@@ -336,12 +425,17 @@ class ThermostatsMigrator(BaseMigrator):
             thermostat = Thermostat(**kwargs)
             db.add(thermostat)
             db.commit()
+        elif thermostat.sensor != sensor:
+            raise ValueError('Cooling and heating thermostat do not share same sensor')
 
         cls._migrate_pid_parameters(thermostat, mode, eeprom_object)
-        cls._migrate_output(db, thermostat, mode, eeprom_object.output0, 0)
-        cls._migrate_output(db, thermostat, mode, eeprom_object.output1, 1)
-        cls._migrate_presets(db, thermostat, mode, eeprom_object)
-        cls._migrate_schedules(db, thermostat, mode, eeprom_object)
+        has_valve = cls._migrate_output(db, thermostat, mode, eeprom_object.output0)
+        has_valve |= cls._migrate_output(db, thermostat, mode, eeprom_object.output1)
+        if has_valve:
+            cls._migrate_presets(db, thermostat, mode, eeprom_object)
+            cls._migrate_schedules(db, thermostat, mode, eeprom_object)
+        else:
+            db.query(Thermostat).where(Thermostat.number == thermostat.number).delete()
 
     @classmethod
     def _migrate_pid_parameters(cls, thermostat, mode, eeprom_object):
@@ -354,33 +448,32 @@ class ThermostatsMigrator(BaseMigrator):
             setattr(thermostat, dst_field, value)
 
     @classmethod
-    def _migrate_output(cls, db, thermostat, mode, output_nr, valve_priority):
-        # type: (Any, Thermostat, str, int, int) -> None
-        if output_nr not in (None, 255):
+    def _migrate_output(cls, db, thermostat, mode, output_nr):
+        # type: (Any, Thermostat, str, int) -> bool
+        if output_nr not in (None, 240, 255):
             output = db.query(Output).where(Output.number == output_nr).one()
             name = 'Valve (output {0})'.format(output.number)
             valve = db.query(Valve).where(Valve.output == output).one_or_none()
-            valve_to_thermostat = None  # type: Optional[ValveToThermostatAssociation]
+            indoor_link_valve = None  # type: Optional[IndoorLinkValves]
             if valve is None:
                 valve = Valve(output=output, name=name)
                 db.add(valve)
                 db.commit()
             else:
                 valve.name = name
-                valve_to_thermostat = db.query(ValveToThermostatAssociation).where(
-                    (ValveToThermostatAssociation.mode == mode) &
-                    (ValveToThermostatAssociation.valve == valve) &
-                    (ValveToThermostatAssociation.thermostat == thermostat)
+                indoor_link_valve = db.query(IndoorLinkValves).where(
+                    (IndoorLinkValves.mode == mode) &
+                    (IndoorLinkValves.valve == valve) &
+                    (IndoorLinkValves.thermostat == thermostat)
                 ).one_or_none()
-            if valve_to_thermostat is None:
-                valve_to_thermostat = ValveToThermostatAssociation(mode=mode,
-                                                                   valve=valve,
-                                                                   thermostat=thermostat,
-                                                                   priority=valve_priority)
-                db.add(valve_to_thermostat)
+            if indoor_link_valve is None:
+                indoor_link_valve = IndoorLinkValves(mode=mode,
+                                                     valve=valve,
+                                                     thermostat=thermostat)
+                db.add(indoor_link_valve)
                 db.commit()
-            else:
-                valve_to_thermostat.priority = valve_priority
+            return True
+        return False
 
     @classmethod
     def _migrate_presets(cls, db, thermostat, mode, eeprom_object):
@@ -467,27 +560,28 @@ class ThermostatsMigrator(BaseMigrator):
         # type: (Any, Any) -> None
         if eeprom_object.output not in (None, 255):
             output = db.query(Output).where(Output.number == eeprom_object.output).one()
-            name = 'Pump (output {0})'.format(output.number)
-            pump = Pump(name=name, output=output)
-            db.add(pump)
-            db.commit()
+            pump = db.query(Pump).where(Pump.output == output).one_or_none()
+            if pump is None:
+                name = 'Pump (output {0})'.format(output.number)
+                pump = Pump(name=name, output=output)
+                db.add(pump)
+                db.commit()
+            current_outputs = [valve.output for valve in pump.valves]
             for output_nr in (int(x) for x in eeprom_object.outputs.split(',')):
                 linked_output = db.query(Output).where(Output.number == output_nr).one()
-                name = 'Valve (output {0})'.format(linked_output.number)
-                valve = db.query(Valve).where(Valve.output == linked_output).one_or_none()
-                if valve is None:
-                    valve = Valve(output=linked_output,
-                                  name=name)
-                    db.add(valve)
+                if linked_output not in current_outputs:
+                    valve = db.query(Valve).where(Valve.output == linked_output).one_or_none()
+                    if valve is None:
+                        continue  # Ignore valves that are not used
+                    pump_to_valve = PumpToValveAssociation(pump=pump, valve=valve)
+                    db.add(pump_to_valve)
                     db.commit()
-                pump_to_valve = PumpToValveAssociation(pump=pump, valve=valve)
-                db.add(pump_to_valve)
-                db.commit()
+                    current_outputs.append(linked_output)
 
     @classmethod
     def _migrate_thermostat_group(cls, db, thermostat_group, eeprom_object):
         # type: (Any, ThermostatGroup, Any) -> None
-        temperature = Sensor.PhysicalQuantities.TEMPERATURE
+        temperature = SensorEnums.PhysicalQuantities.TEMPERATURE
         if eeprom_object.outside_sensor not in (None, 255):
             sensor = db.query(Sensor).where(
                 (Sensor.physical_quantity == temperature) &
@@ -500,7 +594,7 @@ class ThermostatsMigrator(BaseMigrator):
                 ).one_or_none()
                 if sensor is not None:
                     sensor.physical_quantity = temperature
-                    sensor.unit = Sensor.Units.CELCIUS
+                    sensor.unit = SensorEnums.Units.CELCIUS
             if sensor is None:
                 raise ValueError('Thermostat <Sensor external_id={}> does not exist'.format(eeprom_object.outside_sensor))
             thermostat_group.sensor = sensor
@@ -508,14 +602,16 @@ class ThermostatsMigrator(BaseMigrator):
             thermostat_group.threshold_temperature = eeprom_object.threshold_temp
 
         for mode in [ThermostatGroup.Modes.HEATING, ThermostatGroup.Modes.COOLING]:
+            index = 0
             for i in range(4):
                 output_field = 'switch_to_{0}_output_{1}'.format(mode, i)
                 value_field = 'switch_to_{0}_value_{1}'.format(mode, i)
                 if getattr(eeprom_object, output_field) not in (None, 255):
                     output = db.query(Output).where(Output.number == getattr(eeprom_object, output_field)).one()
-                    value = 0 if getattr(eeprom_object, value_field) in (None, 255, 0) else 100
-                    o2tg = OutputToThermostatGroupAssociation(thermostat_group=thermostat_group, output=output, mode=mode, value=value, index=0)
-                    db.add(o2tg)
+                    value = 0 if getattr(eeprom_object, value_field) == 0 else 100
+                    # o2tg = OutputToThermostatGroupAssociation(thermostat_group=thermostat_group, output=output, mode=mode, value=value, index=index)
+                    index += 1
+                    # db.add(o2tg)
                     db.commit()
 
         for valve in db.query(Valve).all():
diff --git a/src/gateway/models.py b/src/gateway/models.py
index c47f7425..0c3007f8 100644
--- a/src/gateway/models.py
+++ b/src/gateway/models.py
@@ -26,8 +26,10 @@ from sqlalchemy.orm import RelationshipProperty, relationship, \
     scoped_session, sessionmaker
 from sqlalchemy.orm.exc import NoResultFound
 from sqlalchemy.schema import MetaData
+# from sqlalchemy_utils import ChoiceType
 from sqlite3 import Connection as SQLite3Connection
 from sqlalchemy import event
+
 import constants
 
 
@@ -140,29 +142,31 @@ class Sensor(Base):
     room = relationship('Room', lazy='joined', innerjoin=False)  # type: RelationshipProperty[Optional[Room]]
     plugin = relationship('Plugin', lazy='joined', innerjoin=False)  # type: RelationshipProperty[Optional[Plugin]]
 
-    class Sources(object):
-        MASTER = 'master'
-        PLUGIN = 'plugin'
 
-    class PhysicalQuantities:
-        TEMPERATURE = 'temperature'
-        HUMIDITY = 'humidity'
-        BRIGHTNESS = 'brightness'
-        SOUND = 'sound'
-        DUST = 'dust'
-        COMFORT_INDEX = 'comfort_index'
-        AQI = 'aqi'
-        CO2 = 'co2'
-        VOC = 'voc'
-
-    class Units:
-        NONE = 'none'
-        CELCIUS = 'celcius'
-        PERCENT = 'percent'
-        DECIBEL = 'decibel'
-        LUX = 'lux'
-        MICRO_GRAM_PER_CUBIC_METER = 'micro_gram_per_cubic_meter'
-        PARTS_PER_MILLION = 'parts_per_million'
+class Screen(Base):
+    __tablename__ = 'screen'
+    __table_args__ = {'sqlite_autoincrement': True}
+
+    id = Column(Integer, primary_key=True, autoincrement=True)
+    room_id = Column(Integer, ForeignKey('room.id', ondelete='SET NULL'), nullable=True)
+    name = Column(String(255), default='', nullable=False)
+    in_use = Column(Boolean, nullable=False, default=True)
+    type = Column(String(255), nullable=False)
+
+    translational_steps = Column(Integer, nullable=True)
+    rotational_steps = Column(Integer, nullable=True)
+
+    source = Column(String(255), nullable=False)
+    external_id = Column(String(255), nullable=False)
+    plugin_id = Column(Integer, ForeignKey('plugin.id', ondelete='CASCADE'), nullable=True)
+
+    room = relationship('Room', lazy='joined', innerjoin=False)  # type: RelationshipProperty[Optional[Room]]
+    plugin = relationship('Plugin', lazy='joined', innerjoin=False)  # type: RelationshipProperty[Optional[Plugin]]
+
+    def __str__(self):
+        if self.name:
+            return '{0} ({1})'.format(self.name, self.id)
+        return str(self.id)
 
 
 class Shutter(Base, MasterNumber):
@@ -378,31 +382,47 @@ class ThermostatGroup(Base, MasterNumber):
 
     sensor = relationship('Sensor')  # type: RelationshipProperty[Optional[Sensor]]
     thermostats = relationship('Thermostat', back_populates='group')  # type: RelationshipProperty[List[Thermostat]]
-    outputs = relationship('Output', secondary='outputtothermostatgroup')  # type: RelationshipProperty[List[Output]]
+    outputs = relationship('Output', secondary='hvac_output_link')  # type: RelationshipProperty[List[Output]]
+
+    heating_output_associations = relationship('HvacOutputLink',
+                                               primaryjoin='and_(ThermostatGroup.id == HvacOutputLink.hvac_id, HvacOutputLink.mode == "heating")',
+                                               order_by='asc(HvacOutputLink.id)',
+                                               back_populates='hvac')  # type: RelationshipProperty[List[HvacOutputLink]]
+    cooling_output_associations = relationship('HvacOutputLink',
+                                               primaryjoin='and_(ThermostatGroup.id == HvacOutputLink.hvac_id, HvacOutputLink.mode == "cooling")',
+                                               order_by='asc(HvacOutputLink.id)',
+                                               back_populates='hvac')  # type: RelationshipProperty[List[HvacOutputLink]]
 
-    heating_output_associations = relationship('OutputToThermostatGroupAssociation',
-                                               primaryjoin='and_(ThermostatGroup.id == OutputToThermostatGroupAssociation.thermostat_group_id, OutputToThermostatGroupAssociation.mode == "heating")',
-                                               order_by='asc(OutputToThermostatGroupAssociation.index)',
-                                               back_populates='thermostat_group')  # type: RelationshipProperty[List[OutputToThermostatGroupAssociation]]
-    cooling_output_associations = relationship('OutputToThermostatGroupAssociation',
-                                               primaryjoin='and_(ThermostatGroup.id == OutputToThermostatGroupAssociation.thermostat_group_id, OutputToThermostatGroupAssociation.mode == "cooling")',
-                                               order_by='asc(OutputToThermostatGroupAssociation.index)',
-                                               back_populates='thermostat_group')  # type: RelationshipProperty[List[OutputToThermostatGroupAssociation]]
 
 
-class OutputToThermostatGroupAssociation(Base):
-    __tablename__ = 'outputtothermostatgroup'
-    __table_args__ = {'sqlite_autoincrement': True}
 
-    output_id = Column(Integer, ForeignKey('output.id', ondelete='CASCADE'), primary_key=True)
-    thermostat_group_id = Column(Integer, ForeignKey('thermostatgroup.id', ondelete='CASCADE'), primary_key=True)
-    mode = Column(String(255), nullable=False, primary_key=True)  # The mode this config is used for. Options: 'heating' or 'cooling'
+# thermostatsV2
+class HvacOutputLink(Base):
+    class Modes(object):
+        HEATING = 'heating'
+        COOLING = 'cooling'
+        OFF = 'off'
+        
 
-    index = Column(Integer, nullable=False)  # The index of this output in the config 0-3
-    value = Column(Integer, nullable=False)  # The value that needs to be set on the output when in this mode (0-100)
+    __tablename__ = "hvac_output_link"
+    __table_args__ = (
+        UniqueConstraint('hvac_id', 'output_id', 'mode'),
+        {'sqlite_autoincrement': True},
+    )
+
+    id = Column(Integer, primary_key=True, autoincrement=True)
+
+    # hvac_id = Column(Integer, ForeignKey('hvac.id', ondelete='CASCADE'), nullable=False)
+    hvac_id = Column(Integer, ForeignKey('thermostatgroup.id', ondelete='CASCADE'), nullable=False)  # todo: currently this is the id of thermostat_group_id but setting name for future changes
+    output_id = Column(Integer, ForeignKey('output.id', ondelete='CASCADE'), nullable=False)
+    mode = Column(String, nullable=False, default='heating')  # The mode this config is used for
+
+    value = Column(Integer, nullable=False, default=100)  # The value that needs to be set on the output when in this mode (0-100)
 
     output = relationship('Output')
-    thermostat_group = relationship('ThermostatGroup')
+    hvac = relationship('ThermostatGroup')
+
+
 
 
 class PumpToValveAssociation(Base):
@@ -464,7 +484,6 @@ class Valve(Base):
 
     output = relationship('Output', lazy='joined', back_populates='valve')
     pump = relationship('Pump', secondary='pumptovalve')  # type: RelationshipProperty[Optional[Pump]]
-    # associations = relationship('ValveToThermostatAssociation', lazy='joined')
 
 
 class Thermostat(Base, MasterNumber):
@@ -500,14 +519,11 @@ class Thermostat(Base, MasterNumber):
                                  primaryjoin='and_(Thermostat.id == Preset.thermostat_id, Preset.active == True)',
                                  back_populates='thermostat', uselist=False)  # type: RelationshipProperty[Preset]
 
-    valves = relationship('Valve', secondary='valvetothermostat',
-                          order_by='asc(ValveToThermostatAssociation.priority)')  # type: RelationshipProperty[List[Valve]]
-    heating_valve_associations = relationship('ValveToThermostatAssociation',
-                                              primaryjoin='and_(Thermostat.id == ValveToThermostatAssociation.thermostat_id, ValveToThermostatAssociation.mode == "heating")',
-                                              order_by='asc(ValveToThermostatAssociation.priority)')  # type: RelationshipProperty[List[ValveToThermostatAssociation]]
-    cooling_valve_associations = relationship('ValveToThermostatAssociation',
-                                              primaryjoin='and_(Thermostat.id == ValveToThermostatAssociation.thermostat_id, ValveToThermostatAssociation.mode == "cooling")',
-                                              order_by='asc(ValveToThermostatAssociation.priority)')  # type: RelationshipProperty[List[ValveToThermostatAssociation]]
+    valves = relationship('Valve', secondary='indoor_link_valves')  # type: RelationshipProperty[List[Valve]]
+    heating_valve_associations = relationship('IndoorLinkValves',
+                                              primaryjoin='and_(Thermostat.id == IndoorLinkValves.thermostat_link_id, IndoorLinkValves.mode == "heating")')  # type: RelationshipProperty[List[IndoorLinkValves]]
+    cooling_valve_associations = relationship('IndoorLinkValves',
+                                              primaryjoin='and_(Thermostat.id == IndoorLinkValves.thermostat_link_id, IndoorLinkValves.mode == "cooling")')  # type: RelationshipProperty[List[IndoorLinkValves]]
 
     schedules = relationship('DaySchedule', back_populates='thermostat')  # type: RelationshipProperty[List[DaySchedule]]
     heating_schedules = relationship('DaySchedule',
@@ -517,99 +533,20 @@ class Thermostat(Base, MasterNumber):
                                      primaryjoin='and_(Thermostat.id == DaySchedule.thermostat_id, DaySchedule.mode == "cooling")',
                                      order_by='asc(DaySchedule.index)')  # type: RelationshipProperty[List[DaySchedule]]
 
-    # def get_preset(self, preset_type):  # type: (str) -> Preset
-    #     if preset_type not in Preset.ALL_TYPES:
-    #         raise ValueError('Preset type `{0}` unknown'.format(preset_type))
-    #     preset = Preset.get_or_none((Preset.type == preset_type) &
-    #                                 (Preset.thermostat_id == self.id))
-    #     if preset is None:
-    #         preset = Preset(thermostat=self, type=preset_type)
-    #         if preset_type in Preset.DEFAULT_PRESET_TYPES:
-    #             preset.heating_setpoint = Preset.DEFAULT_PRESETS[ThermostatGroup.Modes.HEATING][preset_type]
-    #             preset.cooling_setpoint = Preset.DEFAULT_PRESETS[ThermostatGroup.Modes.COOLING][preset_type]
-    #         preset.save()
-    #     return preset
-    #
-    # @property
-    # def setpoint(self):
-    #     return self.active_preset.heating_setpoint if self.mode == ThermostatGroup.Modes.HEATING else self.active_preset.cooling_setpoint
-    #
-    # @property
-    # def active_preset(self):
-    #     preset = Preset.get_or_none(thermostat=self.id, active=True)
-    #     if preset is None:
-    #         preset = self.get_preset(Preset.Types.AUTO)
-    #         preset.active = True
-    #         preset.save()
-    #     return preset
-    #
-    # @active_preset.setter
-    # def active_preset(self, value):
-    #     if value is None or value.thermostat_id != self.id:
-    #         raise ValueError('The given Preset does not belong to this Thermostat')
-    #     if value != self.active_preset:
-    #         if self.active_preset is not None:
-    #             current_active_preset = self.active_preset
-    #             current_active_preset.active = False
-    #             current_active_preset.save()
-    #         value.active = True
-    #         value.save()
-    #
-    # @property
-    # def valves(self):  # type: () -> List[Valve]
-    #     return [valve for valve in Valve.select(Valve)
-    #                                     .join(ValveToThermostat)
-    #                                     .where(ValveToThermostat.thermostat_id == self.id)
-    #                                     .order_by(ValveToThermostat.priority)]
-    #
-    # @property
-    # def active_valves(self):  # type: () -> List[Valve]
-    #     return self._valves(mode=self.thermostat_group.mode)
-    #
-    # @property
-    # def heating_valves(self):  # type: () -> List[Valve]
-    #     return self._valves(mode=ThermostatGroup.Modes.HEATING)
-    #
-    # @property
-    # def cooling_valves(self):  # type: () -> List[Valve]
-    #     return self._valves(mode=ThermostatGroup.Modes.COOLING)
-    #
-    # def _valves(self, mode):  # type: (str) -> List[Valve]
-    #     return [valve for valve in Valve.select(Valve, ValveToThermostat.mode, ValveToThermostat.priority)
-    #                                     .join(ValveToThermostat)
-    #                                     .where((ValveToThermostat.thermostat_id == self.id) &
-    #                                            (ValveToThermostat.mode == mode))
-    #                                     .order_by(ValveToThermostat.priority)]
-    #
-    # @property
-    # def heating_schedules(self):  # type: () -> List[DaySchedule]
-    #     return [schedule for schedule in
-    #             DaySchedule.select()
-    #                        .where((DaySchedule.thermostat == self.id) &
-    #                               (DaySchedule.mode == ThermostatGroup.Modes.HEATING))
-    #                        .order_by(DaySchedule.index)]
-    #
-    # @property
-    # def cooling_schedules(self):  # type: () -> List[DaySchedule]
-    #     return [x for x in
-    #             DaySchedule.select()
-    #                        .where((DaySchedule.thermostat == self.id) &
-    #                               (DaySchedule.mode == ThermostatGroup.Modes.COOLING))
-    #                        .order_by(DaySchedule.index)]
 
 
-class ValveToThermostatAssociation(Base):
-    __tablename__ = 'valvetothermostat'
+class IndoorLinkValves(Base):
+    __tablename__ = 'indoor_link_valves'
     __table_args__ = {'sqlite_autoincrement': True}
 
-    thermostat_id = Column(Integer, ForeignKey('thermostat.id', ondelete='CASCADE'), primary_key=True)
-    valve_id = Column(Integer, ForeignKey('valve.id', ondelete='CASCADE'), primary_key=True)
-    mode = Column(String(255), default=ThermostatGroup.Modes.HEATING, nullable=False, primary_key=True)
-
-    priority = Column(Integer, default=0, nullable=False)
+    id = Column(Integer, primary_key=True, autoincrement=True)
+    # thermostat_link_id = Column(Integer, ForeignKey('indoor_thermostat_pid.id', ondelete='CASCADE'), nullable=False)
+    thermostat_link_id = Column(Integer, ForeignKey('thermostat.id', ondelete='CASCADE'))  # currently linked directly to the thermostat, in thermostat V2 it will be linked to indoor controller (pid controller)
+    valve_id = Column(Integer, ForeignKey('valve.id', ondelete='CASCADE'), nullable=False)
+    mode = Column(String(255), default=ThermostatGroup.Modes.HEATING, nullable=False)  # temporary placed here, will move to PID
 
-    thermostat = relationship('Thermostat', backref='valve_associations')
     valve = relationship('Valve', lazy='joined', backref='thermostat_associations')
+    thermostat = relationship('Thermostat', backref='valve_associations')
 
 
 class Preset(Base):
@@ -677,6 +614,14 @@ class DaySchedule(Base):
             last_value = data[key]
         return last_value
 
+    def __str__(self):
+        schedule = self.schedule_data
+        schedules = []
+        for offset in sorted(list(schedule.keys())):
+            minutes = offset // 60
+            schedules.append(('{0:02d}:{1:02d}'.format(minutes // 60, minutes % 60), schedule[offset]))
+        return ', '.join('{0}: {1}'.format(s[0], s[1]) for s in schedules)
+
 
 class Room(Base, MasterNumber):
     __tablename__ = 'room'
diff --git a/src/gateway/module_controller.py b/src/gateway/module_controller.py
index 3d43a60f..6e8a2c70 100644
--- a/src/gateway/module_controller.py
+++ b/src/gateway/module_controller.py
@@ -29,7 +29,7 @@ from gateway.mappers.module import ModuleMapper
 from enums import HardwareType
 
 if False:  # MYPY
-    from typing import Dict, List, Optional, Any, Set
+    from typing import Any, Dict, Iterable, List, Optional, Set
     from gateway.hal.master_controller import MasterController
     from gateway.energy_module_controller import EnergyModuleController
 
@@ -53,6 +53,12 @@ class ModuleController(BaseController):
             return False
         self._sync_running = True
 
+        try:
+            # sync the master serial number
+            self._master_controller.get_serial_number(update=True)
+        except Exception:
+            pass
+
         if self._sync_structures:
             self._sync_structures = False
 
@@ -69,6 +75,9 @@ class ModuleController(BaseController):
                 with Database.get_session() as db:
                     logger.info('ORM sync (Modules): Sync master modules...')
                     for dto in self._master_controller.get_modules_information():
+                        if dto.address in ['255.255.255.255', '255.255.255']:
+                            logger.warning('Skip adding an unaddressed module to the ORM')
+                            continue
                         module = db.query(Module)\
                             .where(Module.source == dto.source, Module.address == dto.address)\
                             .one_or_none()
@@ -222,10 +231,13 @@ class ModuleController(BaseController):
         self._master_controller.set_status_leds(status)
 
     def get_master_backup(self):
-        return self._master_controller.get_backup()
+        # type: () -> Iterable[bytes]
+        for chunk in self._master_controller.get_backup():
+            yield bytes(chunk)
 
     def master_restore(self, data):
-        return self._master_controller.restore(data)
+        # type: (bytearray) -> None
+        self._master_controller.restore(data)
 
     def flash_leds(self, led_type, led_id):
         with Database.get_session() as db:
@@ -270,3 +282,4 @@ class ModuleController(BaseController):
 
     def save_can_bus_termination(self, enabled):  # type: (bool) -> None
         self._master_controller.save_can_bus_termination(enabled=enabled)
+
diff --git a/src/gateway/notification_controller.py b/src/gateway/notification_controller.py
new file mode 100644
index 00000000..7b47fad2
--- /dev/null
+++ b/src/gateway/notification_controller.py
@@ -0,0 +1,62 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Notification BLL
+"""
+from __future__ import absolute_import
+
+import logging
+from cloud.events import GatewayEvent
+from gateway.enums import NotificationEnums
+from gateway.models import Database, Plugin
+from ioc import INJECTED, Inject, Injectable, Singleton
+
+if False:  # MYPY
+    from typing import Any
+    from cloud.events import EventSender
+    from gateway.dto import SourceDTO
+    from plugins.base import PluginController
+
+logger = logging.getLogger(__name__)
+
+
+@Injectable.named('notification_controller')
+@Singleton
+class NotificationController(object):
+
+    @Inject
+    def __init__(self, plugin_controller=INJECTED, event_sender=INJECTED):
+        # type: (PluginController, EventSender) -> None
+        self._plugin_controller = plugin_controller
+        self._event_sender = event_sender
+
+        self._plugin_controller.notification_callback_action = self._plugin_notification_callback_action
+
+    def _plugin_notification_callback_action(self, source, action, action_payload):
+        # type: (SourceDTO, str, Any) -> Any
+        if action == NotificationEnums.CallbackAction.SEND:
+            if not isinstance(action_payload, dict):
+                raise ValueError('Unexpected payload format')
+            if action_payload['type'] not in NotificationEnums.TYPES:
+                raise ValueError('Invalid type, should be one of: {0}'.format(', '.join(NotificationEnums.TYPES)))
+            with Database.get_session() as db:
+                plugin_name = db.query(Plugin).filter_by(id=source.source_id).one().name
+            gateway_event = GatewayEvent(event_type=GatewayEvent.Types.NOTIFICATION,
+                                         data={'source': 'plugin',
+                                               'plugin': plugin_name,
+                                               'type': action_payload['type'],
+                                               'topic': action_payload['topic'],
+                                               'message': action_payload['message']})
+            self._event_sender.enqueue_event(gateway_event)
diff --git a/src/gateway/scheduling_controller.py b/src/gateway/scheduling_controller.py
index 6da329b1..e28735ec 100644
--- a/src/gateway/scheduling_controller.py
+++ b/src/gateway/scheduling_controller.py
@@ -85,7 +85,6 @@ class SchedulingController(object):
         self._web_interface = None  # type: Optional[WebInterface]
         self._sync_thread = None  # type: Optional[DaemonThread]
         self._schedules = {}  # type: Dict[int, ScheduleDTO]
-        self._thermostat_setpoints = {} # type: Dict[Tuple[int,str],List[ScheduleSetpointDTO]]
         timezone = system_controller.get_timezone()
         self._scheduler = BackgroundScheduler(timezone=timezone, job_defaults={
             'coalesce': True,
@@ -213,30 +212,6 @@ class SchedulingController(object):
             db.commit()
         self.refresh_schedules()
 
-    def update_thermostat_setpoints(self, thermostat_id, mode, day_schedules):
-        # type: (int, str, List[DaySchedule]) -> None
-        key = (thermostat_id, mode)
-        setpoints = []
-        for t, setpoint in calculate_transitions(day_schedules, datetime.now()):
-            setpoints.append(ScheduleSetpointDTO(thermostat=thermostat_id,
-                                                 mode=mode,
-                                                 temperature=setpoint,
-                                                 weekday=t.weekday(),
-                                                 hour=t.hour,
-                                                 minute=t.minute))
-        current_setpoints = self._thermostat_setpoints.get(key, [])
-        if current_setpoints != setpoints:
-            for setpoint_dto in current_setpoints:
-                self._abort(setpoint_dto)
-            for setpoint_dto in setpoints:
-                self._submit_setpoint(setpoint_dto)
-            self._thermostat_setpoints[key] = setpoints
-
-    def last_thermostat_setpoint(self, day_schedules):
-        # type: (List[DaySchedule]) -> Tuple[datetime, float]
-        now = datetime.now()
-        transitions = sorted(calculate_transitions(day_schedules, now), reverse=True)
-        return next((t, v) for t, v in transitions if t <= now)
 
     def _submit_setpoint(self, setpoint_dto):
         # type: (ScheduleSetpointDTO) -> None
@@ -358,28 +333,6 @@ class SchedulingController(object):
                 params_parser(arguments['parameters'], check)
 
 
-def calculate_transitions(day_schedules, at):
-    # type: (List[DaySchedule], datetime) -> Iterable[Tuple[datetime, float]]
-    """
-    Calculate the setpoint transitions relative to a timestamp based on the
-    given day schedules.
-    """
-    index = at.weekday()
-    start_of_day = datetime(at.year, at.month, at.day)
-
-    data = {}
-    for day_schedule in day_schedules:
-        offset = max(day_schedule.index, index) - min(day_schedule.index, index)
-        # Shift last day schedule when at start of the week.
-        if index == 0 and day_schedule.index == 6:
-            offset -= 7
-        if day_schedule.index < index:
-            offset = -offset
-        d = start_of_day + timedelta(days=offset)
-        data.update({d + timedelta(seconds=int(k)): v
-                     for k, v in day_schedule.schedule_data.items()})
-    return sorted(data.items())
-
 
 def datetime_to_timestamp(date):
     # type: (datetime) -> float
diff --git a/src/gateway/screen_controller.py b/src/gateway/screen_controller.py
new file mode 100644
index 00000000..b4b32638
--- /dev/null
+++ b/src/gateway/screen_controller.py
@@ -0,0 +1,342 @@
+# Copyright (C) 2019 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+This module contains logic to handle screens with their state/position
+"""
+from __future__ import absolute_import
+
+import logging
+from collections import defaultdict
+from gateway.base_controller import BaseController
+from gateway.dto import ScreenDTO, PluginScreenDTO, ScreenStateDTO, SourceDTO
+from gateway.enums import ScreenEnums, Source
+from gateway.events import GatewayEvent
+from gateway.models import Screen, Database, Plugin
+from gateway.mappers.screen import ScreenMapper
+from gateway.pubsub import PubSub
+from gateway.shutter_controller import ShutterController
+from plugins.base import PluginController
+from ioc import INJECTED, Inject, Injectable, Singleton
+
+if False:  # MYPY
+    from typing import List, Dict, Optional, Any
+    from gateway.hal.master_controller import MasterController
+
+logger = logging.getLogger(__name__)
+
+
+@Injectable.named('screen_controller')
+@Singleton
+class ScreenController(BaseController):
+
+    # Notes:
+    # * Positions:
+    #   * A position of 0 means OPEN
+    #   * A position of `configured max steps` means CLOSED
+    #   * OPEN is considered `most transparent, least opaque`
+    #   * CLOSED is considered `least transparent, most opaque`
+
+    # TODO: Subscribe to Shutter GatewayEvents and report states to `report_screen_status`
+
+    @Inject
+    def __init__(self, master_controller=INJECTED, shutter_controller=INJECTED, plugin_controller=INJECTED):
+        # type: (MasterController, ShutterController, PluginController) -> None
+        super(ScreenController, self).__init__(master_controller)
+        self._shutter_controller = shutter_controller
+        self._plugin_controller = plugin_controller
+
+        self._plugin_controller.screen_callback_action = self._plugin_screen_callback_action
+
+        self._screen_rotational_states = defaultdict(lambda: ScreenStateDTO(state=ScreenEnums.State.UNKNOWN))  # type: Dict[int, ScreenStateDTO]
+        self._screen_translational_states = defaultdict(lambda: ScreenStateDTO(state=ScreenEnums.State.UNKNOWN))  # type: Dict[int, ScreenStateDTO]
+
+    @staticmethod
+    def _get_source_from_screen(screen):  # type: (Screen) -> SourceDTO
+        source = SourceDTO(source=screen.source)
+        if screen.source == Source.PLUGIN:
+            source.source_id = screen.plugin_id
+        return source
+
+    @staticmethod
+    def _get_screen_from_source(db, source, external_id):  # type (Session, SourceDTO, str) -> Screen
+        lookup_kwargs = {'source': source.source,
+                         'external_id': external_id}
+        if source.source == Source.PLUGIN:
+            lookup_kwargs['plugin_id'] = source.source_id
+        return db.query(Screen).filter_by(**lookup_kwargs).one_or_none()
+
+    # Allow screen states to be reported
+
+    def report_screen_status(self, screen_id, rotational_state=None, translational_state=None):
+        # type: (int, Optional[ScreenStateDTO], Optional[ScreenStateDTO]) -> None
+        with Database.get_session() as db:
+            screen = db.query(Screen).filter_by(id=screen_id).one()
+
+        current_rotational_state = self._screen_rotational_states[screen_id]
+        current_translational_state = self._screen_translational_states[screen_id]
+        state_changed = False
+
+        if rotational_state is not None:
+            if screen.rotational_steps is None:
+                raise ValueError('Screen {0} does not support rotation'.format(screen))
+            if rotational_state.position is not None:
+                if 0 <= rotational_state.position <= screen.rotational_steps:
+                    state_changed |= current_rotational_state.position != rotational_state.position
+                    current_rotational_state.position = rotational_state.position
+                else:
+                    raise ValueError('Screen {0} only accepts rotational positions 0 <= n <= {1}'.format(screen, screen.rotational_steps))
+            if rotational_state.state is not None:
+                if rotational_state.state in ScreenEnums.STATES:
+                    state_changed |= current_rotational_state.state != rotational_state.state
+                    current_rotational_state.state = rotational_state.state
+                    if rotational_state.state == ScreenEnums.State.UNKNOWN:
+                        state_changed |= current_rotational_state.position is not None
+                        current_rotational_state.position = None
+                else:
+                    raise ValueError('Screen {0} only accept rotational states: {1}'.format(screen, ', '.join(ScreenEnums.STATES)))
+
+        if translational_state is not None:
+            if screen.translational_steps is None:
+                raise ValueError('Screen {0} does not support translation'.format(screen))
+            if translational_state.position is not None:
+                if 0 <= translational_state.position <= screen.translational_steps:
+                    state_changed |= current_translational_state.position != translational_state.position
+                    current_translational_state.position = translational_state.position
+                else:
+                    raise ValueError('Screen {0} only accepts translational positions 0 <= n <= {1}'.format(screen, screen.translational_steps))
+            if translational_state.state is not None:
+                if translational_state.state in ScreenEnums.STATES:
+                    state_changed |= current_translational_state.state != translational_state.state
+                    current_translational_state.state = translational_state.state
+                    if translational_state.state == ScreenEnums.State.UNKNOWN:
+                        state_changed |= current_translational_state.position is not None
+                        current_translational_state.position = None
+                else:
+                    raise ValueError('Screen {0} only accept translational states: {1}'.format(screen, ', '.join(ScreenEnums.STATES)))
+
+        if state_changed:
+            new_states = []
+            if screen.translational_steps is not None:
+                new_states.append('translational state is {0}'.format(current_translational_state))
+            if screen.rotational_steps is not None:
+                new_states.append('rotational state is {0}'.format(current_rotational_state))
+            logger.info('Screen {0} {1}'.format(screen_id, ' and '.join(new_states)))
+            self._send_state_event(screen_id)
+
+    # PluginController callback processing
+
+    def _plugin_screen_callback_action(self, source, action, action_payload):
+        # type: (SourceDTO, str, Any) -> Any
+        if action == ScreenEnums.CallbackAction.REGISTER:
+            with Database.get_session() as db:
+                if not isinstance(action_payload, PluginScreenDTO):
+                    raise ValueError('Unexpected payload format')
+                if action_payload.type not in ScreenEnums.TYPES:
+                    raise ValueError('Invalid type, should be one of: {0}'.format(', '.join(ScreenEnums.TYPES)))
+                if action_payload.external_id is None:
+                    raise ValueError('An external ID is mandatory for registration')
+                screen = ScreenController._get_screen_from_source(db=db,
+                                                                  source=source,
+                                                                  external_id=action_payload.external_id)
+                if screen is None:
+                    plugin = db.query(Plugin).where(Plugin.id == source.source_id).one()
+                    screen = Screen(name=action_payload.name,
+                                    translational_steps=action_payload.translational_steps,
+                                    rotational_steps=action_payload.rotational_steps,
+                                    type=action_payload.type,
+                                    in_use=True,
+                                    source=Source.PLUGIN,
+                                    external_id=action_payload.external_id,
+                                    plugin=plugin)
+                    db.add(screen)
+                else:
+                    screen.type = action_payload.type
+                    screen.translational_steps = action_payload.translational_steps
+                    screen.rotational_steps = action_payload.rotational_steps
+                db.commit()
+                return PluginScreenDTO(id=screen.id,
+                                       external_id=screen.external_id,
+                                       name=screen.name,
+                                       type=screen.type,
+                                       translational_steps=screen.translational_steps,
+                                       rotational_steps=screen.rotational_steps)
+        if action == ScreenEnums.CallbackAction.REPORT_STATUS:
+            with Database.get_session() as db:
+                screen = ScreenController._get_screen_from_source(db=db,
+                                                                  source=source,
+                                                                  external_id=action_payload['external_id'])
+                if screen is None:
+                    raise RuntimeError('Screen does not exist')
+                return self.report_screen_status(screen_id=screen.id,
+                                                 translational_state=action_payload['translational_state'],
+                                                 rotational_state=action_payload['rotational_state'])
+        if action == ScreenEnums.CallbackAction.LOAD_SCREENS:
+            screen_dtos = []
+            all_screens = action_payload['all_screens']
+            with Database.get_session() as db:
+                if all_screens:
+                    screens = db.query(Screen).all()
+                else:
+                    lookup_kwargs = {'source': source.source}  # type: Dict[str, Any]
+                    if source.source == Source.PLUGIN:
+                        lookup_kwargs['plugin_id'] = source.source_id
+                    screens = db.query(Screen).filter_by(**lookup_kwargs).all()
+                for screen in screens:
+                    if all_screens:
+                        screen_source = ScreenController._get_source_from_screen(screen=screen)
+                        external_id = screen.external_id if screen_source == source else None  # type: Optional[str]
+                    else:
+                        external_id = screen.external_id
+                    screen_dtos.append(PluginScreenDTO(id=screen.id,
+                                                       external_id=external_id,
+                                                       name=screen.name,
+                                                       type=screen.type,
+                                                       translational_steps=screen.translational_steps,
+                                                       rotational_steps=screen.translational_steps))
+            return screen_dtos
+        if action == ScreenEnums.CallbackAction.OPEN:
+            return self.screen_open(screen_id=action_payload['screen_id'])
+        if action == ScreenEnums.CallbackAction.CLOSE:
+            return self.screen_close(screen_id=action_payload['screen_id'])
+        if action == ScreenEnums.CallbackAction.STOP:
+            return self.screen_stop(screen_id=action_payload['screen_id'])
+        if action == ScreenEnums.CallbackAction.GOTO_POSITION:
+            return self.screen_goto_position(screen_id=action_payload['screen_id'],
+                                             translational_position=action_payload['translational_position'],
+                                             rotational_position=action_payload['rotational_position'])
+
+    # Configure screens
+
+    def load_screen(self, screen_id):  # type: (int) -> ScreenDTO
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+            return ScreenMapper(db).orm_to_dto(screen)
+
+    def load_screens(self):  # type: () -> List[ScreenDTO]
+        with Database.get_session() as db:
+            screen_dtos = []
+            mapper = ScreenMapper(db)
+            for screen in db.query(Screen).all():
+                screen_dtos.append(mapper.orm_to_dto(screen))
+            return screen_dtos
+
+    def save_screens(self, screens):  # type: (List[ScreenDTO]) -> None
+        with Database.get_session() as db:
+            mapper = ScreenMapper(db)
+            for screen_dto in screens:
+                mapper.dto_to_orm(screen_dto)
+            db.commit()
+        self._send_config_event()
+
+    # Event senders
+
+    def _send_state_event(self, screen_id):
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+
+        translational_state = self._screen_translational_states[screen.id]
+        rotational_state = self._screen_rotational_states[screen.id]
+        status = {}
+        if screen.translational_steps is not None:
+            status['translational'] = {'position': translational_state.position,
+                                       'state': translational_state.state}
+        if screen.rotational_steps is not None:
+            status['rotational'] = {'position': rotational_state.position,
+                                    'state': rotational_state.state}
+        gateway_event = GatewayEvent(event_type=GatewayEvent.Types.SCREEN_CHANGE,
+                                     data={'id': screen_id,
+                                           'status': status})
+        self._pubsub.publish_gateway_event(PubSub.GatewayTopics.STATE, gateway_event)
+
+    def _send_config_event(self):
+        gateway_event = GatewayEvent(GatewayEvent.Types.CONFIG_CHANGE, {'type': 'screen'})
+        self._pubsub.publish_gateway_event(PubSub.GatewayTopics.CONFIG, gateway_event)
+
+    # Control screens
+
+    @staticmethod
+    def _validate_master_screen(screen):  # type: (Screen) -> None
+        if screen.rotational_steps is not None or screen.translational_steps is None:
+            raise RuntimeError('Screen {0} with source `master` should be translational, but not rotational'.format(screen))
+
+    def screen_goto_position(self, screen_id, rotational_position=None, translational_position=None):
+        # type: (int, Optional[int], Optional[int]) -> None
+        if rotational_position is None and translational_position is None:
+            raise ValueError('Either rotational or translational position must be given')
+
+        positions = []
+        if rotational_position is not None:
+            positions.append('rotational position {0}'.format(rotational_position))
+        if translational_position is not None:
+            positions.append('translational position {0}'.format(translational_position))
+        logger.info('Screen {0} wants to go to {1}'.format(screen_id, ' and '.join(positions)))
+
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+        if screen.source == Source.MASTER:
+            ScreenController._validate_master_screen(screen)
+            if rotational_position is not None or translational_position is None:
+                raise RuntimeError('Screen {0} with source `master` only accepts a translational position'.format(screen))
+            self._shutter_controller.shutter_goto(shutter_id=int(screen.external_id),
+                                                  desired_position=translational_position)
+        elif screen.source == Source.PLUGIN:
+            source = ScreenController._get_source_from_screen(screen)
+            self._plugin_controller.execute_screen_action(action=ScreenEnums.Action.GOTO_POSITION,
+                                                          action_payload={'external_id': screen.external_id,
+                                                                          'rotational_position': rotational_position,
+                                                                          'translational_position': translational_position},
+                                                          destination=source)
+
+    def screen_close(self, screen_id):  # type: (int) -> None
+        logger.info('Screen {0} wants to close'.format(screen_id))
+
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+        if screen.source == Source.MASTER:
+            ScreenController._validate_master_screen(screen)
+            self._shutter_controller.shutter_down(shutter_id=int(screen.external_id))
+        elif screen.source == Source.PLUGIN:
+            source = ScreenController._get_source_from_screen(screen)
+            self._plugin_controller.execute_screen_action(action=ScreenEnums.Action.CLOSE,
+                                                          action_payload={'external_id': screen.external_id},
+                                                          destination=source)
+
+    def screen_open(self, screen_id):  # type: (int) -> None
+        logger.info('Screen {0} wants to open'.format(screen_id))
+
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+        if screen.source == Source.MASTER:
+            ScreenController._validate_master_screen(screen)
+            self._shutter_controller.shutter_up(shutter_id=int(screen.external_id))
+        elif screen.source == Source.PLUGIN:
+            source = ScreenController._get_source_from_screen(screen)
+            self._plugin_controller.execute_screen_action(action=ScreenEnums.Action.OPEN,
+                                                          action_payload={'external_id': screen.external_id},
+                                                          destination=source)
+
+    def screen_stop(self, screen_id):  # type: (int) -> None
+        logger.info('Screen {0} wants to stop'.format(screen_id))
+
+        with Database.get_session() as db:
+            screen = db.query(Screen).where(Screen.id == screen_id).one()
+        if screen.source == Source.MASTER:
+            ScreenController._validate_master_screen(screen)
+            self._shutter_controller.shutter_stop(shutter_id=int(screen.external_id))
+        elif screen.source == Source.PLUGIN:
+            source = ScreenController._get_source_from_screen(screen)
+            self._plugin_controller.execute_screen_action(action=ScreenEnums.Action.STOP,
+                                                          action_payload={'external_id': screen.external_id},
+                                                          destination=source)
diff --git a/src/gateway/sensor_controller.py b/src/gateway/sensor_controller.py
index 13fb0156..3bd8fafa 100644
--- a/src/gateway/sensor_controller.py
+++ b/src/gateway/sensor_controller.py
@@ -18,23 +18,24 @@ Sensor BLL
 from __future__ import absolute_import
 
 import logging
-import time
 
 from sqlalchemy import func
 
 from gateway.base_controller import BaseController, SyncStructure
-from gateway.dto import MasterSensorDTO, SensorDTO, SensorSourceDTO, \
-    SensorStatusDTO
+from gateway.dto import MasterSensorDTO, PluginSensorDTO, SensorDTO, \
+    SensorStateDTO, SourceDTO
+from gateway.enums import SensorEnums, Source
 from gateway.events import GatewayEvent
 from gateway.hal.master_event import MasterEvent
 from gateway.mappers.sensor import SensorMapper
-from gateway.models import Database, Plugin, Room, Sensor, Session
+from gateway.models import Database, Plugin, Room, Sensor
 from gateway.pubsub import PubSub
 from ioc import INJECTED, Inject, Injectable, Singleton
 
 if False:  # MYPY
     from typing import Any, Dict, List, Optional, Set, Tuple
     from gateway.hal.master_controller import MasterController
+    from plugins.base import PluginController
 
 logger = logging.getLogger(__name__)
 
@@ -44,19 +45,63 @@ logger = logging.getLogger(__name__)
 class SensorController(BaseController):
     SYNC_STRUCTURES = [SyncStructure(Sensor, 'sensor')]
 
-    MASTER_TYPES = {MasterEvent.SensorType.TEMPERATURE: Sensor.PhysicalQuantities.TEMPERATURE,
-                    MasterEvent.SensorType.HUMIDITY: Sensor.PhysicalQuantities.HUMIDITY,
-                    MasterEvent.SensorType.BRIGHTNESS: Sensor.PhysicalQuantities.BRIGHTNESS}
+    MASTER_TYPES = {MasterEvent.SensorType.TEMPERATURE: SensorEnums.PhysicalQuantities.TEMPERATURE,
+                    MasterEvent.SensorType.HUMIDITY: SensorEnums.PhysicalQuantities.HUMIDITY,
+                    MasterEvent.SensorType.BRIGHTNESS: SensorEnums.PhysicalQuantities.BRIGHTNESS}
 
     @Inject
-    def __init__(self, master_controller=INJECTED, pubsub=INJECTED):
-        # type: (MasterController, PubSub) -> None
+    def __init__(self, master_controller=INJECTED, plugin_controller=INJECTED, pubsub=INJECTED):
+        # type: (MasterController, PluginController, PubSub) -> None
         super(SensorController, self).__init__(master_controller, sync_interval=600)
+        self._plugin_controller = plugin_controller
         self._pubsub = pubsub
         self._master_cache = {}  # type: Dict[Tuple[str, int],SensorDTO]
-        self._status = {}  # type: Dict[int, SensorStatusDTO]
+        self._status = {}  # type: Dict[int, SensorStateDTO]
+        self._plugin_controller.sensor_callback_action = self._plugin_callback_action
         self._pubsub.subscribe_master_events(PubSub.MasterTopics.SENSOR, self._handle_master_event)
 
+    def _plugin_callback_action(self, source, action, action_payload):
+        # type: (SourceDTO, str, Any) -> Any
+        if action == SensorEnums.CallbackAction.REGISTER:
+            changed = False
+            with Database.get_session() as db:
+                if not source.is_plugin:
+                    raise ValueError('Can\'t register Sensor with source {}'.format(source.source))
+                plugin = db.query(Plugin).filter_by(id=source.source_id).one()  # type: Plugin
+                lookup_kwargs = {'source': source.source,
+                                 'plugin': plugin,
+                                 'external_id': action_payload.external_id,
+                                 'physical_quantity': action_payload.physical_quantity,
+                                 'unit': action_payload.unit}
+                sensor = db.query(Sensor).filter_by(**lookup_kwargs).one_or_none()  # type: Optional[Sensor]
+                if sensor is None:
+                    sensor = Sensor(id=get_sensor_orm_id(db, source.source), **lookup_kwargs)
+                    sensor.name = action_payload.name
+                    db.add(sensor)
+                    changed = True
+                db.commit()
+                sensor_dto = PluginSensorDTO(external_id=sensor.external_id,
+                                             physical_quantity=sensor.physical_quantity,
+                                             unit=sensor.unit,
+                                             name=sensor.name)
+            if changed:
+                self._publish_config()
+            return sensor_dto
+        if action == SensorEnums.CallbackAction.REPORT_STATUS:
+            with Database.get_session() as db:
+                if not source.is_plugin:
+                    raise ValueError('Can\'t report status for Sensor with source {}'.format(source.source))
+                plugin = db.query(Plugin).filter_by(id=source.source_id).one()
+                sensor_dto = action_payload['sensor']
+                lookup_kwargs = {'source': source.source,
+                                 'plugin': plugin,
+                                 'external_id': sensor_dto.external_id,
+                                 'physical_quantity': sensor_dto.physical_quantity,
+                                 'unit': sensor_dto.unit}
+                sensor = db.query(Sensor).filter_by(**lookup_kwargs).one()
+                if sensor:
+                    self._handle_status(SensorStateDTO(sensor.id, value=action_payload['value']))
+
     def sync_state(self):
         # type: () -> None
         logger.debug('Publishing latest sensor status')
@@ -72,7 +117,7 @@ class SensorController(BaseController):
         self._pubsub.publish_gateway_event(PubSub.GatewayTopics.CONFIG, gateway_event)
 
     def _handle_status(self, status_dto):
-        # type: (SensorStatusDTO) -> None
+        # type: (SensorStateDTO) -> None
         if not (status_dto == self._status.get(status_dto.id)):
             event_data = {'id': status_dto.id,
                           'value': status_dto.value}
@@ -91,8 +136,8 @@ class SensorController(BaseController):
             key = (sensor_type, master_event.data['sensor'])
             sensor_dto = self._master_cache.get(key)
             if sensor_dto is not None:
-                self._handle_status(SensorStatusDTO(sensor_dto.id,
-                                                    value=master_event.data['value']))
+                self._handle_status(SensorStateDTO(sensor_dto.id,
+                                                   value=master_event.data['value']))
             else:
                 logger.warning('Received value for unknown %s sensor %s', key, master_event)
                 self._sync_structures = True
@@ -110,13 +155,13 @@ class SensorController(BaseController):
 
             with Database.get_session() as db:
                 temperature = self._master_controller.get_sensors_temperature()
-                ids |= self._sync_orm_master(db, Sensor.PhysicalQuantities.TEMPERATURE, 'celcius', temperature, master_orm_mapping)
+                ids |= self._sync_orm_master(db, SensorEnums.PhysicalQuantities.TEMPERATURE, 'celcius', temperature, master_orm_mapping)
                 humidity = self._master_controller.get_sensors_humidity()
-                ids |= self._sync_orm_master(db, Sensor.PhysicalQuantities.HUMIDITY, 'percent', humidity, master_orm_mapping)
+                ids |= self._sync_orm_master(db, SensorEnums.PhysicalQuantities.HUMIDITY, 'percent', humidity, master_orm_mapping)
                 brighness = self._master_controller.get_sensors_brightness()
-                ids |= self._sync_orm_master(db, Sensor.PhysicalQuantities.BRIGHTNESS, 'percent', brighness, master_orm_mapping)
+                ids |= self._sync_orm_master(db, SensorEnums.PhysicalQuantities.BRIGHTNESS, 'percent', brighness, master_orm_mapping)
 
-                query = (Sensor.source == Sensor.Sources.MASTER) & (Sensor.external_id.notin_(ids))
+                query = (Sensor.source == Source.MASTER) & (Sensor.external_id.notin_(ids))
                 count = db.query(Sensor).where(query).delete()
                 if count > 0:
                     logger.info('Removed {} unreferenced sensor(s)'.format(count))
@@ -126,7 +171,7 @@ class SensorController(BaseController):
 
     def _sync_orm_master(self, db, physical_quantity, unit, values, master_orm_mapping):
         # type: (Any, str, str, List[Optional[float]], Dict[int,MasterSensorDTO]) -> Set[str]
-        source = SensorSourceDTO(Sensor.Sources.MASTER)
+        source = SourceDTO(Source.MASTER)
         ids = set()
         for i, value in enumerate(values):
             if i not in master_orm_mapping:
@@ -148,7 +193,7 @@ class SensorController(BaseController):
             sensor_dto.id = sensor.id
             self._master_cache[(physical_quantity, i)] = sensor_dto
 
-            status_dto = SensorStatusDTO(sensor.id, value=float(value))
+            status_dto = SensorStateDTO(sensor.id, value=float(value))
             self._handle_status(status_dto)
         return ids
 
@@ -157,18 +202,18 @@ class SensorController(BaseController):
         with Database.get_session() as db:
             sensor = db.get(Sensor, sensor_id)
             room = sensor.room.number if sensor.room is not None else None
-            source_name = None if sensor.plugin is None else sensor.plugin.name
+            plugin_id = None if sensor.plugin is None else sensor.plugin.id
             sensor_dto = SensorDTO(id=sensor.id,
-                                   source=SensorSourceDTO(sensor.source, name=source_name),
+                                   source=SourceDTO(sensor.source, source_id=plugin_id),
                                    external_id=sensor.external_id,
                                    physical_quantity=sensor.physical_quantity,
                                    unit=sensor.unit,
                                    name=sensor.name,
                                    room=room)
-        if sensor.source == Sensor.Sources.MASTER:
+        if sensor.source == Source.MASTER:
             master_sensor_dto = self._master_controller.load_sensor(sensor_id=int(sensor.external_id))
             sensor_dto.virtual = master_sensor_dto.virtual
-            if sensor.physical_quantity == Sensor.PhysicalQuantities.TEMPERATURE:
+            if sensor.physical_quantity == SensorEnums.PhysicalQuantities.TEMPERATURE:
                 sensor_dto.offset = master_sensor_dto.offset
         return sensor_dto
 
@@ -180,21 +225,21 @@ class SensorController(BaseController):
                 .all()  # type: List[Sensor]
             sensor_dtos = []
             for sensor in sensors:
-                source_name = None
+                plugin_id = None
                 if sensor.plugin is not None:
-                    source_name = sensor.plugin.name
+                    plugin_id = sensor.plugin.id
                 room = sensor.room.number if sensor.room is not None else None
                 sensor_dto = SensorDTO(id=sensor.id,
-                                       source=SensorSourceDTO(sensor.source, name=source_name),
+                                       source=SourceDTO(sensor.source, source_id=plugin_id),
                                        external_id=sensor.external_id,
                                        physical_quantity=sensor.physical_quantity,
                                        unit=sensor.unit,
                                        name=sensor.name,
                                        room=room)
-                if sensor.source == Sensor.Sources.MASTER:
+                if sensor.source == Source.MASTER:
                     master_sensor_dto = self._master_controller.load_sensor(sensor_id=int(sensor.external_id))
                     sensor_dto.virtual = master_sensor_dto.virtual
-                    if sensor.physical_quantity == Sensor.PhysicalQuantities.TEMPERATURE:
+                    if sensor.physical_quantity == SensorEnums.PhysicalQuantities.TEMPERATURE:
                         sensor_dto.offset = master_sensor_dto.offset
                 sensor_dtos.append(sensor_dto)
         return sensor_dtos
@@ -210,10 +255,10 @@ class SensorController(BaseController):
 
                 sensor_dto.external_id = sensor.external_id
                 if sensor_dto.source is None:
-                    source_name = None
+                    plugin = None
                     if sensor.plugin is not None:
-                        source_name = sensor.plugin.name
-                    sensor_dto.source = SensorSourceDTO(sensor.source, name=source_name)
+                        plugin = sensor.plugin.id
+                    sensor_dto.source = SourceDTO(sensor.source, source_id=plugin)
                 if sensor_dto.physical_quantity is None:
                     sensor_dto.physical_quantity = sensor.physical_quantity
                 master_dto = mapper.dto_to_master_dto(sensor_dto)
@@ -226,32 +271,6 @@ class SensorController(BaseController):
             self._publish_config()
         return sensors
 
-    def register_sensor(self, source_dto, external_id, physical_quantity, unit, default_config=None):
-        # type: (SensorSourceDTO, str, str, str, Optional[Dict[str,Any]]) -> SensorDTO
-        changed = False
-        default_config = default_config or {}
-        with Database.get_session() as db:
-            if source_dto.type == 'plugin':
-                plugin = db.query(Plugin).filter_by(name=source_dto.name).one()  # type: Plugin
-                lookup_kwargs = {'source': source_dto.type, 'plugin': plugin,
-                                 'external_id': external_id,
-                                 'physical_quantity': physical_quantity,
-                                 'unit': unit}
-            else:
-                raise ValueError('Can\'t register Sensor with source {}'.format(source_dto.type))
-            sensor = db.query(Sensor).filter_by(**lookup_kwargs).one_or_none()  # type: Optional[Sensor]
-            if sensor is None:
-                sensor = Sensor(id=get_sensor_orm_id(db, source_dto.type), **lookup_kwargs)
-                db.add(sensor)
-                changed = True
-                for field in ('name',):
-                    setattr(sensor, field, default_config.get(field, ''))
-            db.commit()
-            sensor_dto = self.load_sensor(sensor.id)
-        if changed:
-            self._publish_config()
-        return sensor_dto
-
     def _create_or_update_sensor(self, db, sensor_dto):  # type: (Any, SensorDTO) -> Tuple[Sensor, bool]
         changed = False
         if sensor_dto.id:
@@ -259,13 +278,13 @@ class SensorController(BaseController):
         else:
             if 'physical_quantity' in sensor_dto.loaded_fields and 'external_id' in sensor_dto.loaded_fields:
                 sensor = db.query(Sensor) \
-                    .filter_by(source=Sensor.Sources.MASTER,
+                    .filter_by(source=Source.MASTER,
                                external_id=sensor_dto.external_id,
                                physical_quantity=sensor_dto.physical_quantity) \
                     .one_or_none()
             if sensor is None:
                 sensor = db.query(Sensor) \
-                    .filter_by(source=Sensor.Sources.MASTER,
+                    .filter_by(source=Source.MASTER,
                                external_id=sensor_dto.external_id,
                                physical_quantity=None) \
                     .first()
@@ -276,7 +295,7 @@ class SensorController(BaseController):
                 if 'room' in sensor_dto.loaded_fields and sensor_dto.room is not None:
                     room = db.query(Room).filter_by(number=sensor_dto.room).one()
                 else:
-                    query = (Sensor.source == sensor_dto.source.type) \
+                    query = (Sensor.source == sensor_dto.source.source) \
                         & (Sensor.external_id == sensor_dto.external_id) \
                         & (Sensor.room != None)
                     sensor = db.query(Sensor).where(query).first()
@@ -284,8 +303,8 @@ class SensorController(BaseController):
                         room = sensor.room
                     else:
                         room = None
-                sensor = Sensor(id=get_sensor_orm_id(db, sensor_dto.source.type),
-                                source=sensor_dto.source.type,
+                sensor = Sensor(id=get_sensor_orm_id(db, sensor_dto.source.source),
+                                source=sensor_dto.source.source,
                                 external_id=sensor_dto.external_id,
                                 physical_quantity=sensor_dto.physical_quantity,
                                 unit=sensor_dto.unit,
@@ -293,12 +312,12 @@ class SensorController(BaseController):
                                 in_use=sensor_dto.in_use or True,
                                 room=room)
                 db.add(sensor)
-        if sensor.source == Sensor.Sources.MASTER and sensor.id > 200:
+        if sensor.source == Source.MASTER and sensor.id > 200:
             db.rollback()
             db.query(Sensor).filter_by(id=sensor.id).delete()
             db.commit()
             raise ValueError('Master sensor id {} out of range'.format(sensor.id))
-        if sensor.source == Sensor.Sources.PLUGIN and sensor.id < 500:
+        if sensor.source == Source.PLUGIN and sensor.id < 500:
             db.rollback()
             db.query(Sensor).filter_by(id=sensor.id).delete()
             db.commit()
@@ -308,17 +327,17 @@ class SensorController(BaseController):
         db.commit()  # explicit commit here because of id allocation
         return sensor, changed
 
-    def get_sensors_status(self):  # type: () -> List[SensorStatusDTO]
+    def get_sensors_status(self):  # type: () -> List[SensorStateDTO]
         """ Get the current status of all sensors.
         """
         return list(self._status.values())
 
-    def get_sensor_status(self, sensor_id):  # type: (int) -> Optional[SensorStatusDTO]
+    def get_sensor_status(self, sensor_id):  # type: (int) -> Optional[SensorStateDTO]
         """ Get the current status of a sensor.
         """
         return self._status.get(sensor_id)
 
-    def set_sensor_status(self, status_dto):  # type: (SensorStatusDTO) -> SensorStatusDTO
+    def set_sensor_status(self, status_dto):  # type: (SensorStateDTO) -> SensorStateDTO
         """ Update the current status of a (non master) sensor.
         """
         if status_dto.id < 200:
@@ -334,7 +353,7 @@ class SensorController(BaseController):
         with Database.get_session() as db:
             sensors = db.query(Sensor) \
                 .filter_by(physical_quantity=physical_quantity,
-                           source=Sensor.Sources.MASTER) \
+                           source=Source.MASTER) \
                 .all()
         try:
             sensor_count = max(s.id for s in sensors) + 1
@@ -351,26 +370,26 @@ class SensorController(BaseController):
 
         :returns: list with 32 temperatures, 1 for each sensor. None/null if not connected
         """
-        return self._translate_legacy_statuses(Sensor.PhysicalQuantities.TEMPERATURE)
+        return self._translate_legacy_statuses(SensorEnums.PhysicalQuantities.TEMPERATURE)
 
     def get_humidity_status(self):  # type: () -> List[Optional[float]]
         """ Get the current humidity of all sensors. """
-        return self._translate_legacy_statuses(Sensor.PhysicalQuantities.HUMIDITY)
+        return self._translate_legacy_statuses(SensorEnums.PhysicalQuantities.HUMIDITY)
 
     def get_brightness_status(self):  # type: () -> List[Optional[float]]
         """ Get the current brightness of all sensors. """
-        return self._translate_legacy_statuses(Sensor.PhysicalQuantities.BRIGHTNESS)
+        return self._translate_legacy_statuses(SensorEnums.PhysicalQuantities.BRIGHTNESS)
 
 
 def get_sensor_orm_id(db, source):
-    if source == Sensor.Sources.PLUGIN:
+    if source == Source.PLUGIN:
         # Plugins sensors use 510 or auto increment
         if db.query(Sensor).where(Sensor.id > 255).count() == 0:
             return 510
-    if source == Sensor.Sources.MASTER:
+    if source == Source.MASTER:
         # Master sensors use 1-200
         value = db.query(func.max(Sensor.id)) \
-            .where(Sensor.source == Sensor.Sources.MASTER) \
+            .where(Sensor.source == Source.MASTER) \
             .where(Sensor.id < 200) \
             .scalar()
         return (value or 0) + 1
diff --git a/src/gateway/shutter_controller.py b/src/gateway/shutter_controller.py
index 6f1a4ef7..2b8963fb 100644
--- a/src/gateway/shutter_controller.py
+++ b/src/gateway/shutter_controller.py
@@ -109,7 +109,6 @@ class ShutterController(BaseController):
         except CommunicationFailure as ex:
             logger.error('ORM sync (Shutter config): Failed: {0}'.format(ex))
         except Exception as e:
-            print(e)
             logger.exception('ORM sync (Shutter config): Failed')
 
     def update_config(self, config):  # type: (List[ShutterDTO]) -> bool
diff --git a/src/gateway/system_controller.py b/src/gateway/system_controller.py
index 42d6cc25..89ef46fd 100644
--- a/src/gateway/system_controller.py
+++ b/src/gateway/system_controller.py
@@ -56,6 +56,7 @@ class SystemController(object):
         self._master_controller = master_controller  # type: MasterController
         self._message_client = message_client  # type: MessageClient
         self._sync_time_thread = None  # type: Optional[DaemonThread]
+        self._master_serial_number = None  # type: Optional[str]
 
     def start(self):
         # type: () -> None
@@ -142,6 +143,7 @@ class SystemController(object):
     # Backup and restore functions
 
     def get_full_backup(self):
+        # type: () -> Iterable[bytes]
         """
         Get a backup (tar) of the master eeprom, the sqlite databases and the plugins
 
@@ -171,7 +173,8 @@ class SystemController(object):
 
         try:
             with open('{0}/master.eep'.format(tmp_sqlite_dir), 'wb') as eeprom_file:
-                eeprom_file.write(self._module_controller.get_master_backup())
+                for chunk in self._module_controller.get_master_backup():
+                    eeprom_file.write(chunk)
 
             for filename, source in {'config.db': constants.get_config_database_file(),
                                      'power.db': constants.get_power_database_file(),
@@ -218,12 +221,12 @@ class SystemController(object):
                 raise Exception('The backup tar could not be created.')
 
             with open('{0}/backup.tar'.format(tmp_dir), 'rb') as backup_file:
-                return backup_file.read()
-
+                yield backup_file.read()
         finally:
             shutil.rmtree(tmp_dir)
 
     def restore_full_backup(self, data):
+        # type: (bytearray) -> Dict[str, Any]
         """
         Restore a full backup containing the master eeprom and the sqlite databases.
 
@@ -250,8 +253,8 @@ class SystemController(object):
             # Check if the sqlite db's are in a folder or not for backwards compatibility
             src_dir = tmp_sqlite_dir if os.path.isdir(tmp_sqlite_dir) else tmp_dir
 
-            with open('{0}/master.eep'.format(src_dir), 'r') as eeprom_file:
-                eeprom_content = eeprom_file.read()
+            with open('{0}/master.eep'.format(src_dir), 'rb') as eeprom_file:
+                eeprom_content = bytearray(eeprom_file.read())
                 self._module_controller.master_restore(data=eeprom_content)
 
             for filename, target in {'config.db': constants.get_config_database_file(),
@@ -299,25 +302,34 @@ class SystemController(object):
         except subprocess.CalledProcessError as exc:
             return {'success': False, 'factory_reset': exc.output.strip()}
 
-        self.restart_services(service_names=['openmotics'])
+        self.restart_services(services=[System.Service.OPENMOTICS])
         if can:
             return {'factory_reset_full': 'pending'}
         return {'factory_reset': 'pending'}
 
-    def restart_services(self, service_names=None):
+    def restart_services(self, services=None):
         # type: (Optional[Iterable[str]]) -> Dict[str,Any]
-        def _restart(_service_names):
+        def _restart(_services):
             # type: (Iterable[str]) -> None
             logger.info('Restarting services...')
-            for service_name in _service_names:
-                System.restart_service(service_name)
+            for service in _services:
+                System.restart_service(service)
 
-        if service_names is None:
-            service_names = System.SERVICES
+        if services is None:
+            services = System.RESTARTABLE_SERVICES
 
-        Timer(2, _restart, args=[service_names]).start()
+        Timer(2, _restart, args=[services]).start()
         return {'restart_services': 'pending'}
 
+    def get_update_logs(self):
+        # type: () -> Dict[str,str]
+        output = {}
+        for file in glob.glob(os.path.join(constants.OPENMOTICS_PREFIX, 'update_logs', '*.log')):
+            name, _ , _ = os.path.basename(file).partition('.log')
+            with open(file, 'r') as fd:
+                output[name] = fd.read()
+        return output
+
     def get_logs(self):
         fh = io.BytesIO()
         with tarfile.open(fileobj=fh, mode='w:gz') as archive:
@@ -330,3 +342,14 @@ class SystemController(object):
             watchdog.start()
         else:
             watchdog.stop()
+
+    def get_master_serial_number(self):
+        # type: () -> Optional[str]
+        try:
+            return self._master_controller.get_serial_number()
+        except NotImplementedError as ex:
+            logger.warning("Requesting master serial number unsupported on this device")
+        except Exception as ex:
+            logger.exception("Unexpected error when requesting serial number: {}".format(ex))
+        return None
+
diff --git a/src/gateway/thermostat/gateway/hvac_drivers.py b/src/gateway/thermostat/gateway/hvac_drivers.py
new file mode 100644
index 00000000..02694cf9
--- /dev/null
+++ b/src/gateway/thermostat/gateway/hvac_drivers.py
@@ -0,0 +1,85 @@
+import logging
+from ioc import INJECTED, Inject
+from gateway.models import Database, Output, HvacOutputLink
+from gateway.dto.hvac_driver import HvacContactDTO
+
+if False:  # MYPY
+    from typing import Dict, List, Optional, Set
+    from gateway.output_controller import OutputController
+    from gateway.sensor_controller import SensorController
+
+logger = logging.getLogger(__name__)
+
+# general class for hvac drivers
+class HvacDriverParent(object):
+    def __init__(self, hvac_id):
+        self._hvac_id      = hvac_id  # TODO: currently hvac_id is the id of the thermostat group
+        self._old_mode     = None  # remember previous state to not spam the output with changes
+        self._old_delta_t  = None  # remember previous state to not spam the output with changes
+        self._old_setpoint = None  # remember previous state to not spam the output with changes
+
+
+    def _is_updated(self, mode, delta_t=None, setpoint=None):  # type: (str, float, float) -> bool
+        if mode is None:
+            logger.error('Steering hvac (id: {}) with mode None is not allowed '.format(self._hvac_id))
+
+        # if no new information is provided, return false
+        if mode == self._old_mode and delta_t == self._old_delta_t and setpoint == self._old_setpoint:
+            return False
+
+        self._old_mode     = mode
+        self._old_delta_t  = delta_t
+        self._old_setpoint = setpoint
+
+        return True
+
+    def steer(self, mode, delta_t=None, setpoint=None):  # type: (str, Optional[float], Optional[float]) -> None
+        raise NotImplementedError()
+
+
+# class for driving hvac contacts (switching modes)
+@Inject
+class HvacContactDriver(HvacDriverParent):
+    def __init__(self, hvac_id, output_controller=INJECTED):
+        super(HvacContactDriver, self).__init__(hvac_id)
+        self._output_controller = output_controller
+        self._output_list = []  # list of dto's with output information
+
+
+    def _update_from_database(self):
+        with Database.get_session() as db:
+            hvac_output_links = db.query(HvacOutputLink).filter_by(hvac_id=self._hvac_id).all()
+        if hvac_output_links is None:
+            return
+        new_output_list = []
+        for hvac_output_link in hvac_output_links:
+            new_output = HvacContactDTO(
+                    output_id = hvac_output_link.output_id,
+                    mode      = hvac_output_link.mode,
+                    value     = hvac_output_link.value
+                )
+            new_output_list.append(new_output)
+        self._output_list = new_output_list
+
+
+    # change value of outputs according to setting fetched from database
+    def steer(self, mode, delta_t=None, setpoint=None):  # type: (str, Optional[float], Optional[float]) -> None
+        # todo: take into account incremental steps        
+        if self._is_updated(mode, delta_t, setpoint) == False:  # do nothing if there is no change
+            return
+
+        if len(self._output_list) < 1:
+            logger.error("outputs need to be linked to hvac unit with id: {} ".format(self._hvac_id))
+            return
+
+        for output in self._output_list:
+            if output.mode != mode:
+                continue
+
+            value = output.value
+            value = max(0, min(value, 100))  # clampling on 0-100
+            self._output_controller.set_output_status(
+                                                        output_id=output.output_id, 
+                                                        is_on=value>0, 
+                                                        dimmer=value
+                                                    )
diff --git a/src/gateway/thermostat/gateway/setpoint_controller.py b/src/gateway/thermostat/gateway/setpoint_controller.py
new file mode 100644
index 00000000..03b7e801
--- /dev/null
+++ b/src/gateway/thermostat/gateway/setpoint_controller.py
@@ -0,0 +1,249 @@
+
+
+
+import logging
+from datetime import datetime, timedelta
+from ioc import INJECTED, Inject, Injectable, Singleton
+from gateway.dto import ScheduleDTO, ScheduleSetpointDTO
+from gateway.scheduling_controller import SchedulingController
+from gateway.models import Database, DaySchedule, Preset, Thermostat, ThermostatGroup
+
+
+if False:  # MYPY
+    from typing import Dict, List, Optional, Set, Tuple, Iterable
+    from gateway.output_controller import OutputController
+    from gateway.sensor_controller import SensorController
+
+
+logger = logging.getLogger(__name__)
+
+
+@Injectable.named('setpoint_controller')
+class SetpointController(object):
+    @Inject
+    def __init__(self, scheduling_controller=INJECTED):
+        self._thermostat_setpoints = {} # type: Dict[Tuple[int,str],List[ScheduleSetpointDTO]]
+        self._scheduling_controller = scheduling_controller
+
+
+
+
+    '''
+    Set a manual setpoint and activate manual mode
+    '''
+    def overrule_current_setpoint(self, thermostat_id, temperature=None, heating_temperature=None, cooling_temperature=None):
+        # type: (int, Optional[float], Optional[float], Optional[float]) -> None
+        with Database.get_session() as db:
+            thermostat = db.query(Thermostat).filter_by(number=thermostat_id).one()
+            self._overrule_current_setpoint(thermostat,
+                                       temperature=temperature,
+                                       heating_temperature=heating_temperature,
+                                       cooling_temperature=cooling_temperature)
+            db.commit()
+
+
+
+
+    '''
+    Activate a specific preset type
+    '''
+    def set_current_preset(self, thermostat_id, preset_type):  # type: (int, str) -> None
+        with Database.get_session() as db:
+            thermostat = db.query(Thermostat).filter_by(id=thermostat_id).one()  # type: Thermostat
+            self._set_current_preset(thermostat, preset_type=preset_type)
+            change = bool(db.dirty)
+            db.commit()
+        if change:
+            # self.tick_thermostat(thermostat_id)
+            pass
+
+
+
+
+    def get_current_setpoint(self, thermostat_id):  # type: (int) -> Dict
+        with Database.get_session() as db:
+            active_preset = db.query(Preset).filter_by(thermostat_id=thermostat_id).filter_by(active=True).one()
+
+        heating_setpoint = active_preset.heating_setpoint
+        cooling_setpoint = active_preset.cooling_setpoint
+        setpoint = (heating_setpoint + cooling_setpoint)/2
+        margin = abs(setpoint - heating_setpoint)
+
+        setpoint = {
+        "heating_setpoint" : heating_setpoint,  # minimum room temperature
+        "cooling_setpoint" : cooling_setpoint,  # maximum room temperature
+        "setpoint"         : setpoint,          # desired temperature
+        "margin"           : margin             # deviation on the desired temperature
+        }
+
+        return setpoint
+
+
+
+
+    '''
+    Here we check the current dayschedule of the thermostat and if there are changes we update the schedule.
+    The background schedule will then update the preset table for auto values and change the temperature on the saved triggers.
+    This allows implementing the dayschedule in presets.
+    '''
+    def update_thermostat_setpoints(self, thermostat_id, mode, day_schedules):
+        # type: (int, str, List[DaySchedule]) -> None
+        key = (thermostat_id, mode)
+        setpoints = []
+        for t, setpoint in self._calculate_transitions(day_schedules, datetime.now()):
+            setpoints.append(ScheduleSetpointDTO(thermostat=thermostat_id,
+                                                 mode=mode,
+                                                 temperature=setpoint,
+                                                 weekday=t.weekday(),
+                                                 hour=t.hour,
+                                                 minute=t.minute))
+        current_setpoints = self._thermostat_setpoints.get(key, [])
+        if current_setpoints != setpoints:
+            # remove the old triggers of the schedule
+            for setpoint_dto in current_setpoints:
+                self._scheduling_controller._abort(setpoint_dto)
+            # add the new triggers to the schedule
+            for setpoint_dto in setpoints:
+                self._scheduling_controller._submit_setpoint(setpoint_dto)
+            self._thermostat_setpoints[key] = setpoints
+
+
+
+
+    '''
+    This function solely acts as a manual overwrite of the setpoint:
+    1. if current mode = automatic      ->      simply overwrite the setpoints in the Preset table of type automatic
+                                                when there is a new transition, this manual setpoint will be overwritten
+                                                and follow the day schedule again
+    2. if current mode != automatic     ->      set manual mode active in preset table and other modes inactive
+                                                set manual mode temperatures accordingly
+    '''
+    def _overrule_current_setpoint(self, thermostat, temperature=None, heating_temperature=None, cooling_temperature=None):
+        # type: (Thermostat, Optional[float], Optional[float], Optional[float]) -> bool
+        if not any([temperature, heating_temperature, cooling_temperature]):
+            return False
+
+        active_preset = thermostat.active_preset  # type: Optional[Preset]
+
+        # check if the active preset is automatic or manual, if not, fetch/create a manual preset
+        if active_preset is None or active_preset.type not in [Preset.Types.AUTO, Preset.Types.MANUAL]:
+            # loop over all the presets and get the preset of manual type if exists, alse None
+            active_preset = next((x for x in thermostat.presets if x.type == Preset.Types.MANUAL), None)
+            # if no preset was found, create a manual preset
+            if active_preset is None:
+                active_preset = Preset(type=Preset.Types.MANUAL)
+                thermostat.presets.append(active_preset)
+
+            self._set_preset_active(thermostat, active_preset)
+
+        if heating_temperature is None:
+            heating_temperature = temperature
+        if heating_temperature is not None:
+            active_preset.heating_setpoint = float(heating_temperature)  # type: ignore
+
+        if cooling_temperature is None:
+            cooling_temperature = temperature
+        if cooling_temperature is not None:
+            active_preset.cooling_setpoint = float(cooling_temperature)  # type: ignore
+        return True
+
+
+
+
+    '''
+    Activate a specific preset type
+    '''
+    def _set_current_preset(self, thermostat, preset_type):  # type: (Thermostat, str) -> None
+        preset = next((x for x in thermostat.presets if x.type == preset_type), None)  # type: Optional[Preset]
+        if preset is None:
+            preset = Preset(thermostat=thermostat, type=preset_type,
+                            heating_setpoint=Preset.DEFAULT_PRESETS['heating'].get(preset_type, 14.0),
+                            cooling_setpoint=Preset.DEFAULT_PRESETS['cooling'].get(preset_type, 30.0))  # type: ignore
+
+        if preset.type == Preset.Types.AUTO:
+            self._update_auto_preset(thermostat)
+
+        self._set_preset_active(thermostat, preset)
+
+
+
+
+    '''
+    Fetch the thermostat schedule from the Dayschedule table
+    Determine if a transition needs to be made in the schedule?
+    If yes, update the temperature for the auto preset of said thermostat
+    This does not mean that the thermostat is in auto mode, we simply update the preset values
+    '''
+    def _update_auto_preset(self, thermostat):  #type: (Thermostat) -> None
+        # fetch or create auto preset
+        preset = next((x for x in thermostat.presets if x.type == Preset.Types.AUTO), None)
+        if preset is None:
+            preset = Preset(type=Preset.Types.AUTO)
+            thermostat.presets.append(preset)
+
+        items = [(ThermostatGroup.Modes.HEATING, 'heating_setpoint', thermostat.heating_schedules),
+                 (ThermostatGroup.Modes.COOLING, 'cooling_setpoint', thermostat.cooling_schedules)]
+        for mode, field, day_schedules in items:
+            try:
+                if not day_schedules:
+                    for i in range(7):
+                        schedule = DaySchedule(index=i, thermostat=thermostat, mode=mode)
+                        schedule.schedule_data = DaySchedule.DEFAULT_SCHEDULE[mode]
+                        day_schedules.append(schedule)
+                _, setpoint = self.last_thermostat_setpoint(day_schedules)
+                setattr(preset, field, setpoint)
+            except StopIteration:
+                logger.warning('could not determine %s setpoint from schedule', mode)
+
+
+
+
+    '''
+    extract setpoint from dayschedule
+    '''
+    def last_thermostat_setpoint(self, day_schedules):
+        # type: (List[DaySchedule]) -> Tuple[datetime, float]
+        now = datetime.now()
+        transitions = sorted(self._calculate_transitions(day_schedules, now), reverse=True)
+        return next((t, v) for t, v in transitions if t <= now)
+
+
+
+
+    """
+    Calculate the setpoint transitions relative to a timestamp based on the
+    given day schedules.
+    """
+    def _calculate_transitions(self, day_schedules, at):
+        # type: (List[DaySchedule], datetime) -> Iterable[Tuple[datetime, float]]
+        index = at.weekday()
+        start_of_day = datetime(at.year, at.month, at.day)
+
+        data = {}
+        for day_schedule in day_schedules:
+            offset = max(day_schedule.index, index) - min(day_schedule.index, index)
+            # Shift last day schedule when at start of the week.
+            if index == 0 and day_schedule.index == 6:
+                offset -= 7
+            if day_schedule.index < index:
+                offset = -offset
+            d = start_of_day + timedelta(days=offset)
+            data.update({d + timedelta(seconds=int(k)): v
+                         for k, v in day_schedule.schedule_data.items()})
+        return sorted(data.items())
+
+
+
+
+    def _set_preset_active(self, thermostat, preset):  #type: (Thermostat, Preset) -> None
+        if thermostat.active_preset != preset:
+            for p in thermostat.presets:
+                p.active = False
+            preset.active = True
+
+
+
+
+
+
+ 
\ No newline at end of file
diff --git a/src/gateway/thermostat/gateway/thermostat_controller_gateway.py b/src/gateway/thermostat/gateway/thermostat_controller_gateway.py
index 35fb6d76..ef9ac73f 100644
--- a/src/gateway/thermostat/gateway/thermostat_controller_gateway.py
+++ b/src/gateway/thermostat/gateway/thermostat_controller_gateway.py
@@ -14,33 +14,32 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 import logging
-from datetime import datetime, timedelta
+from datetime import datetime
 
-from sqlalchemy import select, update
+from sqlalchemy import select
 
 from gateway.daemon_thread import DaemonThread
-from gateway.dto import RTD10DTO, GlobalRTD10DTO, PumpGroupDTO, ScheduleDTO, \
-    ThermostatDTO, ThermostatGroupDTO, ThermostatGroupStatusDTO, \
-    ThermostatStatusDTO
-from gateway.enums import ThermostatMode, ThermostatState
+from gateway.dto import PumpGroupDTO, ThermostatDTO, ThermostatGroupDTO, \
+    ThermostatGroupStatusDTO, ThermostatStatusDTO
+from gateway.enums import SensorEnums, ThermostatMode, ThermostatState
 from gateway.events import GatewayEvent
 from gateway.exceptions import UnsupportedException
 from gateway.hal.master_event import MasterEvent
 from gateway.mappers import ThermostatMapper
 from gateway.models import Database, DaySchedule, Output, \
-    OutputToThermostatGroupAssociation, Preset, Pump, PumpToValveAssociation, \
-    Schedule, Sensor, Thermostat, ThermostatGroup, Valve, \
-    ValveToThermostatAssociation
+    HvacOutputLink, Preset, Pump, Sensor, Thermostat, \
+    ThermostatGroup, Valve
 from gateway.pubsub import PubSub
+from gateway.valve_pump.valve_pump_controller import ValvePumpController
 from gateway.scheduling_controller import SchedulingController
-from gateway.thermostat.gateway.pump_valve_controller import \
-    PumpValveController
 from gateway.thermostat.gateway.thermostat_pid import ThermostatPid
 from gateway.thermostat.thermostat_controller import ThermostatController
+from gateway.thermostat.gateway.hvac_drivers import HvacContactDriver
+from gateway.thermostat.gateway.setpoint_controller import SetpointController
 from ioc import INJECTED, Inject
 
 if False:  # MYPY
-    from typing import Dict, Iterable, List, Optional, Tuple, Set
+    from typing import Dict, List, Optional, Set, Tuple
     from gateway.output_controller import OutputController
     from gateway.sensor_controller import SensorController
 
@@ -57,22 +56,23 @@ class ThermostatControllerGateway(ThermostatController):
     PUMP_UPDATE_INTERVAL = 30
 
     @Inject
-    def __init__(self, output_controller=INJECTED, sensor_controller=INJECTED, scheduling_controller=INJECTED, pubsub=INJECTED):
-        # type: (OutputController, SensorController, SchedulingController, PubSub) -> None
+    def __init__(self, output_controller=INJECTED, sensor_controller=INJECTED, setpoint_controller=INJECTED, pubsub=INJECTED, valve_pump_controller=INJECTED):
+        # type: (OutputController, SensorController, SetpointController, PubSub, ValvePumpController) -> None
         super(ThermostatControllerGateway, self).__init__(output_controller)
         self._sensor_controller = sensor_controller
-        self._scheduling_controller = scheduling_controller
+        self._setpoint_controller = setpoint_controller
         self._pubsub = pubsub
+        self._valve_pump_controller = valve_pump_controller
         self._running = False
         self._sync_auto_setpoints = True
         self._pid_loop_thread = None  # type: Optional[DaemonThread]
-        self._update_pumps_thread = None  # type: Optional[DaemonThread]
         self.thermostat_pids = {}  # type: Dict[int, ThermostatPid]
-        self._pump_valve_controller = PumpValveController()
 
         self._pubsub.subscribe_gateway_events(PubSub.GatewayTopics.SCHEDULER, self._handle_scheduler_event)
         self._pubsub.subscribe_master_events(PubSub.MasterTopics.THERMOSTAT, self._handle_master_event)
 
+        self._drivers = {}  # type: Dict[int, HvacContactDriver]
+
     def get_features(self):
         # type: () -> Set[str]
         return {'thermostats_gateway',
@@ -87,10 +87,6 @@ class ThermostatControllerGateway(ThermostatController):
                                                  interval=self.THERMOSTAT_PID_UPDATE_INTERVAL)
             self._pid_loop_thread.start()
 
-            self._update_pumps_thread = DaemonThread(name='thermostatpumps',
-                                                     target=self._update_pumps,
-                                                     interval=self.PUMP_UPDATE_INTERVAL)
-            self._update_pumps_thread.start()
             super(ThermostatControllerGateway, self).start()
             logger.info('Starting gateway thermostatcontroller... Done')
         else:
@@ -102,8 +98,6 @@ class ThermostatControllerGateway(ThermostatController):
         self._running = False
         if self._pid_loop_thread is not None:
             self._pid_loop_thread.stop()
-        if self._update_pumps_thread is not None:
-            self._update_pumps_thread.stop()
         super(ThermostatControllerGateway, self).stop()
 
     def _pid_tick(self):  # type: () -> None
@@ -152,12 +146,20 @@ class ThermostatControllerGateway(ThermostatController):
                         stmt = select(Thermostat.number)  # type: ignore
                         numbers = db.execute(stmt).scalars()
                     for thermostat_nr in numbers:
-                        self.set_current_preset(thermostat_nr, preset_type=preset)
+                        thermostat_id = self._thermostatnr_to_thermostatid(thermostat_nr)
+                        if thermostat_id is not None:
+                            self._setpoint_controller.set_current_preset(thermostat_id=thermostat_id, preset_type=preset)
                     logger.info('Changed preset for all Thermostats to {0} by master event'.format(preset))
 
+
     def refresh_config_from_db(self):  # type: () -> None
         self.refresh_thermostats_from_db()
-        self._pump_valve_controller.refresh_from_db()
+        self._valve_pump_controller.update_from_db()
+
+
+        # update heating/cooling output drivers
+        for key, driver in self._drivers.items():
+            driver._update_from_database()
 
     def refresh_thermostats_from_db(self):  # type: () -> None
         self._sync_auto_presets()
@@ -167,7 +169,7 @@ class ThermostatControllerGateway(ThermostatController):
                 removed_thermostats.discard(thermostat.number)
                 pid = self.thermostat_pids.get(thermostat.number)
                 if pid is None:
-                    pid = ThermostatPid(thermostat, self._pump_valve_controller)
+                    pid = ThermostatPid(thermostat)
                     pid.subscribe_state_changes(self._thermostat_changed)
                     self.thermostat_pids[thermostat.number] = pid
             # TODO: Delete stale/removed thermostats
@@ -182,12 +184,6 @@ class ThermostatControllerGateway(ThermostatController):
                     pid.update_thermostat()
                     pid.tick()
 
-    def _update_pumps(self):  # type: () -> None
-        try:
-            self._pump_valve_controller.steer()
-        except Exception:
-            logger.exception('Could not update pumps.')
-
     def _sync(self):  # type: () -> None
         # refresh the config from the database
         try:
@@ -216,6 +212,7 @@ class ThermostatControllerGateway(ThermostatController):
                 logger.exception('Could not publish %s', pid)
 
     def _sync_auto_presets(self):
+        # update preset table auto column when "_sync_auto_setpoints" is True for ?all thermostats
         # type: () -> None
         if not self._sync_auto_setpoints:
             return
@@ -234,7 +231,7 @@ class ThermostatControllerGateway(ThermostatController):
                                 schedule = DaySchedule(index=i, thermostat=preset.thermostat, mode=mode)
                                 schedule.schedule_data = DaySchedule.DEFAULT_SCHEDULE[mode]
                                 day_schedules.append(schedule)
-                        _, setpoint = self._scheduling_controller.last_thermostat_setpoint(day_schedules)
+                        _, setpoint = self._setpoint_controller.last_thermostat_setpoint(day_schedules)
                         setattr(preset, field, setpoint)
                     except StopIteration:
                         logger.warning('could not determine %s setpoint from schedule', mode)
@@ -247,91 +244,24 @@ class ThermostatControllerGateway(ThermostatController):
                 thermostat = db.query(Thermostat).filter_by(number=thermostat_id).one()  # type: Thermostat
                 for mode, day_schedules in [(ThermostatGroup.Modes.HEATING, thermostat.heating_schedules),
                                             (ThermostatGroup.Modes.COOLING, thermostat.cooling_schedules)]:
-                    self._scheduling_controller.update_thermostat_setpoints(thermostat_id, mode, day_schedules)
+                    self._setpoint_controller.update_thermostat_setpoints(thermostat_id, mode, day_schedules)
 
     def set_current_setpoint(self, thermostat_id, temperature=None, heating_temperature=None, cooling_temperature=None):
         # type: (int, Optional[float], Optional[float], Optional[float]) -> None
         with Database.get_session() as db:
             thermostat = db.query(Thermostat).filter_by(number=thermostat_id).one()
-            self._set_current_setpoint(thermostat,
+            self._setpoint_controller._overrule_current_setpoint(thermostat,
                                        temperature=temperature,
                                        heating_temperature=heating_temperature,
                                        cooling_temperature=cooling_temperature)
             db.commit()
         self.tick_thermostat(thermostat_id)
 
-    def _set_current_setpoint(self, thermostat, temperature=None, heating_temperature=None, cooling_temperature=None):
-        # type: (Thermostat, Optional[float], Optional[float], Optional[float]) -> bool
-        if temperature is None and heating_temperature is None and cooling_temperature is None:
-            return False
-
-        # When setting a setpoint manually, switch to manual preset except for when we are in scheduled mode
-        # scheduled mode will override the setpoint when the next edge in the schedule is triggered
-        active_preset = thermostat.active_preset  # type: Optional[Preset]
-        if active_preset is None or active_preset.type not in [Preset.Types.AUTO, Preset.Types.MANUAL]:
-            active_preset = next((x for x in thermostat.presets if x.type == Preset.Types.MANUAL), None)
-            if active_preset is None:
-                active_preset = Preset(type=Preset.Types.MANUAL)
-                thermostat.presets.append(active_preset)
-            for p in thermostat.presets:
-                p.active = False
-            active_preset.active = True
-
-        if heating_temperature is None:
-            heating_temperature = temperature
-        if heating_temperature is not None:
-            active_preset.heating_setpoint = float(heating_temperature)  # type: ignore
-
-        if cooling_temperature is None:
-            cooling_temperature = temperature
-        if cooling_temperature is not None:
-            active_preset.cooling_setpoint = float(cooling_temperature)  # type: ignore
-        return True
-
     def get_current_preset(self, thermostat_number):  # type: (int) -> str
         with Database.get_session() as db:
             thermostat = db.query(Thermostat).filter_by(number=thermostat_number).one()  # type: Thermostat
             return thermostat.active_preset.type
 
-    def set_current_preset(self, thermostat_id, preset_type):  # type: (int, str) -> None
-        with Database.get_session() as db:
-            thermostat = db.query(Thermostat).filter_by(number=thermostat_id).one()  # type: Thermostat
-            self._set_current_preset(thermostat, preset_type=preset_type)
-            change = bool(db.dirty)
-            db.commit()
-        if change:
-            self.tick_thermostat(thermostat_id)
-
-    def _set_current_preset(self, thermostat, preset_type):
-        # type: (Thermostat, str) -> None
-        preset = next((x for x in thermostat.presets if x.type == preset_type), None)  # type: Optional[Preset]
-        if preset is None:
-            preset = Preset(thermostat=thermostat, type=preset_type,
-                            heating_setpoint=Preset.DEFAULT_PRESETS['heating'].get(preset_type, 14.0),
-                            cooling_setpoint=Preset.DEFAULT_PRESETS['cooling'].get(preset_type, 30.0))  # type: ignore
-
-        if preset.type == Preset.Types.AUTO:
-            # Restore setpoint from auto schedule.
-            now = datetime.now()
-            items = [(ThermostatGroup.Modes.HEATING, 'heating_setpoint', thermostat.heating_schedules),
-                     (ThermostatGroup.Modes.COOLING, 'cooling_setpoint', thermostat.cooling_schedules)]
-            for mode, field, day_schedules in items:
-                try:
-                    if not day_schedules:
-                        for i in range(7):
-                            schedule = DaySchedule(index=i, thermostat=thermostat, mode=mode)
-                            schedule.schedule_data = DaySchedule.DEFAULT_SCHEDULE[mode]
-                            day_schedules.append(schedule)
-                    _, setpoint = self._scheduling_controller.last_thermostat_setpoint(day_schedules)
-                    setattr(preset, field, setpoint)
-                except StopIteration:
-                    logger.warning('could not determine %s setpoint from schedule', mode)
-
-        if thermostat.active_preset != preset:
-            for p in thermostat.presets:
-                p.active = False
-            preset.active = True
-
     def _set_current_state(self, thermostat, state):
         # type: (Thermostat, str) -> None
         thermostat.state = state
@@ -436,12 +366,19 @@ class ThermostatControllerGateway(ThermostatController):
 
     def set_thermostat_group(self, thermostat_group_id, state=None, mode=None):
         # type: (int, Optional[str], Optional[str]) -> None
+
+        # check if a driver already exists, create a driver if not
+        if thermostat_group_id not in self._drivers:
+            self._drivers[thermostat_group_id] = HvacContactDriver(thermostat_group_id)
+        # fetch the driver for this thermostat group
+        driver = self._drivers[thermostat_group_id]
+
         with Database.get_session() as db:
             thermostat_group = db.query(ThermostatGroup).filter_by(number=thermostat_group_id).one()  # type: ThermostatGroup
             changed = False
             if mode is not None and thermostat_group.mode != mode:
                 thermostat_group.mode = mode
-                self._set_mode_outputs(thermostat_group)
+                driver.steer(mode=mode)
                 self._thermostat_group_changed(thermostat_group)
                 changed = True
             if changed or state is not None:
@@ -449,7 +386,7 @@ class ThermostatControllerGateway(ThermostatController):
                     if state is not None:
                         self._set_current_state(thermostat,
                                                 state=state)
-                    self._set_current_preset(thermostat=thermostat,
+                    self._setpoint_controller._set_current_preset(thermostat=thermostat,
                                              preset_type=Preset.Types.AUTO)
             change = bool(db.dirty)
             db.commit()
@@ -457,13 +394,6 @@ class ThermostatControllerGateway(ThermostatController):
                 for thermostat in thermostat_group.thermostats:
                     self.tick_thermostat(thermostat.number)
 
-    def _set_mode_outputs(self, thermostat_group):  # type: (ThermostatGroup) -> None
-        associations = getattr(thermostat_group, '{0}_output_associations'.format(thermostat_group.mode))  # type: List[OutputToThermostatGroupAssociation]
-        for output_to_thermostat_group in associations:
-            self._output_controller.set_output_status(output_id=output_to_thermostat_group.output.number,
-                                                      is_on=output_to_thermostat_group.value > 0,
-                                                      dimmer=output_to_thermostat_group.value)
-
     def load_heating_thermostat(self, thermostat_id):  # type: (int) -> ThermostatDTO
         mode = ThermostatMode.HEATING
         with Database.get_session() as db:
@@ -545,7 +475,7 @@ class ThermostatControllerGateway(ThermostatController):
                 preset_type = Preset.Types.AUTO  # type: str
             else:
                 preset_type = Preset.SETPOINT_TO_TYPE.get(setpoint, Preset.Types.AUTO)
-            self._set_current_preset(thermostat, preset_type=preset_type)
+            self._setpoint_controller._set_current_preset(thermostat, preset_type=preset_type)
             change = bool(db.dirty)
             db.commit()
         if change:
@@ -557,14 +487,14 @@ class ThermostatControllerGateway(ThermostatController):
             thermostat = db.query(Thermostat).filter_by(number=thermostat_id).one()
             change = False
             if preset is not None:
-                self._set_current_preset(thermostat,
+                self._setpoint_controller._set_current_preset(thermostat,
                                          preset_type=preset)
             if state is not None:
                 self._set_current_state(thermostat=thermostat,
                                         state=state)
             if temperature is not None:
-                self._set_current_setpoint(thermostat=thermostat,
-                                           temperature=temperature)
+                self._setpoint_controller._overrule_current_setpoint(thermostat=thermostat,
+                                                               temperature=temperature)
             change = bool(db.dirty)
             db.commit()
         if change:
@@ -611,17 +541,27 @@ class ThermostatControllerGateway(ThermostatController):
                                                       pump_delay=pump_delay)
             for mode, associations in [(ThermostatGroup.Modes.HEATING, group.heating_output_associations),
                                        (ThermostatGroup.Modes.COOLING, group.cooling_output_associations)]:
+                index = 0
                 for output_to_thermostat_group in associations:
-                    field = 'switch_to_{0}_{1}'.format(mode, output_to_thermostat_group.index)
+                    field = 'switch_to_{0}_{1}'.format(mode, index)
                     setattr(thermostat_group_dto, field, (output_to_thermostat_group.output.number, output_to_thermostat_group.value))
+                    index += 1
             return thermostat_group_dto
 
+
+
     def save_thermostat_groups(self, thermostat_groups):  # type: (List[ThermostatGroupDTO]) -> None
         # Update thermostat group configuration
         logger.debug('saving %s', thermostat_groups)
         with Database.get_session() as db:
+
+            # get all available groups from the database as a dictionary Dict[group_number, ThermostatGroup]
             groups = {x.number: x for x in db.query(ThermostatGroup)}  # type: Dict[int, ThermostatGroup]
+
+            # loop over all the new information from the api call
             for thermostat_group_dto in thermostat_groups:
+
+                # get the group database object & update information
                 thermostat_group = groups.get(thermostat_group_dto.id)
                 if thermostat_group is None:
                     logger.info('creating <ThermostatGroup %s>', thermostat_group_dto.id)
@@ -634,7 +574,7 @@ class ThermostatControllerGateway(ThermostatController):
                         thermostat_group.sensor = None
                     else:
                         sensor = db.get(Sensor, thermostat_group_dto.outside_sensor_id)  # type: Sensor
-                        if sensor.physical_quantity != Sensor.PhysicalQuantities.TEMPERATURE:
+                        if sensor.physical_quantity != SensorEnums.PhysicalQuantities.TEMPERATURE:
                             raise ValueError('Invalid <Sensor %s %s> for ThermostatGroup' % (sensor.id, sensor.physical_quantity))
                         thermostat_group.sensor = sensor
                 if 'threshold_temperature' in thermostat_group_dto.loaded_fields:
@@ -642,38 +582,49 @@ class ThermostatControllerGateway(ThermostatController):
                 if thermostat_group in db.dirty:
                     self._thermostat_group_changed(thermostat_group)
 
-                # Link configuration outputs to global thermostat config
+                # Link configuration outputs to global thermostat config, from here on we update the outputs linked to a group
                 for mode, associations in [(ThermostatMode.HEATING, thermostat_group.heating_output_associations),
-                                           (ThermostatMode.COOLING, thermostat_group.cooling_output_associations)]:
+                                           (ThermostatMode.COOLING, thermostat_group.cooling_output_associations)
+                                           # (thermostatMode.OFF, thermostat_group.off_output_associations)
+                                           ]:
+
+                    # we currently allow 4 connections for both heating and cooling (8 total)
                     for i in range(4):
                         field = 'switch_to_{0}_{1}'.format(mode, i)
+
+                        # check if this field is provided in the api call / dto object
                         if field not in thermostat_group_dto.loaded_fields:
                             continue
 
+                        # check if an association exists
                         try:
-                            output_to_thermostat_group = associations[i]
+                            hvac_output_link = associations[i]  # type: Optional[HvacOutputLink]
                         except IndexError:
-                            output_to_thermostat_group = None
-                        data = getattr(thermostat_group_dto, field)
+                            hvac_output_link = None
+
+                        data = getattr(thermostat_group_dto, field)  # type: Tuple[int, int]
                         if data is None:
-                            if output_to_thermostat_group is not None:
-                                db.delete(output_to_thermostat_group)
+                            if hvac_output_link is not None:
+                                db.delete(hvac_output_link)
                         else:
                             output_number, value = data
                             output = db.query(Output).filter_by(number=output_number).one()  # type: Output
-                            if output_to_thermostat_group is None:
+
+                            # create new output entry if none exists
+                            if hvac_output_link is None:
                                 db.add(
-                                    OutputToThermostatGroupAssociation(
-                                        thermostat_group=thermostat_group,
+                                    HvacOutputLink(
+                                        hvac=thermostat_group,
                                         mode=mode,
-                                        index=i,
                                         output=output,
                                         value=value
                                     )
                                 )
+
+                            # update output entry if one exists
                             else:
-                                output_to_thermostat_group.output = output
-                                output_to_thermostat_group.value = value
+                                hvac_output_link.output = output
+                                hvac_output_link.value = value
 
                 if 'pump_delay' in thermostat_group_dto.loaded_fields:
                     # Set valve delay for all valves in this group
@@ -686,6 +637,8 @@ class ThermostatControllerGateway(ThermostatController):
         if self._sync_thread:
             self._sync_thread.request_single_run()
 
+
+
     def remove_thermostat_groups(self, thermostat_group_ids):  # type: (List[int]) -> None
         with Database.get_session() as db:
             for group_id in thermostat_group_ids:
@@ -782,9 +735,6 @@ class ThermostatControllerGateway(ThermostatController):
             db.commit()
         self._thermostat_config_changed()
 
-    def load_global_rtd10(self):  # type: () -> GlobalRTD10DTO
-        raise UnsupportedException()
-
     def _thermostat_config_changed(self):
         gateway_event = GatewayEvent(GatewayEvent.Types.CONFIG_CHANGE, {'type': 'thermostats'})
         self._pubsub.publish_gateway_event(PubSub.GatewayTopics.CONFIG, gateway_event)
@@ -810,31 +760,11 @@ class ThermostatControllerGateway(ThermostatController):
                                       'status': {'mode': thermostat_group.mode.upper()}})
         self._pubsub.publish_gateway_event(PubSub.GatewayTopics.STATE, gateway_event)
 
-    # Obsolete unsupported calls
-
-    def save_global_rtd10(self, rtd10):  # type: (GlobalRTD10DTO) -> None
-        raise UnsupportedException()
-
-    def load_heating_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        raise UnsupportedException()
-
-    def load_heating_rtd10s(self):  # type: () -> List[RTD10DTO]
-        raise UnsupportedException()
-
-    def save_heating_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        raise UnsupportedException()
-
-    def load_cooling_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        raise UnsupportedException()
-
-    def load_cooling_rtd10s(self):  # type: () -> List[RTD10DTO]
-        raise UnsupportedException()
-
-    def save_cooling_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        raise UnsupportedException()
+    def _thermostatnr_to_thermostatid(self, thermostat_nr):  # type: (int) -> Optional[int]
+        with Database.get_session() as db:
+            thermostat = db.query(Thermostat).filter_by(number=thermostat_nr).one_or_none()  # type: Optional[ThermostatGroup]
+        if thermostat is not None:
+            return thermostat.id
+        return None
 
-    def set_airco_status(self, thermostat_id, airco_on):
-        raise UnsupportedException()
 
-    def load_airco_status(self):
-        raise UnsupportedException()
diff --git a/src/gateway/thermostat/gateway/thermostat_pid.py b/src/gateway/thermostat/gateway/thermostat_pid.py
index e95c460a..2ae20106 100644
--- a/src/gateway/thermostat/gateway/thermostat_pid.py
+++ b/src/gateway/thermostat/gateway/thermostat_pid.py
@@ -20,7 +20,8 @@ from simple_pid import PID
 
 from gateway.dto import ThermostatStatusDTO
 from gateway.enums import ThermostatState
-from gateway.models import Database, Thermostat, ThermostatGroup
+from gateway.models import Database, Thermostat, ThermostatGroup, IndoorLinkValves
+from gateway.valve_pump.valve_pump_driver import ValvePumpDriver
 from ioc import INJECTED, Inject
 from serial_utils import CommunicationTimedOutException
 
@@ -38,10 +39,10 @@ class ThermostatPid(object):
     DEFAULT_KI = 0.0
     DEFAULT_KD = 2.0
 
-    def __init__(self, thermostat, pump_valve_controller, sensor_controller=INJECTED):
+    def __init__(self, thermostat, valve_pump_controller=INJECTED, sensor_controller=INJECTED):
         # type: (Thermostat, PumpValveController, SensorController) -> None
         self._sensor_controller = sensor_controller
-        self._pump_valve_controller = pump_valve_controller
+        self._pump_valve_controller = valve_pump_controller  # todo: this is only here to update the status of valve positions, will be changed further down the line
         self._thermostat_change_lock = Lock()
         self._sensor_id = None  # type: Optional[int]
         self._heating_valve_ids = []  # type: List[int]
@@ -60,6 +61,8 @@ class ThermostatPid(object):
         self._current_steering_power = None  # type: Optional[int]
         self._current_enabled = None  # type: Optional[bool]
         self._current_setpoint = None  # type: Optional[float]
+        self._driver_heating = None  # type: Optional[ValvePumpDriver]
+        self._driver_cooling = None  # type: Optional[ValvePumpDriver]
 
     @property
     def enabled(self):  # type: () -> bool
@@ -95,8 +98,8 @@ class ThermostatPid(object):
                 self._active_preset_type = thermostat.active_preset.type
 
                 self._sensor_id = thermostat.sensor.id if thermostat.sensor else None
-                self._heating_valve_ids = [x.valve.id for x in thermostat.heating_valve_associations]
-                self._cooling_valve_ids = [x.valve.id for x in thermostat.cooling_valve_associations]
+                self._heating_valve_ids = [x.valve_id for x in thermostat.heating_valve_associations]
+                self._cooling_valve_ids = [x.valve_id for x in thermostat.cooling_valve_associations]
 
                 if thermostat.group.mode == ThermostatGroup.Modes.HEATING:
                     pid_p = thermostat.pid_heating_p if thermostat.pid_heating_p is not None else self.DEFAULT_KP
@@ -109,11 +112,24 @@ class ThermostatPid(object):
                     pid_d = thermostat.pid_cooling_d if thermostat.pid_cooling_d is not None else self.DEFAULT_KD
                     setpoint = thermostat.active_preset.cooling_setpoint
 
+                # create the driver if not exist
+                if self._driver_heating is None:
+                    self._driver_heating = ValvePumpDriver(thermostat.id, 'heating')
+                if self._driver_cooling is None:
+                    self._driver_cooling = ValvePumpDriver(thermostat.id, 'cooling')
+
+                # update the driver if exist
+                if self._driver_heating is not None:
+                    self._driver_heating.update_from_db()
+                if self._driver_cooling is not None:
+                    self._driver_cooling.update_from_db()
+
             self._pid.tunings = (pid_p, pid_i, pid_d)
             self._pid.setpoint = setpoint
             self._pid.output_limits = (-100, 100)
             self._errors = 0
 
+
     @property
     def steering_power(self):  # type: () -> Optional[int]
         return self._current_steering_power
@@ -199,19 +215,21 @@ class ThermostatPid(object):
         if self._current_steering_power != power:
             logger.info('Thermostat {0}: Steer to {1} '.format(self._number, power))
             self._current_steering_power = power
+        else:
+            return
+
+        # Steer drivers
+        if self._driver_heating is None or self._driver_cooling is None:
+            return
 
-        # Configure valves and set desired opening
-        # TODO: Check union to avoid opening same valves in heating and cooling
         if power > 0:
-            self._pump_valve_controller.set_valves(0, self._cooling_valve_ids, mode=self._valve_config)
-            self._pump_valve_controller.set_valves(power, self._heating_valve_ids, mode=self._valve_config)
+            self._driver_heating.steer(power)
+            self._driver_cooling.steer(0)
         else:
             power = abs(power)
-            self._pump_valve_controller.set_valves(0, self._heating_valve_ids, mode=self._valve_config)
-            self._pump_valve_controller.set_valves(power, self._cooling_valve_ids, mode=self._valve_config)
+            self._driver_heating.steer(0)
+            self._driver_cooling.steer(power)
 
-        # Effectively steer pumps and valves according to needs
-        self._pump_valve_controller.steer()
 
     @property
     def kp(self):  # type: () -> float
diff --git a/src/gateway/thermostat/master/thermostat_controller_master.py b/src/gateway/thermostat/master/thermostat_controller_master.py
index 8c412f2b..f74d9ab0 100644
--- a/src/gateway/thermostat/master/thermostat_controller_master.py
+++ b/src/gateway/thermostat/master/thermostat_controller_master.py
@@ -17,9 +17,9 @@ import logging
 import time
 
 from gateway.daemon_thread import DaemonThread, DaemonThreadWait
-from gateway.dto import RTD10DTO, GlobalRTD10DTO, PumpGroupDTO, \
-    ThermostatAircoStatusDTO, ThermostatDTO, ThermostatGroupDTO, \
+from gateway.dto import PumpGroupDTO, ThermostatDTO, ThermostatGroupDTO, \
     ThermostatGroupStatusDTO, ThermostatScheduleDTO, ThermostatStatusDTO
+from gateway.enums import SensorEnums, Source
 from gateway.events import GatewayEvent
 from gateway.exceptions import CommunicationFailure, \
     FeatureUnavailableException
@@ -258,8 +258,8 @@ class ThermostatControllerMaster(ThermostatController):
         else:
             with Database.get_session() as db:
                 sensor = db.query(Sensor) \
-                    .filter_by(source=Sensor.Sources.MASTER,
-                               physical_quantity=Sensor.PhysicalQuantities.TEMPERATURE,
+                    .filter_by(source=Source.MASTER,
+                               physical_quantity=SensorEnums.PhysicalQuantities.TEMPERATURE,
                                external_id=str(sensor_id)) \
                     .first()
                 if sensor is None:
@@ -274,9 +274,9 @@ class ThermostatControllerMaster(ThermostatController):
         else:
             with Database.get_session() as db:
                 sensor = db.get(Sensor, sensor_id)
-                if sensor.source != Sensor.Sources.MASTER:
+                if sensor.source != Source.MASTER:
                     raise ValueError('Invalid <Sensor {}> {} for thermostats'.format(sensor_id, sensor.source))
-                if sensor.physical_quantity != Sensor.PhysicalQuantities.TEMPERATURE:
+                if sensor.physical_quantity != SensorEnums.PhysicalQuantities.TEMPERATURE:
                     raise ValueError('Invalid <Sensor {}> {} for thermostats'.format(sensor_id, sensor.physical_quantity))
                 return int(sensor.external_id)
 
@@ -289,30 +289,6 @@ class ThermostatControllerMaster(ThermostatController):
     def save_cooling_pump_groups(self, pump_groups):  # type: (List[PumpGroupDTO]) -> None
         self._master_controller.save_cooling_pump_groups(pump_groups)
 
-    def load_global_rtd10(self):  # type: () -> GlobalRTD10DTO
-        return self._master_controller.load_global_rtd10()
-
-    def save_global_rtd10(self, global_rtd10):  # type: (GlobalRTD10DTO) -> None
-        self._master_controller.save_global_rtd10(global_rtd10)
-
-    def load_heating_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        return self._master_controller.load_heating_rtd10(rtd10_id)
-
-    def load_heating_rtd10s(self):  # type: () -> List[RTD10DTO]
-        return self._master_controller.load_heating_rtd10s()
-
-    def save_heating_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        self._master_controller.save_heating_rtd10s(rtd10s)
-
-    def load_cooling_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        return self._master_controller.load_cooling_rtd10(rtd10_id)
-
-    def load_cooling_rtd10s(self):  # type: () -> List[RTD10DTO]
-        return self._master_controller.load_cooling_rtd10s()
-
-    def save_cooling_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        self._master_controller.save_cooling_rtd10s(rtd10s)
-
     def load_thermostat_group(self, thermostat_group_id):
         # type: (int) -> ThermostatGroupDTO
         if thermostat_group_id != self.GLOBAL_THERMOSTAT:
@@ -411,18 +387,6 @@ class ThermostatControllerMaster(ThermostatController):
         # type: (int, Optional[str], Optional[str], Optional[float]) -> None
         raise FeatureUnavailableException()
 
-    def set_airco_status(self, thermostat_id, airco_on):
-        # type: (int, bool) -> None
-        """ Set the mode of the airco attached to a given thermostat. """
-        if thermostat_id < 0 or thermostat_id > 31:
-            raise ValueError('Thermostat id not in [0, 31]: {0}'.format(thermostat_id))
-        self._master_controller.set_airco_status(thermostat_id, airco_on)
-
-    def load_airco_status(self):
-        # type: () -> ThermostatAircoStatusDTO
-        """ Get the mode of the airco attached to a all thermostats. """
-        return self._master_controller.load_airco_status()
-
     @staticmethod
     def __check_thermostat(thermostat):
         """ :raises ValueError if thermostat not in range [0, 32]. """
@@ -477,7 +441,6 @@ class ThermostatControllerMaster(ThermostatController):
         try:
             thermostat_info = self._master_controller.get_thermostats()
             thermostat_mode = self._master_controller.get_thermostat_modes()
-            aircos = self._master_controller.load_airco_status()
         except CommunicationFailure:
             return
 
@@ -513,8 +476,7 @@ class ThermostatControllerMaster(ThermostatController):
                               'setpoint': t_setpoint,
                               'preset': t_preset,
                               'name': thermostat_dto.name,
-                              'sensor_nr': thermostat_dto.sensor,
-                              'airco': 1 if aircos.status[thermostat_id] else 0}
+                              'sensor_nr': thermostat_dto.sensor}
                 for output in [0, 1]:
                     output_id = getattr(thermostat_dto, 'output{0}'.format(output))
                     output_state_dto = status.get(output_id)
diff --git a/src/gateway/thermostat/thermostat_controller.py b/src/gateway/thermostat/thermostat_controller.py
index 5f9a80ef..c80d0479 100644
--- a/src/gateway/thermostat/thermostat_controller.py
+++ b/src/gateway/thermostat/thermostat_controller.py
@@ -13,13 +13,14 @@
 # You should have received a copy of the GNU Affero General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 from __future__ import absolute_import
+
 import logging
+
 from gateway.daemon_thread import DaemonThread
 
 if False:  # MYPY
-    from gateway.dto import ThermostatAircoStatusDTO, ThermostatDTO, \
-        ThermostatGroupStatusDTO, ThermostatGroupDTO, PumpGroupDTO, \
-        RTD10DTO, GlobalRTD10DTO
+    from gateway.dto import ThermostatDTO, \
+        ThermostatGroupStatusDTO, ThermostatGroupDTO, PumpGroupDTO
     from gateway.output_controller import OutputController
     from typing import List, Tuple, Optional, Set
 
@@ -153,35 +154,5 @@ class ThermostatController(object):
     def save_cooling_pump_groups(self, pump_groups):  # type: (List[PumpGroupDTO]) -> None
         raise NotImplementedError()
 
-    def load_global_rtd10(self):  # type: () -> GlobalRTD10DTO
-        raise NotImplementedError()
-
-    def save_global_rtd10(self, global_rtd10):  # type: (GlobalRTD10DTO) -> None
-        raise NotImplementedError()
-
-    def load_heating_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        raise NotImplementedError()
-
-    def load_heating_rtd10s(self):  # type: () -> List[RTD10DTO]
-        raise NotImplementedError()
-
-    def save_heating_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        raise NotImplementedError()
-
-    def load_cooling_rtd10(self, rtd10_id):  # type: (int) -> RTD10DTO
-        raise NotImplementedError()
-
-    def load_cooling_rtd10s(self):  # type: () -> List[RTD10DTO]
-        raise NotImplementedError()
-
-    def save_cooling_rtd10s(self, rtd10s):  # type: (List[RTD10DTO]) -> None
-        raise NotImplementedError()
-
-    def set_airco_status(self, thermostat_id, airco_on):  # type: (int, bool) -> None
-        raise NotImplementedError()
-
-    def load_airco_status(self):  # type: () -> ThermostatAircoStatusDTO
-        raise NotImplementedError()
-
     def _sync(self):  # type: () -> None
         raise NotImplementedError()
diff --git a/src/gateway/update_controller.py b/src/gateway/update_controller.py
deleted file mode 100644
index c53775bc..00000000
--- a/src/gateway/update_controller.py
+++ /dev/null
@@ -1,1158 +0,0 @@
-# Copyright (C) 2021 OpenMotics BV
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Affero General Public License as
-# published by the Free Software Foundation, either version 3 of the
-# License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Affero General Public License for more details.
-#
-# You should have received a copy of the GNU Affero General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-"""
-Update Controller
-"""
-from __future__ import absolute_import
-import re
-import time
-import tempfile
-import glob
-import os
-import logging
-import constants
-import requests
-import gateway
-import hashlib
-import shutil
-import subprocess
-from threading import Lock
-from collections import namedtuple
-from six.moves.urllib.parse import urlparse, urlunparse
-from ioc import INJECTED, Inject, Injectable, Singleton
-from logs import Logs
-from gateway.dto import ModuleDTO
-from gateway.daemon_thread import DaemonThread
-from gateway.models import Config, EnergyModule, Module, Database, Session
-from platform_utils import Platform, System
-from gateway.enums import EnergyEnums, ModuleType, UpdateEnums
-from enums import HardwareType
-
-if False:  # MYPY
-    from typing import Any, List, Union, Optional, Tuple, Dict, Set
-    from gateway.module_controller import ModuleController
-    from gateway.hal.master_controller import MasterController
-    from gateway.energy_module_controller import EnergyModuleController
-    from logging import Logger
-
-# Different name to reduce confusion between multiple used loggers
-global_logger = logging.getLogger(__name__)
-
-FirmwareInfo = namedtuple('FirmwareInfo', 'code  module_types')
-
-
-@Injectable.named('update_controller')
-@Singleton
-class UpdateController(object):
-
-    UPDATE_DELAY = 120
-    BACKGROUND_UPDATE_SCAN = False
-
-    PREFIX = constants.OPENMOTICS_PREFIX  # e.g. /x
-    VERSIONS_FOLDER = os.path.join(PREFIX, 'versions')  # e.g. /x/versions
-    VERSIONS_BASE_TEMPLATE = os.path.join(VERSIONS_FOLDER, '{0}', '{1}')  # e.g. /x/versions/{0}/{1}
-    VERSIONS_CURRENT_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('{0}', 'current')  # e.g. /x/versions/{0}/current
-    VERSIONS_PREVIOUS_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('{0}', 'previous')  # e.g. /x/versions/{0}/previous
-
-    CERTIFICATES_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('certificates', '{0}')  # e.g. /x/versions/certificates/{0}
-    CERTIFICATES_CURRENT = VERSIONS_BASE_TEMPLATE.format('certificates', 'current')  # e.g. /x/versions/certificates/current
-    CERTIFICATES_OPENVPN = VERSIONS_BASE_TEMPLATE.format('certificates', 'openvpn')  # e.g. /x/versions/certificates/openvpn
-
-    SERVICE_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('service', '{0}')  # e.g. /x/versions/service/{0}
-    SERVICE_CURRENT = VERSIONS_CURRENT_TEMPLATE.format('service')  # e.g. /x/versions/service/current
-    SERVICE_PREVIOUS = VERSIONS_PREVIOUS_TEMPLATE.format('service')  # e.g. /x/versions/service/previous
-    SERVICE_CURRENT_UPDATE_RUNNING_MARKER = os.path.join(SERVICE_CURRENT, 'update.running')
-    PLUGINS_DIRECTORY_TEMPLATE = os.path.join(SERVICE_BASE_TEMPLATE, 'python', 'plugins')  # e.g. /x/versions/service/{0}/python/plugins
-
-    FRONTEND_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('frontend', '{0}')  # e.g. /x/versions/frontend/{0}
-    FRONTEND_CURRENT = VERSIONS_CURRENT_TEMPLATE.format('frontend')  # e.g. /x/versions/frontend/current
-    FRONTEND_PREVIOUS = VERSIONS_PREVIOUS_TEMPLATE.format('frontend')  # e.g. /x/versions/frontend/previous
-
-    FIRMWARE_FILENAME_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('firmwares', '{0}')  # e.g. /x/versions/firmwares/{0}
-    FIRMWARE_NAME_TEMPLATE = 'OMF{0}_{{0}}.hex'
-    FIRMWARE_INFO_MAP = {'temperature': FirmwareInfo('TE', [ModuleType.SENSOR]),
-                         'input': FirmwareInfo('IT', [ModuleType.INPUT]),
-                         'input_gen3': FirmwareInfo('IT', [ModuleType.INPUT]),
-                         'output': FirmwareInfo('OT', [ModuleType.OUTPUT, ModuleType.SHUTTER]),
-                         'output_gen3': FirmwareInfo('RY', [ModuleType.OUTPUT]),
-                         'dimmer': FirmwareInfo('DL', [ModuleType.DIM_CONTROL]),
-                         'dimmer_gen3': FirmwareInfo('ZL', [ModuleType.DIM_CONTROL]),
-                         'can': FirmwareInfo('CL', [ModuleType.CAN_CONTROL]),
-                         'can_gen3': FirmwareInfo('CL', [ModuleType.CAN_CONTROL]),
-                         'ucan': FirmwareInfo('MN', [ModuleType.MICRO_CAN]),
-                         'master_classic': FirmwareInfo('GY', []),
-                         'master_coreplus': FirmwareInfo('BN', []),
-                         'energy': FirmwareInfo('EY', [ModuleType.ENERGY]),
-                         'p1_concentrator': FirmwareInfo('PR', [ModuleType.P1_CONCENTRATOR])}  # type: Dict[str, FirmwareInfo]
-    MODULE_TYPE_MAP = {'temperature': {2: 'temperature'},
-                       'input': {2: 'input', 3: 'input_gen3'},
-                       'output': {2: 'output', 3: 'output_gen3'},
-                       'shutter': {2: 'output'},
-                       'dim_control': {2: 'dimmer', 3: 'dimmer_gen3'},
-                       'can_control': {2: 'can', 3: 'can_gen3'},
-                       'ucan': {3: 'ucan'},
-                       'master_classic': {2: 'master_classic'},
-                       'master_core': {3: 'master_coreplus'},
-                       'energy': {3: 'energy'},
-                       'p1_concentrator': {3: 'p1_concentrator'}}  # type: Dict[str, Dict[int, str]]
-
-    # Below order of services are important, this is the order in which the updates will be performed
-    SUPPORTED_FIRMWARES = {Platform.Type.CORE: ['gateway_service', 'gateway_frontend',
-                                                'master_coreplus',
-                                                'energy', 'p1_concentrator',
-                                                'input_gen3', 'output_gen3', 'dimmer_gen3', 'can_gen3', 'ucan'],
-                           Platform.Type.CORE_PLUS: ['gateway_service', 'gateway_frontend',
-                                                     'master_coreplus',
-                                                     'energy', 'p1_concentrator',
-                                                     'input_gen3', 'output_gen3', 'dimmer_gen3', 'can_gen3', 'ucan'],
-                           Platform.Type.CLASSIC: ['gateway_service', 'gateway_frontend',
-                                                   'master_classic',
-                                                   'energy', 'p1_concentrator',
-                                                   'input', 'output', 'dimmer', 'can']}
-
-    if System.get_operating_system().get('ID') == System.OS.ANGSTROM:
-        OPENVPN_CONFIG = '/etc/openvpn/vpn.conf'
-    else:
-        OPENVPN_CONFIG = '/etc/openvpn/client/omcloud.conf'
-
-    @Inject
-    def __init__(self, gateway_uuid=INJECTED, module_controller=INJECTED, master_controller=INJECTED, energy_module_controller=INJECTED, cloud_url=INJECTED):
-        # type: (str, ModuleController, MasterController, EnergyModuleController, str) -> None
-        self._update_thread = None  # type: Optional[DaemonThread]
-        self._gateway_uuid = gateway_uuid
-        self._module_controller = module_controller
-        self._master_controller = master_controller
-        self._energy_module_controller = energy_module_controller
-        self._cloud_url = cloud_url
-        self._update_lock = Lock()
-        self._pending_updates = True
-        self._updates_blocked = False
-        self._firmware_updates_in_progress = False
-
-        if not os.path.exists(UpdateController.VERSIONS_FOLDER):
-            global_logger.info('Creating {0}'.format(UpdateController.VERSIONS_FOLDER))
-            os.makedirs(UpdateController.VERSIONS_FOLDER)
-        for kind in ['service', 'frontend', 'firmwares']:
-            path = os.path.join(UpdateController.VERSIONS_FOLDER, kind)
-            if not os.path.exists(path):
-                global_logger.info('Creating {0}'.format(path))
-                os.makedirs(path)
-
-        self._update_threshold = time.time() + UpdateController.UPDATE_DELAY
-
-    def start(self):
-        self._update_thread = DaemonThread(name='update_controller',
-                                           target=self._execute_pending_updates,
-                                           interval=60,
-                                           delay=300)
-        self._update_thread.start()
-
-    def stop(self):
-        if self._update_thread is not None:
-            self._update_thread.stop()
-
-    @property
-    def firmware_updates_in_progress(self):
-        return self._firmware_updates_in_progress
-
-    def block_updates(self):
-        with self._update_lock:
-            self._updates_blocked = True
-
-    def unblock_updates(self):
-        self._updates_blocked = False
-
-    def get_update_state(self):
-        states = []
-        state = 2
-        state_map = {0: UpdateEnums.States.ERROR,
-                     1: UpdateEnums.States.UPDATING,
-                     2: UpdateEnums.States.SKIPPED,
-                     3: UpdateEnums.States.OK}
-        global_state_map = {0: UpdateEnums.States.ERROR,
-                            1: UpdateEnums.States.UPDATING,
-                            2: UpdateEnums.States.OK,
-                            3: UpdateEnums.States.OK}
-        modules = {}  # type: Dict[str, List[Module]]
-        with Database.get_session() as db:
-            for module in db.query(Module).where(Module.hardware_type == HardwareType.PHYSICAL).all():
-                modules.setdefault(module.module_type, []).append(module)
-            firmware_types = UpdateController.SUPPORTED_FIRMWARES.get(Platform.get_platform(), [])
-            for firmware_type in firmware_types:
-                success, target_version, _ = UpdateController._get_target_version_info(firmware_type)
-                if target_version is None:
-                    continue
-                if firmware_type in ['gateway_service', 'gateway_frontend', 'master_classic', 'master_coreplus']:
-                    current_version = self._fetch_version(firmware_type=firmware_type, logger=global_logger)
-                    if current_version == target_version:
-                        state_number = 3  # OK
-                    else:
-                        state_number = 1  # UPDATING
-                        if success is not None:
-                            state_number = 2 if success else 0  # SKIPPED or ERROR
-                        elif not self._pending_updates:
-                            state_number = 2  # SKIPPED
-                    state = min(state, state_number)
-                    states.append({'firmware_type': firmware_type,
-                                   'state': state_map[state_number],
-                                   'current_version': current_version,
-                                   'target_version': target_version})
-                else:
-                    for module_type in UpdateController.FIRMWARE_INFO_MAP[firmware_type].module_types:
-                        for module in modules.get(module_type, []):
-                            if module.firmware_version == target_version:
-                                state_number = 3  # OK
-                            else:
-                                state_number = 1  # UPDATING
-                                update_success = module.update_success
-                                if update_success is not None:
-                                    state_number = 2 if update_success else 0  # SKIPPED or ERROR
-                                elif not self._pending_updates:
-                                    state_number = 2  # SKIPPED
-                            state = min(state, state_number)
-                            states.append({'firmware_type': firmware_type,
-                                           'state': state_map[state_number],
-                                           'current_version': module.firmware_version,
-                                           'target_version': target_version,
-                                           'module_address': module.address})
-            return {'status': global_state_map[state],
-                    'status_detail': states}
-
-    def request_update(self, new_version, metadata=None):
-        """
-        Example metadata:
-        > {'version': '1.2.3',
-        >  'firmwares': [{'type': 'master_coreplus',
-        >                 'version': '3.12.3'
-        >                 'dependencies': ['gateway_service >= 3.1.1'],
-        >                 'sha256': 'abcdef',
-        >                 'urls': ['https://foo.bar/master-coreplus_3.12.3.hex',
-        >                          'https://foo.bar/master-coreplus_3.12.3.hex'],
-        >                 'url': 'https://foo.bar/master-coreplus_3.12.3.hex'}]}
-        Where the order of download is based on `firmware.get('urls', [firmware['url']])`
-        """
-        modules = {}  # type: Dict[str, List[Module]]
-        with Database.get_session() as db:
-            for module in db.query(Module).where(Module.hardware_type == HardwareType.PHYSICAL).all():
-                modules.setdefault(module.module_type, []).append(module)
-            global_logger.info('Request for update to {0}'.format(new_version))
-            platform = Platform.get_platform()
-            if metadata is None:
-                global_logger.info('Downloading metadata for {0}'.format(new_version))
-                response = requests.get(url=self._get_update_metadata_url(version=new_version),
-                                        timeout=2,
-                                        verify=System.get_operating_system().get('ID') != System.OS.ANGSTROM)
-                if response.status_code != 200:
-                    raise ValueError('Failed to get update metadata for {0}'.format(new_version))
-                metadata = response.json()
-            target_versions = {}
-            for firmware in metadata.get('firmwares', []):
-                version = firmware['version']
-                firmware_type = firmware['type']
-                if firmware_type not in UpdateController.SUPPORTED_FIRMWARES.get(platform, []):
-                    global_logger.info('Skip firmware {0} as it is unsupported on platform {1}'.format(firmware_type, platform))
-                    continue
-                target_versions[firmware_type] = {'target_version': version,
-                                                  'urls': firmware.get('urls', []) + ([firmware['url']] if 'url' in firmware else []),
-                                                  'sha256': firmware['sha256']}
-                if firmware_type in UpdateController.FIRMWARE_INFO_MAP:
-                    module_types = UpdateController.FIRMWARE_INFO_MAP[firmware_type].module_types
-                    for module_type in module_types:
-                        for module in modules.get(module_type, []):
-                            if module.firmware_version != version:
-                                module.update_success = None  # Allow the update to be re-tried
-                db.commit()
-                global_logger.info('Request for update firmware {0} to {1}'.format(firmware_type, version))
-            Config.set_entry('firmware_target_versions', target_versions)
-            self._pending_updates = True
-
-    def update_module_firmware(self, module_type, target_version, mode, module_address, firmware_filename=None):
-        # type: (str, str, str, Optional[str], Optional[str]) -> Tuple[int, int]
-        if module_type not in UpdateController.MODULE_TYPE_MAP:
-            raise RuntimeError('Cannot update unknown module type {0}'.format(module_type))
-        # Load firmware type
-        parsed_version = tuple(int(part) for part in target_version.split('.'))
-        if module_type in ['master_classic', 'master_core']:
-            generation = 3 if parsed_version < (2, 0, 0) else 2  # Core = 1.x.x, classic = 3.x.x
-        elif module_type in ['energy', 'p1_concentrator']:
-            generation = 3  # Generation doesn't matter for these modules
-        else:
-            generation = 3 if parsed_version >= (6, 0, 0) else 2  # Gen3 = 6.x.x, gen2 = 3.x.x
-        if generation not in UpdateController.MODULE_TYPE_MAP[module_type]:
-            raise RuntimeError('Calculated generation {0} is not suppored on {1}'.format(generation, module_type))
-        firmware_type = UpdateController.MODULE_TYPE_MAP[module_type][generation]
-        platform = Platform.get_platform()
-        if firmware_type not in UpdateController.SUPPORTED_FIRMWARES.get(platform, []):
-            raise RuntimeError('Firmware {0} cannot be updated on platform {1}'.format(firmware_type, platform))
-        # Execute update
-        with self._update_lock:
-            return self._update_module_firmware(firmware_type=firmware_type,
-                                                target_version=target_version,
-                                                mode=mode,
-                                                module_address=module_address,
-                                                metadata=None,
-                                                firmware_filename=firmware_filename)
-
-    @staticmethod
-    def update_gateway_service(new_version, logger):
-        # type: (str, Logger) -> None
-        """ Executed from within a separate process """
-        logger.info('Stopping services')
-        System.run_service_action('stop', 'openmotics').wait()
-        System.run_service_action('stop', 'vpn_service').wait()
-
-        old_version_folder = ''
-        running_marker = ''
-
-        try:
-            # Migrate legacy folder structure, if needed
-            if not os.path.exists(UpdateController.SERVICE_CURRENT):
-                old_version_folder = UpdateController.SERVICE_BASE_TEMPLATE.format(gateway.__version__)
-                os.makedirs(old_version_folder)
-                os.symlink(old_version_folder, UpdateController.SERVICE_CURRENT)
-
-                for folder in ['python', 'etc', 'python-deps']:
-                    old_location = os.path.join(UpdateController.PREFIX, folder)
-                    new_location = os.path.join(UpdateController.SERVICE_CURRENT, folder)
-                    shutil.move(old_location, new_location)
-                    os.symlink(new_location, old_location)
-
-            old_version = os.readlink(UpdateController.SERVICE_CURRENT).split(os.path.sep)[-1]
-            old_version_folder = UpdateController.SERVICE_BASE_TEMPLATE.format(old_version)
-            new_version_folder = UpdateController.SERVICE_BASE_TEMPLATE.format(new_version)
-
-            success_marker = os.path.join(new_version_folder, 'update.success')
-            running_marker = os.path.join(new_version_folder, 'update.running')
-
-            if os.path.exists(new_version_folder) and not os.path.exists(success_marker):
-                # Remove the existing `new_version_folder` if the contents could not be started
-                shutil.rmtree(new_version_folder)
-
-            if not os.path.exists(new_version_folder):
-                os.mkdir(new_version_folder)
-                UpdateController._touch(running_marker)
-
-                # Extract new version
-                logger.info('Extracting archive')
-                os.makedirs(os.path.join(new_version_folder, 'python'))
-                archive = UpdateController.SERVICE_BASE_TEMPLATE.format('gateway_{0}.tgz'.format(new_version))
-                UpdateController._extract_tgz(filename=archive,
-                                              output_dir=os.path.join(new_version_folder, 'python'),
-                                              logger=logger)
-
-                # Remove old archive
-                os.remove(archive)
-
-                # Copy `etc`
-                logger.info('Copy `etc` folder')
-                shutil.copytree(os.path.join(old_version_folder, 'etc'),
-                                os.path.join(new_version_folder, 'etc'),
-                                symlinks=True)
-
-                # Restore plugins
-                logger.info('Copy plugins...')
-                plugins = glob.glob('{0}{1}*{1}'.format(UpdateController.PLUGINS_DIRECTORY_TEMPLATE.format(old_version), os.path.sep))
-                for plugin_path in plugins:
-                    plugin = plugin_path.strip('/').rsplit('/', 1)[-1]
-                    logger.info('Copy plugin {0}'.format(plugin))
-                    UpdateController._execute(command=['cp', '-R',
-                                                       os.path.join(UpdateController.PLUGINS_DIRECTORY_TEMPLATE.format(old_version), plugin),
-                                                       os.path.join(UpdateController.PLUGINS_DIRECTORY_TEMPLATE.format(new_version), '')],
-                                              logger=logger)
-
-                # Install pip dependencies
-                logger.info('Installing pip dependencies')
-                os.makedirs(os.path.join(new_version_folder, 'python-deps'))
-                operating_system = System.get_operating_system()['ID']
-                temp_dir = tempfile.mkdtemp(dir=UpdateController.PREFIX)
-                UpdateController._execute(
-                    command='env TMPDIR={0} PYTHONUSERBASE={1}/python-deps python {1}/python/libs/pip.whl/pip install --no-index --user {1}/python/libs/{2}/*.whl'.format(
-                        temp_dir, new_version_folder, operating_system
-                    ),
-                    logger=logger,
-                    shell=True
-                )
-                os.rmdir(temp_dir)
-
-            UpdateController._touch(running_marker)  # Make sure the running marker exists
-
-            # Keep track of the old version, so it can be manually restored if something goes wrong
-            logger.info('Tracking previous version')
-            if os.path.exists(UpdateController.SERVICE_PREVIOUS):
-                os.unlink(UpdateController.SERVICE_PREVIOUS)
-            os.symlink(old_version_folder, UpdateController.SERVICE_PREVIOUS)
-
-            # Prepare new code for first startup
-            logger.info('Preparing for first startup')
-            UpdateController._execute(command=['python',
-                                               os.path.join(new_version_folder, 'python', 'openmotics_update.py'),
-                                               '--prepare-gateway-service-for-first-startup',
-                                               new_version],
-                                      logger=logger)
-
-            # Symlink to new version
-            logger.info('Symlink to new version')
-            os.unlink(UpdateController.SERVICE_CURRENT)
-            os.symlink(new_version_folder, UpdateController.SERVICE_CURRENT)
-
-            # Startup
-            logger.info('Starting services')
-            System.run_service_action('start', 'openmotics').wait()
-            System.run_service_action('start', 'vpn_service').wait()
-
-            # Health-check
-            logger.info('Starting health check')
-            update_successful = UpdateController._check_gateway_service_health(logger=logger)
-
-            # Rollback to old version
-            if not update_successful:
-                logger.info('Update failed, restoring')
-                System.run_service_action('stop', 'openmotics').wait()
-                System.run_service_action('stop', 'vpn_service').wait()
-                os.unlink(UpdateController.SERVICE_CURRENT)
-                os.symlink(old_version_folder, UpdateController.SERVICE_CURRENT)
-                # Raise with actual reason
-                raise RuntimeError('Failed to start {0}'.format(new_version))
-
-            # Cleanup
-            UpdateController._clean_old_versions(base_template=UpdateController.SERVICE_BASE_TEMPLATE,
-                                                 logger=logger)
-
-            # Update markers
-            UpdateController._touch(success_marker)
-            logger.info('Update completed')
-        except Exception as ex:
-            logger.exception('Unexpected exception setting up new version: {0}'.format(ex))
-            if old_version_folder and not os.path.exists(UpdateController.SERVICE_CURRENT):
-                os.symlink(old_version_folder, UpdateController.SERVICE_CURRENT)
-            # Start services again
-            System.run_service_action('start', 'openmotics').wait()
-            System.run_service_action('start', 'vpn_service').wait()
-            raise
-        finally:
-            if running_marker and os.path.exists(running_marker):
-                os.remove(running_marker)  # Cleanup running marker
-
-    @staticmethod
-    def update_gateway_service_prepare_for_first_startup(logger):
-        # type: (Logger) -> None
-        """ Executed from within a separate process """
-        # This is currently empty, but might in the future be used for:
-        #  * Updating the supervisor service files
-        #  * Changing system settings mandatory for the services to start up
-        # This code will execute after the new version is in place and before the
-        # services are started. It runs the new code, has the new imports
-        # available, ...
-
-        # Certificates
-        UpdateController._move_openvpn_certificates(logger)
-
-        # Migrations of `openmotics.conf`
-        from six.moves.configparser import ConfigParser
-        openmotics_conf_path = constants.get_config_file()
-        openmotics_conf_path_new = '{0}.new'.format(openmotics_conf_path)
-        config = ConfigParser()
-        config.read(openmotics_conf_path)
-        if config.has_option('OpenMotics', 'version'):
-            config.remove_option('OpenMotics', 'version')
-        with open(openmotics_conf_path_new, 'w') as fp:
-            config.write(fp)
-        os.rename(openmotics_conf_path_new, openmotics_conf_path)
-
-        logger.info('Preparation for first startup completed')
-
-    def _execute_pending_updates(self):
-        if os.path.exists(UpdateController.SERVICE_CURRENT_UPDATE_RUNNING_MARKER):
-            global_logger.info('Waiting for the update process to finish')
-            return
-        if self._update_threshold > time.time():
-            global_logger.info('Waiting for update startup threshold')
-            return
-        if self._updates_blocked:
-            global_logger.info('Updates currently blocked')
-            return
-        if not (self._pending_updates or UpdateController.BACKGROUND_UPDATE_SCAN):
-            return
-
-        with self._update_lock:
-            success, target_version, _ = UpdateController._get_target_version_info('gateway_service')
-            gateway_service_current_version = self._fetch_version(firmware_type='gateway_service', logger=global_logger)
-            gateway_service_up_to_date = target_version is None or (success and target_version == gateway_service_current_version)
-
-            had_work = False
-
-            firmware_types = UpdateController.SUPPORTED_FIRMWARES.get(Platform.get_platform(), [])
-            for firmware_type in firmware_types:
-                success, target_version, metadata = UpdateController._get_target_version_info(firmware_type)
-                if target_version is None:
-                    continue  # Nothing can be done
-                if success is not None:
-                    continue  # Update was successfull, or it failed (but retries are not yet supported)
-
-                component_logger = Logs.get_update_logger(name=firmware_type)
-                if firmware_type == 'gateway_service':
-                    had_work = True
-                    try:
-                        component_logger.info('Updating gateway_service to {0}'.format(target_version))
-                        # Validate whether an update is needed
-                        if target_version == gateway_service_current_version:
-                            component_logger.info('Firmware for gateway_service up-to-date')
-                            UpdateController._register_version_success(firmware_type=firmware_type, success=True)
-                            gateway_service_up_to_date = True
-                            continue  # Already up-to-date
-                        # Check whether `current` isn't already pointing to the target version (would indicate a version mismatch)
-                        target_version_folder = UpdateController.SERVICE_BASE_TEMPLATE.format(target_version)
-                        if os.path.exists(UpdateController.SERVICE_CURRENT) and target_version_folder == os.readlink(UpdateController.SERVICE_CURRENT):
-                            raise RuntimeError('Symlinked current version seems not what the code states it should be')
-                        # Read failure report
-                        failure_filename = UpdateController.SERVICE_BASE_TEMPLATE.format('{0}.failure'.format(target_version))
-                        if os.path.exists(failure_filename):
-                            with open(failure_filename, 'r') as failure:
-                                failure_content = failure.read()
-                            os.remove(failure_filename)
-                            raise RuntimeError('Update failure reported: {0}'.format(failure_content))
-                        # Download archive if needed
-                        filename = UpdateController.SERVICE_BASE_TEMPLATE.format('gateway_{0}.tgz'.format(target_version))
-                        self._load_firmware(firmware_type=firmware_type,
-                                            version=target_version,
-                                            logger=component_logger,
-                                            target_filename=filename,
-                                            metadata=metadata)
-                        # Start actual update
-                        component_logger.info('Detaching gateway_service update process')
-                        UpdateController._execute(command=['python',
-                                                           os.path.join(UpdateController.PREFIX, 'python', 'openmotics_update.py'),
-                                                           '--execute-gateway-service-update',
-                                                           target_version],
-                                                  logger=component_logger)
-                        time.sleep(300)  # Wait 5 minutes, the service should be stopped by above detached process anyway
-                    except Exception as ex:
-                        component_logger.error('Could not update gateway_service to {0}: {1}'.format(target_version, ex))
-                        UpdateController._register_version_success(firmware_type, success=False)
-                    continue
-
-                if not gateway_service_up_to_date:
-                    # Every other firmware should only be installed when the gateway is up-to-date
-                    # TODO: Implement proper dependencies
-                    continue
-
-                if firmware_type == 'gateway_frontend':
-                    try:
-                        had_work |= self._update_gateway_frontend(new_version=target_version,
-                                                                  metadata=metadata,
-                                                                  logger=component_logger)
-                        success = True
-                    except Exception as ex:
-                        component_logger.error('Could not update gateway_frontend to {0}: {1}'.format(target_version, ex))
-                        success = False
-                    UpdateController._register_version_success(firmware_type, success=success)
-                    continue
-
-                # Hex firmwares
-                try:
-                    successes, failures = self._update_module_firmware(firmware_type=firmware_type,
-                                                                       target_version=target_version,
-                                                                       mode=UpdateEnums.Modes.AUTOMATIC,
-                                                                       module_address=None,
-                                                                       metadata=metadata)
-                    had_work |= successes > 0 or failures > 0
-                except Exception as ex:
-                    component_logger.error('Could not update {0} to {1}: {2}'.format(firmware_type, target_version, ex))
-
-            if not had_work and self._pending_updates:
-                global_logger.info('No pending updates')
-                self._pending_updates = False
-
-    def _update_module_firmware(self, firmware_type, target_version, mode, module_address, metadata, firmware_filename=None):
-        # type: (str, str, str, Optional[str], Optional[Dict[str, Any]], Optional[str]) -> Tuple[int, int]
-        component_logger = Logs.get_update_logger(name=firmware_type)
-
-        if firmware_type not in UpdateController.FIRMWARE_INFO_MAP:
-            raise RuntimeError('Dynamic update for {0} not yet supported'.format(firmware_type))
-
-        try:
-            self._firmware_updates_in_progress = True
-            if firmware_type in ['master_classic', 'master_coreplus']:
-                return self._update_master_firmware(firmware_type=firmware_type,
-                                                    target_version=target_version,
-                                                    firmware_filename=firmware_filename,
-                                                    logger=component_logger,
-                                                    mode=mode,
-                                                    metadata=metadata)
-            elif firmware_type in ['energy', 'p1_concentrator']:
-                return self._update_energy_firmware(firmware_type=firmware_type,
-                                                    target_version=target_version,
-                                                    module_address=module_address,
-                                                    firmware_filename=firmware_filename,
-                                                    logger=component_logger,
-                                                    mode=mode,
-                                                    metadata=metadata)
-            else:
-                return self._update_master_slave_firmware(firmware_type=firmware_type,
-                                                          target_version=target_version,
-                                                          module_address=module_address,
-                                                          firmware_filename=firmware_filename,
-                                                          logger=component_logger,
-                                                          mode=mode,
-                                                          metadata=metadata)
-        finally:
-            self._energy_module_controller.reset_communication_statistics()
-            self._master_controller.reset_communication_statistics()
-            self._firmware_updates_in_progress = False
-
-    def _update_master_slave_firmware(self, firmware_type, target_version, module_address, firmware_filename, logger, mode, metadata):
-        # type: (str, str, Optional[str], Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
-        module_types = UpdateController.FIRMWARE_INFO_MAP[firmware_type].module_types
-        where_expression = ((Module.source == ModuleDTO.Source.MASTER) &
-                            (Module.hardware_type == HardwareType.PHYSICAL) &
-                            (Module.module_type.in_(module_types)))
-        address_suffix = None  # type: Optional[str]
-        single_address = None  # type: Optional[str]
-        if module_address is not None:
-            single_address = module_address
-            if '@' in module_address:
-                single_address, address_suffix = module_address.split('@')
-            where_expression &= (Module.address == single_address)
-
-        with Database.get_session() as db:
-            modules = list(db.query(Module).where(where_expression).all())
-            modules_to_update = UpdateController._filter_modules_to_update(db,
-                                                                           all_modules=modules,
-                                                                           target_version=target_version,
-                                                                           mode=mode)
-            if not modules_to_update:
-                if module_address is None or mode != UpdateEnums.Modes.FORCED:
-                    return 0, 0
-                modules_to_update = [Module(address=module_address)]
-
-            # Fetch the firmware
-            filename_code = UpdateController.FIRMWARE_INFO_MAP[firmware_type].code
-            filename_base = UpdateController.FIRMWARE_NAME_TEMPLATE.format(filename_code)
-            target_filename = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
-            self._load_firmware(firmware_type=firmware_type,
-                                version=target_version,
-                                logger=logger,
-                                target_filename=target_filename,
-                                source_filename=firmware_filename,
-                                metadata=metadata)
-
-            # Update
-            successes, failures = 0, 0
-            hold_versions = {target_version}
-            for module in modules_to_update:
-                address = module.address
-                if address_suffix is not None:
-                    address = '{0}@{1}'.format(address, address_suffix)
-                if module.firmware_version is not None:
-                    hold_versions.add(module.firmware_version)
-                individual_logger = Logs.get_update_logger('{0}_{1}'.format(firmware_type, module.address))
-                try:
-                    new_version = self._master_controller.update_slave_module(firmware_type=firmware_type,
-                                                                              address=address,
-                                                                              hex_filename=target_filename,
-                                                                              version=target_version)
-                    if module.id is not None:
-                        if new_version is not None:
-                            module.firmware_version = new_version
-                        module.last_online_update = int(time.time())
-                        module.update_success = True
-                    successes += 1
-                except Exception as ex:
-                    individual_logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
-                    if module.id is not None:
-                        module.update_success = False
-                    failures += 1
-            db.commit()
-
-        # Cleanup
-        base_template = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
-        UpdateController._clean_old_firmware_versions(base_template=base_template,
-                                                      hold_versions=hold_versions,
-                                                      logger=logger)
-
-        return successes, failures
-
-    def _update_energy_firmware(self, firmware_type, target_version, module_address, firmware_filename, logger, mode, metadata):
-        # type: (str, str, Optional[str], Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
-        module_version = {'energy': EnergyEnums.Version.ENERGY_MODULE,
-                          'p1_concentrator': EnergyEnums.Version.P1_CONCENTRATOR}[firmware_type]
-
-        where_expression = ((EnergyModule.version == module_version) &
-                            (Module.hardware_type == HardwareType.PHYSICAL))
-        if module_address is not None:
-            where_expression &= (Module.address == module_address)
-
-        with Database.get_session() as db:
-            modules = [em.module for em in db.query(EnergyModule).where(where_expression).all()]
-            modules_to_update = UpdateController._filter_modules_to_update(db,
-                                                                           all_modules=modules,
-                                                                           target_version=target_version,
-                                                                           mode=mode)
-            if not modules_to_update:
-                if module_address is None or mode != UpdateEnums.Modes.FORCED:
-                    return 0, 0
-                modules_to_update = [Module(address=module_address)]
-
-            # Fetch the firmware
-            filename_code = UpdateController.FIRMWARE_INFO_MAP[firmware_type].code
-            filename_base = UpdateController.FIRMWARE_NAME_TEMPLATE.format(filename_code)
-            target_filename = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
-            self._load_firmware(firmware_type=firmware_type,
-                                version=target_version,
-                                logger=logger,
-                                target_filename=target_filename,
-                                source_filename=firmware_filename,
-                                metadata=metadata)
-
-            # Update
-            successes, failures = 0, 0
-            hold_versions = {target_version}
-            for module in modules_to_update:
-                module_address = module.address
-                if module.firmware_version is not None:
-                    hold_versions.add(module.firmware_version)
-                individual_logger = Logs.get_update_logger('{0}_{1}'.format(EnergyEnums.VERSION_TO_STRING[module_version], module_address))
-                try:
-                    new_version = self._energy_module_controller.update_module(module_version=module_version,
-                                                                               module_address=module_address,
-                                                                               firmware_filename=target_filename,
-                                                                               firmware_version=target_version)
-                    if module.id is not None:
-                        if new_version is not None:
-                            module.firmware_version = new_version
-                        module.last_online_update = int(time.time())
-                        module.update_success = True
-                    successes += 1
-                except Exception as ex:
-                    individual_logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
-                    if module.id is not None:
-                        module.update_success = False
-                    failures += 1
-            db.commit()
-
-        # Cleanup
-        base_template = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
-        UpdateController._clean_old_firmware_versions(base_template=base_template,
-                                                      hold_versions=hold_versions,
-                                                      logger=logger)
-
-        return successes, failures
-
-    @staticmethod
-    def _filter_modules_to_update(db, all_modules, target_version, mode):
-        # type: (Any, List[Module], str, str) -> List[Module]
-        modules_to_update = []
-        for module in all_modules:
-            if module.firmware_version == target_version:
-                # Only update an alread-up-to-date module if it's forced
-                if mode == UpdateEnums.Modes.FORCED:
-                    modules_to_update.append(module)
-                else:
-                    module.update_success = True
-                    db.add(module)
-                    db.commit()
-            else:
-                # When an outdated module is automatically updated, it should
-                # take the update_success into account (no retries yet), but
-                # otherwise (manual or forced) it can be updated
-                if mode == UpdateEnums.Modes.AUTOMATIC:
-                    if module.update_success is None:
-                        modules_to_update.append(module)
-                else:
-                    modules_to_update.append(module)
-        return modules_to_update
-
-    def _update_master_firmware(self, firmware_type, target_version, firmware_filename, logger, mode, metadata):
-        # type: (str, str, Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
-        try:
-            current_version = self._fetch_version(firmware_type=firmware_type, logger=logger)
-            if mode != UpdateEnums.Modes.FORCED and current_version == target_version:
-                logger.info('Master already up-to-date')
-                UpdateController._register_version_success(firmware_type, success=True)
-                return 0, 0
-
-            # Fetch the firmware
-            filename_code = UpdateController.FIRMWARE_INFO_MAP[firmware_type].code
-            filename_base = UpdateController.FIRMWARE_NAME_TEMPLATE.format(filename_code)
-            target_filename = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
-            self._load_firmware(firmware_type=firmware_type,
-                                version=target_version,
-                                logger=logger,
-                                target_filename=target_filename,
-                                source_filename=firmware_filename,
-                                metadata=metadata)
-
-            # Update
-            self._master_controller.update_master(hex_filename=target_filename,
-                                                  version=target_version)
-
-            # Cleanup
-            base_template = UpdateController.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
-            UpdateController._clean_old_firmware_versions(base_template=base_template,
-                                                          hold_versions={current_version, target_version},
-                                                          logger=logger)
-
-            UpdateController._register_version_success(firmware_type, success=True)
-            return 1, 0
-        except Exception as ex:
-            logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
-            UpdateController._register_version_success(firmware_type, success=False)
-            return 0, 1
-
-    def _update_gateway_frontend(self, new_version, metadata, logger):
-        # type: (str, Optional[Dict[str, Any]], Logger) -> bool
-        logger.info('Updating gateway_frontend to {0}'.format(new_version))
-
-        # Migrate legacy folder structure, if needed
-        if not os.path.exists(UpdateController.FRONTEND_CURRENT):
-            current_version = self._fetch_version(firmware_type='gateway_frontend', logger=logger)
-            if current_version is None:
-                current_version = 'legacy'
-            old_version_folder = UpdateController.FRONTEND_BASE_TEMPLATE.format(current_version)
-            os.makedirs(old_version_folder)
-            os.symlink(old_version_folder, UpdateController.FRONTEND_CURRENT)
-
-            old_location = os.path.join(UpdateController.PREFIX, 'static')
-            new_location = os.path.join(UpdateController.FRONTEND_CURRENT, 'static')
-            shutil.move(old_location, new_location)
-            os.symlink(new_location, old_location)
-
-        old_version = self._fetch_version(firmware_type='gateway_frontend', logger=logger)
-        if old_version == new_version:
-            # Already up-to-date
-            logger.info('Firmware for gateway_frontend up-to-date')
-            return False
-
-        new_version_folder = UpdateController.FRONTEND_BASE_TEMPLATE.format(new_version)
-        if not os.path.exists(new_version_folder):
-            os.mkdir(new_version_folder)
-
-            # Download firmware
-            filename = UpdateController.FRONTEND_BASE_TEMPLATE.format('frontend_{0}.tgz'.format(new_version))
-            self._load_firmware(firmware_type='gateway_frontend',
-                                version=new_version,
-                                logger=logger,
-                                target_filename=filename,
-                                metadata=metadata)
-
-            # Extract new version
-            logger.info('Extracting archive')
-            os.makedirs(os.path.join(new_version_folder, 'static'))
-            UpdateController._extract_tgz(filename=filename,
-                                          output_dir=os.path.join(new_version_folder, 'static'),
-                                          logger=logger)
-
-            # Remove old archive
-            os.remove(filename)
-
-        # Symlink to new version
-        logger.info('Symlink to new version')
-        os.unlink(UpdateController.FRONTEND_CURRENT)
-        os.symlink(new_version_folder, UpdateController.FRONTEND_CURRENT)
-
-        # Cleanup
-        UpdateController._clean_old_versions(base_template=UpdateController.FRONTEND_BASE_TEMPLATE,
-                                             logger=logger)
-
-        logger.info('Update completed')
-        return True
-
-    @staticmethod
-    def _move_openvpn_certificates(logger):  # type: (Logger) -> None
-        vpn_prefix = UpdateController.CERTIFICATES_OPENVPN
-        settings = {'ca': os.path.join(vpn_prefix, 'ca.crt'),
-                    'cert': os.path.join(vpn_prefix, 'client.crt'),
-                    'key': os.path.join(vpn_prefix, 'client.key')}
-        if System.get_operating_system().get('ID') != System.OS.ANGSTROM:
-            settings.update({'cipher': 'AES-256-CBC'})
-
-        changed = False
-        lines = []
-        with open(UpdateController.OPENVPN_CONFIG, 'r') as fd:
-            for line in (x.rstrip() for x in fd.readlines()):
-                prefix, _, value = line.partition(' ')
-                if prefix in settings and settings[prefix] != value:
-                    changed = True
-                    lines.append('{0} {1}'.format(prefix, settings[prefix]))
-                else:
-                    lines.append(line)
-        if not changed:
-            return
-
-        logger.info('Copying openvpn certificates...')
-        unknown = UpdateController.CERTIFICATES_BASE_TEMPLATE.format('unknown')
-        if os.path.exists(unknown):
-            shutil.rmtree(unknown)
-
-        os.makedirs(unknown)
-        for file_ in ('ca.crt', 'client.crt', 'client.key'):
-            shutil.copy(src=os.path.join(os.path.dirname(UpdateController.OPENVPN_CONFIG), file_),
-                        dst=os.path.join(unknown, file_))
-
-        for link in (UpdateController.CERTIFICATES_CURRENT, UpdateController.CERTIFICATES_OPENVPN):
-            if os.path.exists(link):
-                os.unlink(link)
-            os.symlink('unknown', link)
-
-        try:
-            logger.info('Updating openvpn config...')
-            UpdateController._execute(command=['mount', '-o', 'remount,rw', '/'],
-                                      logger=logger)
-            if not os.path.exists(UpdateController.OPENVPN_CONFIG + '.BACKUP'):
-                shutil.copy(UpdateController.OPENVPN_CONFIG, UpdateController.OPENVPN_CONFIG + '.BACKUP')
-            temp_config = tempfile.mktemp(dir=os.path.dirname(UpdateController.OPENVPN_CONFIG))
-            with open(temp_config, 'w') as fd:
-                fd.write('\n'.join(lines))
-            os.rename(temp_config, UpdateController.OPENVPN_CONFIG)
-        finally:
-            UpdateController._execute(command=['mount', '-o', 'remount,ro', '/'],
-                                      logger=logger)
-
-    def _fetch_version(self, logger, firmware_type):  # type: (Logger, str) -> Optional[str]
-        try:
-            if firmware_type == 'gateway_service':
-                return gateway.__version__
-            if firmware_type == 'gateway_frontend':
-                if not os.path.exists(UpdateController.FRONTEND_CURRENT):
-                    with open(os.path.join(UpdateController.PREFIX, 'static', 'index.html'), 'r') as index:
-                        match = re.search(r"v([0-9]+?\.[0-9]+?\.[0-9]+)", index.read())
-                        if match is not None:
-                            return match.groups()[0]
-                return str(os.readlink(UpdateController.FRONTEND_CURRENT).split(os.path.sep)[-1])
-            if firmware_type in ['master_classic', 'master_coreplus']:
-                return '.'.join(str(e) for e in self._master_controller.get_firmware_version())
-        except Exception as ex:
-            logger.warning('Could not load {0} version: {1}'.format(firmware_type, ex))
-        return None
-
-    @staticmethod
-    def _touch(filename):
-        with open(filename, 'w') as file_:
-            file_.write('{0}\n'.format(filename))
-
-    @staticmethod
-    def _get_target_version_info(firmware_type):
-        # type: (str) -> Tuple[Optional[bool], Optional[str], Optional[Dict[str, Any]]]
-        target_versions = Config.get_entry('firmware_target_versions', None)  # type: Optional[Dict[str, Dict[str, Any]]]
-        if target_versions is None:
-            target_versions = {}
-            Config.set_entry('firmware_target_versions', target_versions)
-            return None, None, None
-        if firmware_type not in target_versions:
-            return None, None, None
-        target_version_info = target_versions[firmware_type]
-        metadata = None  # type: Optional[Dict[str, Any]]
-        if 'urls' in target_version_info and 'sha256' in target_version_info:
-            metadata = {'urls': target_version_info['urls'],
-                        'sha256': target_version_info['sha256']}
-        return (target_version_info.get('success'),
-                target_version_info['target_version'],
-                metadata)
-
-    @staticmethod
-    def _register_version_success(firmware_type, success):
-        # type: (str, bool) -> None
-        target_versions = Config.get_entry('firmware_target_versions', None)  # type: Optional[Dict[str, Dict[str, Any]]]
-        if target_versions is None or firmware_type not in target_versions:
-            return
-        target_versions[firmware_type]['success'] = success
-        Config.set_entry('firmware_target_versions', target_versions)
-
-    @staticmethod
-    def _clean_old_firmware_versions(base_template, hold_versions, logger):
-        logger.info('Clean up old firmware versions')
-        path_prefix = base_template.split('{0}')[0]
-
-        def _extract_version(filename_):
-            return filename_.replace(path_prefix, '').replace('.hex', '')
-
-        versions = set()  # type: Set[str]
-        for version_path in glob.glob(base_template.format('*')):
-            versions.add(_extract_version(version_path))
-        versions_to_keep = (set(hold_versions) |
-                            set(sorted(versions, reverse=True)[:3]))
-        for version in versions:
-            if version in versions_to_keep:
-                logger.info('Keeping {0}'.format(version))
-                continue
-            logger.info('Removing {0}'.format(version))
-            os.remove(base_template.format(version))
-
-    @staticmethod
-    def _clean_old_versions(base_template, logger):
-        logger.info('Clean up old versions')
-        try:
-            versions = set()  # type: Set[str]
-            current_version = None  # type: Optional[str]
-            previous_version = None  # type: Optional[str]
-            for version_path in glob.glob(base_template.format('*')):
-                version = version_path.strip('/').rsplit('/', 1)[-1]
-                if 'tgz' in version or version.endswith('.failure'):
-                    continue
-                if version == 'current':
-                    current_version = os.readlink(base_template.format(version)).split(os.path.sep)[-1]
-                elif version == 'previous':
-                    previous_version = os.readlink(base_template.format(version)).split(os.path.sep)[-1]
-                else:
-                    versions.add(version)
-            versions_to_keep = set(sorted(versions, reverse=True)[:3])
-            if current_version is not None:
-                versions_to_keep.add(current_version)
-            if previous_version is not None:
-                versions_to_keep.add(previous_version)
-            for version in versions:
-                if version in versions_to_keep:
-                    logger.info('Keeping {0}'.format(version))
-                    continue
-                logger.info('Removing {0}'.format(version))
-                shutil.rmtree(base_template.format(version))
-        except Exception as ex:
-            logger.warning('Could not clean up old versions with base_template {0}: {1}'.format(base_template, ex))
-
-    @staticmethod
-    def _check_gateway_service_health(logger, timeout=300):
-        since = time.time()
-        pending = ['unknown']
-        http_port = Platform.http_port()
-        while since > time.time() - timeout:
-            try:
-                logger.info('Checking gw service health...')
-                response = requests.get('http://127.0.0.1:{}/health_check'.format(http_port), timeout=2)
-                data = response.json()
-                if data['success']:
-                    pending = [k for k, v in data['health'].items() if not v['state']]
-                    if not pending:
-                        logger.info('Health-check completed successfully')
-                        return True
-            except Exception:
-                pass
-            time.sleep(10)
-        logger.error('Health-check failed with pending {0}'.format(', '.join(pending)))
-        return False
-
-    @staticmethod
-    def _extract_tgz(filename, output_dir, logger):
-        UpdateController._execute(command=['tar', '--no-same-owner', '-xzf', filename, '-C', output_dir],
-                                  logger=logger)
-
-    @staticmethod
-    def _execute(command, logger, **kwargs):
-        # type: (Union[str, List[str]], Logger, Any) -> str
-        proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
-                                close_fds=True, **kwargs)
-        output = b''
-        if proc.stdout is not None:
-            for line in proc.stdout:
-                if line:
-                    logger.info(line.rstrip(b'\n'))
-                output += line
-        return_code = proc.wait()
-        if return_code != 0:
-            raise Exception('Command {} failed'.format(command))
-        return str(output)
-
-    def _load_firmware(self, firmware_type, version, logger, target_filename, metadata, source_filename=None):
-        # type: (str, str, Logger, str, Optional[Dict[str, Any]], Optional[str]) -> None
-        if source_filename is not None:
-            if source_filename != target_filename:
-                shutil.copy(src=source_filename,
-                            dst=target_filename)
-            return
-
-        # Load and parse metadata
-        urls = []
-        if metadata is not None:
-            urls = metadata.get('urls', []) + ([metadata['url']] if 'url' in metadata else [])
-            if not urls:
-                metadata = None  # Download metadata again, since no urls were found
-        if metadata is None:
-            logger.info('Downloading firmware metadata for {0} {1}'.format(firmware_type, version))
-            response = requests.get(self._get_update_firmware_metadata_url(firmware_type, version),
-                                    timeout=5,
-                                    verify=System.get_operating_system().get('ID') != System.OS.ANGSTROM)
-            if response.status_code != 200:
-                raise ValueError('Failed to get firmware metadata for {0} {1}'.format(firmware_type, version))
-            metadata = response.json()
-            urls = metadata.get('urls', []) + ([metadata['url']] if 'url' in metadata else [])
-        checksum = metadata['sha256']
-
-        # Fetch file
-        if os.path.exists(target_filename):
-            actual_checksum = UpdateController._calculate_checksum(filename=target_filename)
-            if actual_checksum == checksum:
-                logger.info('Using firmware from cache: {0} (checksum: {1})'.format(target_filename, checksum))
-                return  # File exists and is valid, no need to redownload
-        if not urls:
-            raise ValueError('Could not find any download url in firmware metadata for {0} {1}'.format(firmware_type, version))
-        UpdateController._download_urls(urls=urls,
-                                        checksum=checksum,
-                                        logger=logger,
-                                        target_filename=target_filename)
-
-    @staticmethod
-    def _download_urls(urls, checksum, logger, target_filename):  # type: (List[str], str, Logger, str) -> None
-        downloaded = False
-        with open(target_filename, 'w') as handle:
-            for url in urls:
-                try:
-                    logger.info('Downloading firmware {0} from {1} ...'.format(target_filename, url))
-                    response = requests.get(url,
-                                            verify=System.get_operating_system().get('ID') != System.OS.ANGSTROM,
-                                            stream=True,
-                                            timeout=30)
-                    shutil.copyfileobj(response.raw, handle)
-                    downloaded = True
-                    break
-                except Exception as ex:
-                    logger.error('Could not download firmware {0} from {1}: {2}'.format(target_filename, url, ex))
-        if not downloaded:
-            raise RuntimeError('No firmware could be downloaded for {0}'.format(target_filename))
-        actual_checksum = UpdateController._calculate_checksum(filename=target_filename)
-        if actual_checksum != checksum:
-            raise RuntimeError('Downloaded firmware {0} checksum {1} does not match expected {2}'.format(target_filename, actual_checksum, checksum))
-
-    @staticmethod
-    def _calculate_checksum(filename):  # type: (str) -> Optional[str]
-        try:
-            hasher = hashlib.sha256()
-            with open(filename, 'rb') as f:
-                hasher.update(f.read())
-            calculated_hash = hasher.hexdigest()
-            return calculated_hash
-        except Exception:
-            pass
-        return None
-
-    def _get_update_metadata_url(self, version):
-        query = 'uuid={0}'.format(self._gateway_uuid)
-        update_url = Config.get_entry('update_metadata_url', None)  # type: Optional[str]
-        if update_url is None:
-            parsed_url = urlparse(self._cloud_url)
-            path = '/api/v1.1/base/updates/metadata/{0}'.format(version)
-        else:
-            parsed_url = urlparse(update_url)
-            path = parsed_url.path
-        return urlunparse((parsed_url.scheme, parsed_url.netloc, path, '', query, ''))
-
-    def _get_update_firmware_metadata_url(self, firmware_type, version):
-        query = 'uuid={0}'.format(self._gateway_uuid)
-        update_url = Config.get_entry('update_firmware_metadata_url', None)  # type: Optional[str]
-        if update_url is None:
-            parsed_url = urlparse(self._cloud_url)
-            path = '/api/v1.1/base/updates/metadata/firmwares/{0}/{1}'.format(firmware_type, version)
-        else:
-            parsed_url = urlparse(update_url)
-            path = parsed_url.path
-        return urlunparse((parsed_url.scheme, parsed_url.netloc, path, '', query, ''))
diff --git a/src/gateway/updates/__init__.py b/src/gateway/updates/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/src/gateway/updates/update_constants.py b/src/gateway/updates/update_constants.py
new file mode 100644
index 00000000..e74d106e
--- /dev/null
+++ b/src/gateway/updates/update_constants.py
@@ -0,0 +1,122 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Various constants
+"""
+from __future__ import absolute_import
+import os
+import constants
+from collections import namedtuple
+from platform_utils import Platform, System
+from gateway.enums import ModuleType, Firmwares
+
+if False:  # MYPY
+    from typing import Dict
+
+FirmwareInfo = namedtuple('FirmwareInfo', 'code  module_types')
+
+
+class UpdateConstants(object):
+
+    UPDATE_DELAY = 120
+    BACKGROUND_UPDATE_SCAN = False
+    LEGACY_DEPENDENCIES_VERSION = '2.0.0'
+
+    PREFIX = constants.OPENMOTICS_PREFIX  # e.g. /x
+    VERSIONS_FOLDER = os.path.join(PREFIX, 'versions')  # e.g. /x/versions
+    VERSIONS_BASE_TEMPLATE = os.path.join(VERSIONS_FOLDER, '{0}', '{1}')  # e.g. /x/versions/{0}/{1}
+
+    CERTIFICATES_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('certificates', '{0}')  # e.g. /x/versions/certificates/{0}
+    CERTIFICATES_CURRENT = VERSIONS_BASE_TEMPLATE.format('certificates', 'current')  # e.g. /x/versions/certificates/current
+    CERTIFICATES_OPENVPN = VERSIONS_BASE_TEMPLATE.format('certificates', 'openvpn')  # e.g. /x/versions/certificates/openvpn
+
+    NIX_PROFILES_DIRECTORY = '/nix/var/nix/profiles/{0}'
+    PYTHON_DEPENDENCIES_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('dependencies',
+                                                                      '{0}')  # e.g. /x/versions/dependencies/{0}
+
+    VENV_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('venv', '{0}')  # e.g. /x/versions/venv/{0}
+    VENV_CURRENT = VENV_BASE_TEMPLATE.format('current')  # e.g. /x/versions/venv/current
+    VENV_PREVIOUS = VENV_BASE_TEMPLATE.format('previous')  # e.g. /x/versions/venv/previous
+    VENV_LEGACY = VENV_BASE_TEMPLATE.format('legacy')  # e.g. /x/versions/venv/legacy
+    VENV_CURRENT_UPDATE_RUNNING_MARKER = os.path.join(VENV_CURRENT, 'update.running')
+
+    SERVICE_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('service', '{0}')  # e.g. /x/versions/service/{0}
+
+    FRONTEND_BASE_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('frontend', '{0}')  # e.g. /x/versions/frontend/{0}
+    FRONTEND_CURRENT = FRONTEND_BASE_TEMPLATE.format('current')  # e.g. /x/versions/frontend/current
+    FRONTEND_PREVIOUS = FRONTEND_BASE_TEMPLATE.format('previous')  # e.g. /x/versions/frontend/previous
+
+    FIRMWARE_FILENAME_TEMPLATE = VERSIONS_BASE_TEMPLATE.format('firmwares', '{0}')  # e.g. /x/versions/firmwares/{0}
+    FIRMWARE_NAME_TEMPLATE = 'OMF{0}_{{0}}.hex'
+    FIRMWARE_INFO_MAP = {Firmwares.TEMPERATURE: FirmwareInfo('TE', [ModuleType.SENSOR]),
+                         Firmwares.INPUT: FirmwareInfo('IT', [ModuleType.INPUT]),
+                         Firmwares.INPUT_GEN3: FirmwareInfo('IT', [ModuleType.INPUT]),
+                         Firmwares.OUTPUT: FirmwareInfo('OT', [ModuleType.OUTPUT, ModuleType.SHUTTER]),
+                         Firmwares.OUTPUT_GEN3: FirmwareInfo('RY', [ModuleType.OUTPUT]),
+                         Firmwares.DIMMER: FirmwareInfo('DL', [ModuleType.DIM_CONTROL]),
+                         Firmwares.DIMMER_GEN3: FirmwareInfo('ZL', [ModuleType.DIM_CONTROL]),
+                         Firmwares.CAN: FirmwareInfo('CL', [ModuleType.CAN_CONTROL]),
+                         Firmwares.CAN_GEN3: FirmwareInfo('CL', [ModuleType.CAN_CONTROL]),
+                         Firmwares.UCAN: FirmwareInfo('MN', [ModuleType.MICRO_CAN]),
+                         Firmwares.MASTER_CLASSIC: FirmwareInfo('GY', []),
+                         Firmwares.MASTER_COREPLUS: FirmwareInfo('BN', []),
+                         Firmwares.ENERGY: FirmwareInfo('EY', [ModuleType.ENERGY]),
+                         Firmwares.P1_CONCENTRATOR: FirmwareInfo('PR', [
+                             ModuleType.P1_CONCENTRATOR])}  # type: Dict[str, FirmwareInfo]
+    MODULE_TYPE_MAP = {'temperature': {2: Firmwares.TEMPERATURE},
+                       'input': {2: Firmwares.INPUT, 3: Firmwares.INPUT_GEN3},
+                       'output': {2: Firmwares.OUTPUT, 3: Firmwares.OUTPUT_GEN3},
+                       'shutter': {2: Firmwares.OUTPUT},
+                       'dim_control': {2: Firmwares.DIMMER, 3: Firmwares.DIMMER_GEN3},
+                       'can_control': {2: Firmwares.CAN, 3: Firmwares.CAN_GEN3},
+                       'ucan': {3: Firmwares.UCAN},
+                       'master_classic': {2: Firmwares.MASTER_CLASSIC},
+                       'master_core': {3: Firmwares.MASTER_COREPLUS},
+                       'energy': {3: Firmwares.ENERGY},
+                       'p1_concentrator': {3: Firmwares.P1_CONCENTRATOR}}  # type: Dict[str, Dict[int, str]]
+
+    SQLITERC_FILE = '/opt/root/.sqliterc'
+    SQLITERC_DEFAULT_CONFIG = """
+.headers on
+.mode column
+.timer on
+.changes on
+"""
+
+    # Below order of services are important, this is the order in which the updates will be performed
+    GATEWAY_SYSTEM_FIRMWARES = [Firmwares.PYTHON_INTERPRETER, Firmwares.PYTHON_DEPENDENCIES, Firmwares.GATEWAY_SERVICE]
+    SUPPORTED_FIRMWARES = {Platform.Type.CORE: (GATEWAY_SYSTEM_FIRMWARES +
+                                                [Firmwares.GATEWAY_FRONTEND,
+                                                 Firmwares.MASTER_COREPLUS,
+                                                 Firmwares.ENERGY, Firmwares.P1_CONCENTRATOR,
+                                                 Firmwares.INPUT_GEN3, Firmwares.OUTPUT_GEN3, Firmwares.DIMMER_GEN3,
+                                                 Firmwares.CAN_GEN3, Firmwares.UCAN]),
+                           Platform.Type.CORE_PLUS: (GATEWAY_SYSTEM_FIRMWARES +
+                                                     [Firmwares.GATEWAY_FRONTEND,
+                                                      Firmwares.MASTER_COREPLUS,
+                                                      Firmwares.ENERGY, Firmwares.P1_CONCENTRATOR,
+                                                      Firmwares.INPUT_GEN3, Firmwares.OUTPUT_GEN3, Firmwares.DIMMER_GEN3,
+                                                      Firmwares.CAN_GEN3, Firmwares.UCAN]),
+                           Platform.Type.CLASSIC: (GATEWAY_SYSTEM_FIRMWARES +
+                                                   [Firmwares.GATEWAY_FRONTEND,
+                                                    Firmwares.MASTER_CLASSIC,
+                                                    Firmwares.ENERGY, Firmwares.P1_CONCENTRATOR,
+                                                    Firmwares.INPUT, Firmwares.OUTPUT, Firmwares.DIMMER,
+                                                    Firmwares.TEMPERATURE, Firmwares.CAN])}
+
+    if System.get_operating_system().get('ID') == System.OS.ANGSTROM:
+        OPENVPN_CONFIG = '/etc/openvpn/vpn.conf'
+    else:
+        OPENVPN_CONFIG = '/etc/openvpn/client/omcloud.conf'
diff --git a/src/gateway/updates/update_controller.py b/src/gateway/updates/update_controller.py
new file mode 100644
index 00000000..0d8e6c79
--- /dev/null
+++ b/src/gateway/updates/update_controller.py
@@ -0,0 +1,764 @@
+# Copyright (C) 2021 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Update Controller
+"""
+from __future__ import absolute_import
+
+import hashlib
+import time
+import glob
+import os
+import logging
+import requests
+import shutil
+from threading import Lock
+from collections import namedtuple
+from six.moves.urllib.parse import urlparse, urlunparse
+from ioc import INJECTED, Inject, Injectable, Singleton
+from logs import Logs
+from toolbox import Toolbox
+from gateway.dto import ModuleDTO
+from gateway.daemon_thread import DaemonThread
+from gateway.models import Config, EnergyModule, Module, Database
+from gateway.updates.update_constants import UpdateConstants
+from gateway.updates.update_gateway import GatewayUpdateController
+from platform_utils import Platform, System
+from gateway.enums import EnergyEnums, ModuleType, UpdateEnums, Firmwares
+from enums import HardwareType
+
+if False:  # MYPY
+    from typing import Any, List, Optional, Tuple, Dict, Set
+    from gateway.module_controller import ModuleController
+    from gateway.hal.master_controller import MasterController
+    from gateway.energy_module_controller import EnergyModuleController
+    from logging import Logger
+
+# Different name to reduce confusion between multiple used loggers
+global_logger = logging.getLogger(__name__)
+
+FirmwareInfo = namedtuple('FirmwareInfo', 'code  module_types')
+
+
+@Injectable.named('update_controller')
+@Singleton
+class UpdateController(object):
+
+    @Inject
+    def __init__(self, gateway_uuid=INJECTED, module_controller=INJECTED, master_controller=INJECTED, energy_module_controller=INJECTED, cloud_url=INJECTED):
+        # type: (str, ModuleController, MasterController, EnergyModuleController, str) -> None
+        self._update_thread = None  # type: Optional[DaemonThread]
+        self._gateway_uuid = gateway_uuid
+        self._module_controller = module_controller
+        self._master_controller = master_controller
+        self._energy_module_controller = energy_module_controller
+        self._cloud_url = cloud_url
+        self._update_lock = Lock()
+        self._pending_updates = True
+        self._updates_blocked = False
+        self._firmware_updates_in_progress = False
+
+        if not os.path.exists(UpdateConstants.VERSIONS_FOLDER):
+            global_logger.info('Creating {0}'.format(UpdateConstants.VERSIONS_FOLDER))
+            os.makedirs(UpdateConstants.VERSIONS_FOLDER)
+        for kind in ['service', 'frontend', 'firmwares']:
+            path = os.path.join(UpdateConstants.VERSIONS_FOLDER, kind)
+            if not os.path.exists(path):
+                global_logger.info('Creating {0}'.format(path))
+                os.makedirs(path)
+
+        self._update_threshold = time.time() + UpdateConstants.UPDATE_DELAY
+
+    def start(self):
+        self._update_thread = DaemonThread(name='update_controller',
+                                           target=self._execute_pending_updates,
+                                           interval=60,
+                                           delay=300)
+        self._update_thread.start()
+
+    def stop(self):
+        if self._update_thread is not None:
+            self._update_thread.stop()
+
+    @property
+    def firmware_updates_in_progress(self):
+        return self._firmware_updates_in_progress
+
+    def block_updates(self):
+        with self._update_lock:
+            self._updates_blocked = True
+
+    def unblock_updates(self):
+        self._updates_blocked = False
+
+    def get_update_state(self):
+        states = []
+        state = 2
+        state_map = {0: UpdateEnums.States.ERROR,
+                     1: UpdateEnums.States.UPDATING,
+                     2: UpdateEnums.States.SKIPPED,
+                     3: UpdateEnums.States.OK}
+        global_state_map = {0: UpdateEnums.States.ERROR,
+                            1: UpdateEnums.States.UPDATING,
+                            2: UpdateEnums.States.OK,
+                            3: UpdateEnums.States.OK}
+        modules = {}  # type: Dict[str, List[Module]]
+        with Database.get_session() as db:
+            for module in db.query(Module).where(Module.hardware_type == HardwareType.PHYSICAL).all():
+                modules.setdefault(module.module_type, []).append(module)
+            firmware_types = UpdateConstants.SUPPORTED_FIRMWARES.get(Platform.get_platform(), [])
+            for firmware_type in firmware_types:
+                success, target_version, _ = UpdateController._get_target_version_info(firmware_type)
+                if target_version is None:
+                    continue
+                if firmware_type in UpdateConstants.GATEWAY_SYSTEM_FIRMWARES + [Firmwares.GATEWAY_FRONTEND, Firmwares.MASTER_CLASSIC, Firmwares.MASTER_COREPLUS]:
+                    if firmware_type in [Firmwares.MASTER_CLASSIC, Firmwares.MASTER_COREPLUS]:
+                        current_version = self._fetch_version(firmware_type=firmware_type, logger=global_logger)
+                    else:
+                        current_version = GatewayUpdateController.fetch_version(firmware_type=firmware_type, logger=global_logger)
+                    if current_version == target_version:
+                        state_number = 3  # OK
+                    else:
+                        state_number = 1  # UPDATING
+                        if success is not None:
+                            state_number = 2 if success else 0  # SKIPPED or ERROR
+                        elif not self._pending_updates:
+                            state_number = 2  # SKIPPED
+                    state = min(state, state_number)
+                    states.append({'firmware_type': firmware_type,
+                                   'state': state_map[state_number],
+                                   'current_version': current_version,
+                                   'target_version': target_version})
+                else:
+                    for module_type in UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].module_types:
+                        for module in modules.get(module_type, []):
+                            if module.firmware_version == target_version:
+                                state_number = 3  # OK
+                            else:
+                                state_number = 1  # UPDATING
+                                update_success = module.update_success
+                                if update_success is not None:
+                                    state_number = 2 if update_success else 0  # SKIPPED or ERROR
+                                elif not self._pending_updates:
+                                    state_number = 2  # SKIPPED
+                            state = min(state, state_number)
+                            states.append({'firmware_type': firmware_type,
+                                           'state': state_map[state_number],
+                                           'current_version': module.firmware_version,
+                                           'target_version': target_version,
+                                           'module_address': module.address})
+            return {'status': global_state_map[state],
+                    'status_detail': states}
+
+    def request_update(self, new_version, metadata=None):
+        """
+        Example metadata:
+        > {'version': '1.2.3',
+        >  'firmwares': [{'type': 'master_coreplus',
+        >                 'version': '3.12.3'
+        >                 'dependencies': ['gateway_service >= 3.1.1'],
+        >                 'sha256': 'abcdef',
+        >                 'urls': ['https://foo.bar/master-coreplus_3.12.3.hex',
+        >                          'https://foo.bar/master-coreplus_3.12.3.hex'],
+        >                 'url': 'https://foo.bar/master-coreplus_3.12.3.hex'}]}
+        Where the order of download is based on `firmware.get('urls', [firmware['url']])`
+        """
+        modules = {}  # type: Dict[str, List[Module]]
+        with Database.get_session() as db:
+            for module in db.query(Module).where(Module.hardware_type == HardwareType.PHYSICAL).all():
+                modules.setdefault(module.module_type, []).append(module)
+            global_logger.info('Request for update to {0}'.format(new_version))
+            platform = Platform.get_platform()
+
+            # Download metadata if not yet included in the payload
+            if metadata is None:
+                global_logger.info('Downloading metadata for {0}'.format(new_version))
+                response = requests.get(url=self._get_update_metadata_url(version=new_version),
+                                        timeout=2,
+                                        verify=System.verify_requests())
+                if response.status_code != 200:
+                    raise ValueError('Failed to get update metadata for {0}'.format(new_version))
+                metadata = response.json()
+
+            # Validate that either all 3 gateway related firmwares are included, or none of them
+            given_firmware_types = [firmware['type'] for firmware in metadata.get('firmwares', [])]
+            if any(firmware_type in given_firmware_types for firmware_type in UpdateConstants.GATEWAY_SYSTEM_FIRMWARES):
+                if not all(firmware_type in given_firmware_types for firmware_type in UpdateConstants.GATEWAY_SYSTEM_FIRMWARES):
+                    raise ValueError('An incomplete firmware set ({0}) was given'.format(
+                        ', '.join(UpdateConstants.GATEWAY_SYSTEM_FIRMWARES)
+                    ))
+
+            # Process & store the metadata
+            target_versions = {}
+            for firmware in metadata.get('firmwares', []):
+                version = firmware['version']
+                firmware_type = firmware['type']
+                if firmware_type not in UpdateConstants.SUPPORTED_FIRMWARES.get(platform, []):
+                    global_logger.info('Skip firmware {0} as it is unsupported on platform {1}'.format(firmware_type, platform))
+                    continue
+                target_versions[firmware_type] = {'target_version': version,
+                                                  'urls': firmware.get('urls', []) + ([firmware['url']] if 'url' in firmware else []),
+                                                  'sha256': firmware['sha256']}
+                if firmware_type in UpdateConstants.FIRMWARE_INFO_MAP:
+                    module_types = UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].module_types
+                    for module_type in module_types:
+                        for module in modules.get(module_type, []):
+                            if module.firmware_version != version:
+                                module.update_success = None  # Allow the update to be re-tried
+                global_logger.info('Request for update firmware {0} to {1}'.format(firmware_type, version))
+            if Firmwares.GATEWAY_SERVICE in target_versions:
+                target_version = GatewayUpdateController.build_venv_version(interpreter_version=target_versions[Firmwares.PYTHON_INTERPRETER]['target_version'],
+                                                                            dependencies_version=target_versions[Firmwares.PYTHON_DEPENDENCIES]['target_version'],
+                                                                            gateway_service_version=target_versions[Firmwares.GATEWAY_SERVICE]['target_version'])
+                target_versions[Firmwares.VIRTUAL_ENVIRONMENT] = {'target_version': target_version}
+            db.commit()
+            Config.set_entry('firmware_target_versions', target_versions)
+            self._pending_updates = True
+
+    def update_module_firmware(self, module_type, target_version, mode, module_address, firmware_filename=None):
+        # type: (str, str, str, Optional[str], Optional[str]) -> Tuple[int, int]
+        if module_type not in UpdateConstants.MODULE_TYPE_MAP:
+            raise RuntimeError('Cannot update unknown module type {0}'.format(module_type))
+        # Load firmware type
+        parsed_version = tuple(int(part) for part in target_version.split('.'))
+        if module_type in [ModuleType.MASTER_CLASSIC, ModuleType.MASTER_CORE]:
+            generation = 3 if parsed_version < (2, 0, 0) else 2  # Core = 1.x.x, classic = 3.x.x
+        elif module_type in [ModuleType.ENERGY, ModuleType.P1_CONCENTRATOR]:
+            generation = 3  # Generation doesn't matter for these modules
+        else:
+            generation = 3 if parsed_version >= (6, 0, 0) else 2  # Gen3 = 6.x.x, gen2 = 3.x.x
+        if generation not in UpdateConstants.MODULE_TYPE_MAP[module_type]:
+            raise RuntimeError('Calculated generation {0} is not suppored on {1}'.format(generation, module_type))
+        firmware_type = UpdateConstants.MODULE_TYPE_MAP[module_type][generation]
+        platform = Platform.get_platform()
+        if firmware_type not in UpdateConstants.SUPPORTED_FIRMWARES.get(platform, []):
+            raise RuntimeError('Firmware {0} cannot be updated on platform {1}'.format(firmware_type, platform))
+        # Execute update
+        with self._update_lock:
+            return self._update_module_firmware(firmware_type=firmware_type,
+                                                target_version=target_version,
+                                                mode=mode,
+                                                module_address=module_address,
+                                                metadata=None,
+                                                firmware_filename=firmware_filename)
+
+    def _execute_pending_updates(self):
+        if os.path.exists(UpdateConstants.VENV_CURRENT_UPDATE_RUNNING_MARKER):
+            global_logger.info('Waiting for the update process to finish')
+            return
+        if self._update_threshold > time.time():
+            global_logger.info('Waiting for update startup threshold')
+            return
+        if self._updates_blocked:
+            global_logger.info('Updates currently blocked')
+            return
+        if not (self._pending_updates or UpdateConstants.BACKGROUND_UPDATE_SCAN):
+            return
+
+        supported_firmware_types = UpdateConstants.SUPPORTED_FIRMWARES.get(Platform.get_platform(), [])
+
+        with self._update_lock:
+            had_work = False
+
+            # Update all gateway related service
+            installed_gateway_firmwares = {}
+            for firmware_type in [firmware_type for firmware_type in supported_firmware_types
+                                  if firmware_type in UpdateConstants.GATEWAY_SYSTEM_FIRMWARES]:
+                success, target_version, metadata = UpdateController._get_target_version_info(firmware_type)
+                if target_version is None:
+                    continue  # Nothing can be done
+                if success is True:
+                    installed_gateway_firmwares[firmware_type] = target_version
+                if success is not None:
+                    continue  # Update was successfull, or it failed (but retries are not yet supported)
+
+                component_logger = Logs.get_update_logger(name=firmware_type)
+                directory, install_function = {Firmwares.PYTHON_INTERPRETER: (UpdateConstants.NIX_PROFILES_DIRECTORY.format('python{0}'),
+                                                                              GatewayUpdateController.install_python_interpreter),
+                                               Firmwares.PYTHON_DEPENDENCIES: (UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE,
+                                                                               GatewayUpdateController.install_python_dependencies),
+                                               Firmwares.GATEWAY_SERVICE: (UpdateConstants.SERVICE_BASE_TEMPLATE,
+                                                                           GatewayUpdateController.install_gateway_service)}[firmware_type]
+                firmware_type_string = firmware_type.replace('_', ' ')
+                try:
+                    # Read current installed versions
+                    directory = directory.format(target_version)
+                    if os.path.exists(directory):
+                        component_logger.info('%s %s already installed', firmware_type_string.capitalize(), target_version)
+                        UpdateController._register_version_success(firmware_type=firmware_type, success=True)
+                        installed_gateway_firmwares[firmware_type] = target_version
+                        continue  # Already up-to-date
+                    had_work = True
+                    component_logger.info('Installing %s %s', firmware_type_string, target_version)
+                    filename = '/tmp/{0}_{1}.tgz'.format(firmware_type, target_version)
+                    self._load_firmware(firmware_type=firmware_type,
+                                        target_filename=filename,
+                                        version=target_version,
+                                        metadata=metadata,
+                                        logger=component_logger)
+                    install_function(filename=filename, target_version=target_version, logger=component_logger)
+                    UpdateController._register_version_success(firmware_type=firmware_type, success=True)
+                    component_logger.info('Installation of %s completed', firmware_type_string)
+                    installed_gateway_firmwares[firmware_type] = target_version
+                except Exception as ex:
+                    component_logger.error('Could not install %s %s: %s', firmware_type_string, target_version, ex)
+                    UpdateController._register_version_success(firmware_type, success=False)
+
+            success, target_version, metadata = UpdateController._get_target_version_info(Firmwares.VIRTUAL_ENVIRONMENT)
+            if target_version is None:
+                # This will only be the case if none of the gateway system firmwares has a pending update
+                success = True
+            else:
+                if sorted(installed_gateway_firmwares.keys()) != sorted(UpdateConstants.GATEWAY_SYSTEM_FIRMWARES):
+                    global_logger.debug('Gateway system firmwares are not yet up to date')
+                    return
+
+                component_logger = Logs.get_update_logger(name=Firmwares.VIRTUAL_ENVIRONMENT)
+                if success is None:
+                    if os.path.exists(UpdateConstants.VENV_CURRENT):
+                        expected_directory = UpdateConstants.VENV_BASE_TEMPLATE.format(target_version)
+                        if expected_directory == os.readlink(UpdateConstants.VENV_CURRENT):
+                            failure_filename = UpdateConstants.VENV_BASE_TEMPLATE.format('{0}.failure'.format(target_version))
+                            if os.path.exists(failure_filename):
+                                with open(failure_filename, 'r') as failure:
+                                    failure_content = failure.read()
+                                os.remove(failure_filename)
+                                component_logger.error('Could not generate virtual environment: {0}'.format(failure_content))
+                                UpdateController._register_version_success(Firmwares.VIRTUAL_ENVIRONMENT, success=False)
+                            else:
+                                component_logger.info('Virtual environment is already up-to-date')
+                                success = True
+                                UpdateController._register_version_success(Firmwares.VIRTUAL_ENVIRONMENT, success=True)
+                    if success is None:
+                        had_work = True
+                        launched = GatewayUpdateController.install_venv(component_versions=installed_gateway_firmwares,
+                                                                        logger=component_logger)
+                        if not launched:
+                            success = False
+                            UpdateController._register_version_success(Firmwares.VIRTUAL_ENVIRONMENT, success=False)
+
+            if success:
+                for firmware_type in [firmware_type for firmware_type in supported_firmware_types
+                                      if firmware_type not in UpdateConstants.GATEWAY_SYSTEM_FIRMWARES]:
+                    success, target_version, metadata = UpdateController._get_target_version_info(firmware_type)
+                    if target_version is None:
+                        continue  # Nothing can be done
+                    if success is not None:
+                        continue  # Update was successfull, or it failed (but retries are not yet supported)
+
+                    component_logger = Logs.get_update_logger(name=firmware_type)
+
+                    if firmware_type == Firmwares.GATEWAY_FRONTEND:
+                        try:
+                            migrated = os.path.exists(UpdateConstants.FRONTEND_CURRENT)
+                            current_version = GatewayUpdateController.fetch_version(firmware_type=Firmwares.GATEWAY_FRONTEND, logger=component_logger)
+                            if migrated and current_version == target_version:
+                                component_logger.info('Firmware for gateway frontend up-to-date')
+                            else:
+                                filename = UpdateController.FRONTEND_BASE_TEMPLATE.format('frontend_{0}.tgz'.format(target_version))
+                                self._load_firmware(firmware_type=Firmwares.GATEWAY_FRONTEND,
+                                                    version=target_version,
+                                                    logger=component_logger,
+                                                    target_filename=filename,
+                                                    metadata=metadata)
+                                GatewayUpdateController.update_gateway_frontend(new_version=target_version,
+                                                                                filename=filename,
+                                                                                logger=component_logger)
+                                had_work = True
+                            success = True
+                        except Exception as ex:
+                            component_logger.error('Could not update gateway frontend to {0}: {1}'.format(target_version, ex))
+                            success = False
+                        UpdateController._register_version_success(firmware_type, success=success)
+                        continue
+
+                    # Hex firmwares
+                    try:
+                        successes, failures = self._update_module_firmware(firmware_type=firmware_type,
+                                                                           target_version=target_version,
+                                                                           mode=UpdateEnums.Modes.AUTOMATIC,
+                                                                           module_address=None,
+                                                                           metadata=metadata)
+                        had_work |= successes > 0 or failures > 0
+                    except Exception as ex:
+                        component_logger.error('Could not update {0} to {1}: {2}'.format(firmware_type, target_version, ex))
+
+            if not had_work and self._pending_updates:
+                global_logger.info('No pending updates')
+                self._pending_updates = False
+
+    def _update_module_firmware(self, firmware_type, target_version, mode, module_address, metadata, firmware_filename=None):
+        # type: (str, str, str, Optional[str], Optional[Dict[str, Any]], Optional[str]) -> Tuple[int, int]
+        component_logger = Logs.get_update_logger(name=firmware_type)
+
+        if firmware_type not in UpdateConstants.FIRMWARE_INFO_MAP:
+            raise RuntimeError('Dynamic update for {0} not yet supported'.format(firmware_type))
+
+        try:
+            self._firmware_updates_in_progress = True
+            if firmware_type in [Firmwares.MASTER_CLASSIC, Firmwares.MASTER_COREPLUS]:
+                return self._update_master_firmware(firmware_type=firmware_type,
+                                                    target_version=target_version,
+                                                    firmware_filename=firmware_filename,
+                                                    logger=component_logger,
+                                                    mode=mode,
+                                                    metadata=metadata)
+            elif firmware_type in [Firmwares.ENERGY, Firmwares.P1_CONCENTRATOR]:
+                return self._update_energy_firmware(firmware_type=firmware_type,
+                                                    target_version=target_version,
+                                                    module_address=module_address,
+                                                    firmware_filename=firmware_filename,
+                                                    logger=component_logger,
+                                                    mode=mode,
+                                                    metadata=metadata)
+            else:
+                return self._update_master_slave_firmware(firmware_type=firmware_type,
+                                                          target_version=target_version,
+                                                          module_address=module_address,
+                                                          firmware_filename=firmware_filename,
+                                                          logger=component_logger,
+                                                          mode=mode,
+                                                          metadata=metadata)
+        finally:
+            self._energy_module_controller.reset_communication_statistics()
+            self._master_controller.reset_communication_statistics()
+            self._firmware_updates_in_progress = False
+
+    def _update_master_slave_firmware(self, firmware_type, target_version, module_address, firmware_filename, logger, mode, metadata):
+        # type: (str, str, Optional[str], Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
+        module_types = UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].module_types
+        where_expression = ((Module.source == ModuleDTO.Source.MASTER) &
+                            (Module.hardware_type == HardwareType.PHYSICAL) &
+                            (Module.module_type.in_(module_types)))
+        address_suffix = None  # type: Optional[str]
+        single_address = None  # type: Optional[str]
+        if module_address is not None:
+            single_address = module_address
+            if '@' in module_address:
+                single_address, address_suffix = module_address.split('@')
+            where_expression &= (Module.address == single_address)
+
+        with Database.get_session() as db:
+            modules = list(db.query(Module).where(where_expression).all())
+            modules_to_update = UpdateController._filter_modules_to_update(db,
+                                                                           all_modules=modules,
+                                                                           target_version=target_version,
+                                                                           mode=mode)
+            if not modules_to_update:
+                if module_address is None or mode != UpdateEnums.Modes.FORCED:
+                    return 0, 0
+                modules_to_update = [Module(address=module_address)]
+
+            # Fetch the firmware
+            filename_code = UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].code
+            filename_base = UpdateConstants.FIRMWARE_NAME_TEMPLATE.format(filename_code)
+            target_filename = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
+            self._load_firmware(firmware_type=firmware_type,
+                                version=target_version,
+                                logger=logger,
+                                target_filename=target_filename,
+                                source_filename=firmware_filename,
+                                metadata=metadata)
+
+            # Update
+            successes, failures = 0, 0
+            hold_versions = {target_version}
+            for module in modules_to_update:
+                address = module.address
+                if address_suffix is not None:
+                    address = '{0}@{1}'.format(address, address_suffix)
+                if module.firmware_version is not None:
+                    hold_versions.add(module.firmware_version)
+                individual_logger = Logs.get_update_logger('{0}_{1}'.format(firmware_type, module.address))
+                try:
+                    new_version = self._master_controller.update_slave_module(firmware_type=firmware_type,
+                                                                              address=address,
+                                                                              hex_filename=target_filename,
+                                                                              version=target_version)
+                    if module.id is not None:
+                        if new_version is not None:
+                            module.firmware_version = new_version
+                        module.last_online_update = int(time.time())
+                        module.update_success = True
+                    successes += 1
+                except Exception as ex:
+                    individual_logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
+                    if module.id is not None:
+                        module.update_success = False
+                    failures += 1
+            db.commit()
+
+        # Cleanup
+        base_template = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
+        UpdateController._clean_old_firmware_versions(base_template=base_template,
+                                                      hold_versions=hold_versions,
+                                                      logger=logger)
+
+        return successes, failures
+
+    def _update_energy_firmware(self, firmware_type, target_version, module_address, firmware_filename, logger, mode, metadata):
+        # type: (str, str, Optional[str], Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
+        module_version = {Firmwares.ENERGY: EnergyEnums.Version.ENERGY_MODULE,
+                          Firmwares.P1_CONCENTRATOR: EnergyEnums.Version.P1_CONCENTRATOR}[firmware_type]
+
+        where_expression = ((EnergyModule.version == module_version) &
+                            (Module.hardware_type == HardwareType.PHYSICAL))
+        if module_address is not None:
+            where_expression &= (Module.address == module_address)
+
+        with Database.get_session() as db:
+            modules = [em.module for em in db.query(EnergyModule).where(where_expression).all()]
+            modules_to_update = UpdateController._filter_modules_to_update(db,
+                                                                           all_modules=modules,
+                                                                           target_version=target_version,
+                                                                           mode=mode)
+            if not modules_to_update:
+                if module_address is None or mode != UpdateEnums.Modes.FORCED:
+                    return 0, 0
+                modules_to_update = [Module(address=module_address)]
+
+            # Fetch the firmware
+            filename_code = UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].code
+            filename_base = UpdateConstants.FIRMWARE_NAME_TEMPLATE.format(filename_code)
+            target_filename = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
+            self._load_firmware(firmware_type=firmware_type,
+                                version=target_version,
+                                logger=logger,
+                                target_filename=target_filename,
+                                source_filename=firmware_filename,
+                                metadata=metadata)
+
+            # Update
+            successes, failures = 0, 0
+            hold_versions = {target_version}
+            for module in modules_to_update:
+                module_address = module.address
+                if module.firmware_version is not None:
+                    hold_versions.add(module.firmware_version)
+                individual_logger = Logs.get_update_logger('{0}_{1}'.format(EnergyEnums.VERSION_TO_STRING[module_version], module_address))
+                try:
+                    new_version = self._energy_module_controller.update_module(module_version=module_version,
+                                                                               module_address=module_address,
+                                                                               firmware_filename=target_filename,
+                                                                               firmware_version=target_version)
+                    if module.id is not None:
+                        if new_version is not None:
+                            module.firmware_version = new_version
+                        module.last_online_update = int(time.time())
+                        module.update_success = True
+                    successes += 1
+                except Exception as ex:
+                    individual_logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
+                    if module.id is not None:
+                        module.update_success = False
+                    failures += 1
+            db.commit()
+
+        # Cleanup
+        base_template = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
+        UpdateController._clean_old_firmware_versions(base_template=base_template,
+                                                      hold_versions=hold_versions,
+                                                      logger=logger)
+
+        return successes, failures
+
+    @staticmethod
+    def _filter_modules_to_update(db, all_modules, target_version, mode):
+        # type: (Any, List[Module], str, str) -> List[Module]
+        modules_to_update = []
+        for module in all_modules:
+            if module.firmware_version == target_version:
+                # Only update an alread-up-to-date module if it's forced
+                if mode == UpdateEnums.Modes.FORCED:
+                    modules_to_update.append(module)
+                else:
+                    module.update_success = True
+                    db.add(module)
+                    db.commit()
+            else:
+                # When an outdated module is automatically updated, it should
+                # take the update_success into account (no retries yet), but
+                # otherwise (manual or forced) it can be updated
+                if mode == UpdateEnums.Modes.AUTOMATIC:
+                    if module.update_success is None:
+                        modules_to_update.append(module)
+                else:
+                    modules_to_update.append(module)
+        return modules_to_update
+
+    def _update_master_firmware(self, firmware_type, target_version, firmware_filename, logger, mode, metadata):
+        # type: (str, str, Optional[str], Logger, str, Optional[Dict[str, Any]]) -> Tuple[int, int]
+        try:
+            current_version = self._fetch_version(firmware_type=firmware_type, logger=logger)
+            if mode != UpdateEnums.Modes.FORCED and current_version == target_version:
+                logger.info('Master already up-to-date')
+                UpdateController._register_version_success(firmware_type, success=True)
+                return 0, 0
+
+            # Fetch the firmware
+            filename_code = UpdateConstants.FIRMWARE_INFO_MAP[firmware_type].code
+            filename_base = UpdateConstants.FIRMWARE_NAME_TEMPLATE.format(filename_code)
+            target_filename = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base.format(target_version))
+            self._load_firmware(firmware_type=firmware_type,
+                                version=target_version,
+                                logger=logger,
+                                target_filename=target_filename,
+                                source_filename=firmware_filename,
+                                metadata=metadata)
+
+            # Update
+            self._master_controller.update_master(hex_filename=target_filename,
+                                                  version=target_version)
+
+            # Cleanup
+            base_template = UpdateConstants.FIRMWARE_FILENAME_TEMPLATE.format(filename_base)
+            UpdateController._clean_old_firmware_versions(base_template=base_template,
+                                                          hold_versions={current_version, target_version},
+                                                          logger=logger)
+
+            UpdateController._register_version_success(firmware_type, success=True)
+            return 1, 0
+        except Exception as ex:
+            logger.exception('Error when updating {0}: {1}'.format(firmware_type, ex))
+            UpdateController._register_version_success(firmware_type, success=False)
+            return 0, 1
+
+    def _fetch_version(self, logger, firmware_type):  # type: (Logger, str) -> Optional[str]
+        try:
+            if firmware_type in [Firmwares.MASTER_CLASSIC, Firmwares.MASTER_COREPLUS]:
+                return '.'.join(str(e) for e in self._master_controller.get_firmware_version())
+        except Exception as ex:
+            logger.warning('Could not load {0} version: {1}'.format(firmware_type, ex))
+        return None
+
+    @staticmethod
+    def _get_target_version_info(firmware_type):
+        # type: (str) -> Tuple[Optional[bool], Optional[str], Optional[Dict[str, Any]]]
+        target_versions = Config.get_entry('firmware_target_versions', None)  # type: Optional[Dict[str, Dict[str, Any]]]
+        if target_versions is None:
+            target_versions = {}
+            Config.set_entry('firmware_target_versions', target_versions)
+            return None, None, None
+        if firmware_type not in target_versions:
+            return None, None, None
+        target_version_info = target_versions[firmware_type]
+        metadata = None  # type: Optional[Dict[str, Any]]
+        if 'urls' in target_version_info and 'sha256' in target_version_info:
+            metadata = {'urls': target_version_info['urls'],
+                        'sha256': target_version_info['sha256']}
+        return (target_version_info.get('success'),
+                target_version_info['target_version'],
+                metadata)
+
+    @staticmethod
+    def _register_version_success(firmware_type, success):
+        # type: (str, bool) -> None
+        target_versions = Config.get_entry('firmware_target_versions', None)  # type: Optional[Dict[str, Dict[str, Any]]]
+        if target_versions is None or firmware_type not in target_versions:
+            return
+        target_versions[firmware_type]['success'] = success
+        Config.set_entry('firmware_target_versions', target_versions)
+
+    @staticmethod
+    def _clean_old_firmware_versions(base_template, hold_versions, logger):
+        logger.info('Clean up old firmware versions')
+        path_prefix = base_template.split('{0}')[0]
+
+        def _extract_version(filename_):
+            return filename_.replace(path_prefix, '').replace('.hex', '')
+
+        versions = set()  # type: Set[str]
+        for version_path in glob.glob(base_template.format('*')):
+            versions.add(_extract_version(version_path))
+        versions_to_keep = (set(hold_versions) |
+                            set(sorted(versions, reverse=True)[:3]))
+        for version in versions:
+            if version in versions_to_keep:
+                logger.info('Keeping {0}'.format(version))
+                continue
+            logger.info('Removing {0}'.format(version))
+            os.remove(base_template.format(version))
+
+    def _load_firmware(self, firmware_type, version, logger, target_filename, metadata, source_filename=None):
+        # type: (str, str, Logger, str, Optional[Dict[str, Any]], Optional[str]) -> None
+        if source_filename is not None:
+            if source_filename != target_filename:
+                shutil.copy(src=source_filename,
+                            dst=target_filename)
+            return
+
+        # Load and parse metadata
+        urls = []
+        if metadata is not None:
+            urls = metadata.get('urls', []) + ([metadata['url']] if 'url' in metadata else [])
+            if not urls:
+                metadata = None  # Download metadata again, since no urls were found
+        if metadata is None:
+            logger.info('Downloading firmware metadata for {0} {1}'.format(firmware_type, version))
+            response = requests.get(self._get_update_firmware_metadata_url(firmware_type, version),
+                                    timeout=5,
+                                    verify=System.verify_requests())
+            if response.status_code != 200:
+                raise ValueError('Failed to get firmware metadata for {0} {1}'.format(firmware_type, version))
+            metadata = response.json()
+            urls = metadata.get('urls', []) + ([metadata['url']] if 'url' in metadata else [])
+        checksum = metadata['sha256']
+
+        # Fetch file
+        if os.path.exists(target_filename):
+            actual_checksum = UpdateController._calculate_checksum(filename=target_filename)
+            if actual_checksum == checksum:
+                logger.info('Using firmware from cache: {0} (checksum: {1})'.format(target_filename, checksum))
+                return  # File exists and is valid, no need to redownload
+        if not urls:
+            raise ValueError('Could not find any download url in firmware metadata for {0} {1}'.format(firmware_type, version))
+        Toolbox.download_urls(urls=urls,
+                              checksum=checksum,
+                              logger=logger,
+                              target_filename=target_filename)
+
+    @staticmethod
+    def _calculate_checksum(filename):  # type: (str) -> Optional[str]
+        try:
+            hasher = hashlib.sha256()
+            with open(filename, 'rb') as f:
+                hasher.update(f.read())
+            calculated_hash = hasher.hexdigest()
+            return calculated_hash
+        except Exception:
+            pass
+        return None
+
+    def _get_update_metadata_url(self, version):
+        query = 'uuid={0}'.format(self._gateway_uuid)
+        update_url = Config.get_entry('update_metadata_url', None)  # type: Optional[str]
+        if update_url is None:
+            parsed_url = urlparse(self._cloud_url)
+            path = '/api/v1.1/base/updates/metadata/{0}'.format(version)
+        else:
+            parsed_url = urlparse(update_url)
+            path = parsed_url.path
+        return urlunparse((parsed_url.scheme, parsed_url.netloc, path, '', query, ''))
+
+    def _get_update_firmware_metadata_url(self, firmware_type, version):
+        query = 'uuid={0}'.format(self._gateway_uuid)
+        update_url = Config.get_entry('update_firmware_metadata_url', None)  # type: Optional[str]
+        if update_url is None:
+            parsed_url = urlparse(self._cloud_url)
+            path = '/api/v1.1/base/updates/metadata/firmwares/{0}/{1}'.format(firmware_type, version)
+        else:
+            parsed_url = urlparse(update_url)
+            path = parsed_url.path
+        return urlunparse((parsed_url.scheme, parsed_url.netloc, path, '', query, ''))
diff --git a/src/gateway/updates/update_gateway.py b/src/gateway/updates/update_gateway.py
new file mode 100644
index 00000000..67d4615c
--- /dev/null
+++ b/src/gateway/updates/update_gateway.py
@@ -0,0 +1,631 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Update logic for the Gateway service
+"""
+from __future__ import absolute_import
+import re
+import sys
+import time
+import tempfile
+import glob
+import os
+import json
+import logging
+import constants
+import requests
+import gateway
+import shutil
+import stat
+from collections import namedtuple
+from toolbox import Toolbox
+from gateway.updates.update_constants import UpdateConstants
+from platform_utils import Platform, System
+from gateway.enums import Firmwares
+
+if False:  # MYPY
+    from typing import List, Optional, Dict, Set, Tuple, Callable
+    from logging import Logger
+
+# Different name to reduce confusion between multiple used loggers
+global_logger = logging.getLogger(__name__)
+
+FirmwareInfo = namedtuple('FirmwareInfo', 'code  module_types')
+
+
+class GatewayUpdateController(object):
+
+    @staticmethod
+    def build_venv_version(interpreter_version, dependencies_version, gateway_service_version):
+        # type: (str, str, str) -> str
+        return '{0}_{1}_{2}'.format(interpreter_version, dependencies_version, gateway_service_version)
+
+    @staticmethod
+    def install_python_interpreter(filename, target_version, logger):
+        # type: (str, str, Logger) -> None
+        _ = target_version
+        with Toolbox.rw_mounted_root(logger=logger):
+            logger.info('Extracting archive...')
+            Toolbox.extract_tgz(filename=filename,
+                                output_dir='/',
+                                logger=logger)
+        os.remove(filename)
+
+    @staticmethod
+    def install_python_dependencies(filename, target_version, logger):
+        # type: (str, str, Logger) -> None
+        dependencies_dir = UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE.format(target_version)
+        os.makedirs(dependencies_dir)
+        logger.info('Extracting archive...')
+        Toolbox.extract_tgz(filename=filename,
+                            output_dir=dependencies_dir,
+                            logger=logger)
+        os.remove(filename)
+
+    @staticmethod
+    def install_gateway_service(filename, target_version, logger):
+        # type: (str, str, Logger) -> None
+        gateway_service_dir = os.path.join(UpdateConstants.SERVICE_BASE_TEMPLATE.format(target_version), 'python')
+        os.makedirs(gateway_service_dir)
+        logger.info('Extracting archive...')
+        Toolbox.extract_tgz(filename=filename,
+                            output_dir=gateway_service_dir,
+                            logger=logger)
+        os.remove(filename)
+
+    @staticmethod
+    def install_venv(component_versions, logger):
+        # type: (Dict[str, str], Logger) -> bool
+        try:
+            interpreter_version = component_versions[Firmwares.PYTHON_INTERPRETER]
+            dependencies_version = component_versions[Firmwares.PYTHON_DEPENDENCIES]
+            gateway_service_version = component_versions[Firmwares.GATEWAY_SERVICE]
+            venv_version = GatewayUpdateController.build_venv_version(interpreter_version=interpreter_version,
+                                                                      dependencies_version=dependencies_version,
+                                                                      gateway_service_version=gateway_service_version)
+
+            logger.info('Generating virtual environment with interpreter {0}, dependencies {1} and service {2}'.format(
+                interpreter_version, dependencies_version, gateway_service_version
+            ))
+            # Get python binary path
+            if os.path.exists(UpdateConstants.VENV_CURRENT):
+                python_binary_path = os.path.join(UpdateConstants.VENV_CURRENT, 'venv/bin/python')
+            else:
+                python_binary_path = '/usr/bin/python'
+            # Start actual update
+            logger.info('Detaching virtual environment generation process')
+            Toolbox.execute(
+                command=[python_binary_path,
+                         os.path.join(UpdateConstants.PREFIX, 'python', 'openmotics_update.py'),
+                         '--build-virtual-environment', venv_version],
+                logger=logger)
+            time.sleep(300)  # Wait 5 minutes, the service should be stopped by above detached process anyway
+            return True
+        except Exception as ex:
+            logger.error('Could not generate virtual environment: {0}'.format(ex))
+            return False
+
+    @staticmethod
+    def generate_virtual_environment(version, logger):
+        # type: (str, Logger) -> None
+        """ Executed from within a separate process """
+        logger.info('Stopping services')
+        System.run_service_action('stop', System.Service.OPENMOTICS).wait()
+        System.run_service_action('stop', System.Service.VPN_SERVICE).wait()
+
+        interpreter_version, dependencies_version, gateway_service_version = version.split('_')
+
+        old_version_folder = ''
+        running_marker = ''
+        venv_base_directory = os.path.join(UpdateConstants.VERSIONS_FOLDER, 'venv')
+        if not os.path.exists(venv_base_directory):
+            os.makedirs(venv_base_directory)
+
+        try:
+            GatewayUpdateController._migrate_legacy_directory_structures(logger=logger)
+
+            old_version = os.readlink(UpdateConstants.VENV_CURRENT).split(os.path.sep)[-1]
+            old_version_folder = UpdateConstants.VENV_BASE_TEMPLATE.format(old_version)
+            new_version_folder = UpdateConstants.VENV_BASE_TEMPLATE.format(version)
+
+            success_marker = os.path.join(new_version_folder, 'update.success')
+            running_marker = os.path.join(new_version_folder, 'update.running')
+
+            if os.path.exists(new_version_folder) and not os.path.exists(success_marker):
+                # Remove the existing `new_version_folder` if the contents could not be started
+                shutil.rmtree(new_version_folder)
+
+            if not os.path.exists(new_version_folder):
+                os.mkdir(new_version_folder)
+                Toolbox._touch(running_marker)
+
+                new_python_symlink = os.path.join(new_version_folder, 'python')
+                old_python_symlink = os.path.join(old_version_folder, 'python')
+
+                # Link in gateway_service / service
+                os.symlink(os.path.join(UpdateConstants.SERVICE_BASE_TEMPLATE.format(gateway_service_version), 'python'),
+                           new_python_symlink)
+
+                # Copy `etc`
+                logger.info('Copy `etc` folder')
+                shutil.copytree(os.path.join(old_version_folder, 'etc'),
+                                os.path.join(new_version_folder, 'etc'),
+                                symlinks=True)
+
+                # Restore plugins
+                if os.readlink(new_python_symlink) != os.readlink(old_python_symlink):
+                    logger.info('Copy plugins...')
+                    plugins = glob.glob('{0}{1}*{1}'.format(os.path.join(old_python_symlink, 'plugins'), os.path.sep))
+                    for plugin_path in plugins:
+                        plugin = plugin_path.strip('/').rsplit('/', 1)[-1]
+                        if plugin == '__pycache__':
+                            continue
+                        logger.info('Copy plugin {0}'.format(plugin))
+                        Toolbox.execute(command=['cp', '-R',
+                                                 os.path.join(old_python_symlink, 'plugins', plugin),
+                                                 os.path.join(new_python_symlink, 'plugins', '')],
+                                        logger=logger)
+
+                logger.info('Installing virtualenv...')
+                virtualenv_directory = os.path.join(new_version_folder, 'venv')
+                virtualenv_bin_directory = os.path.join(virtualenv_directory, 'bin')
+                os.makedirs(virtualenv_bin_directory)
+                site_packages_suffix = 'lib/python{0}/site-packages'.format(interpreter_version.rsplit('.', 1)[0])
+                virtualenv_site_packages_directory = os.path.join(virtualenv_directory, site_packages_suffix)
+                os.makedirs(virtualenv_site_packages_directory)
+                nix_python_binary = os.path.join(UpdateConstants.NIX_PROFILES_DIRECTORY.format('python{0}'.format(interpreter_version)), 'bin', 'python')
+                Toolbox.execute([nix_python_binary, '-m', 'venv', virtualenv_directory, '--without-pip'],
+                                logger=logger)
+                depdencies_site_packages_directory = os.path.join(UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE.format(dependencies_version),
+                                                                  site_packages_suffix)
+                with open(os.path.join(virtualenv_site_packages_directory, 'python_dependencies.pth'), 'w') as fd:
+                    fd.write(depdencies_site_packages_directory)
+                python_binary = os.path.join(virtualenv_bin_directory, 'python')
+                Toolbox.execute([python_binary, '-m', 'pip', 'install', '-e', new_python_symlink, '--no-index'],
+                                logger=logger)
+                os.symlink(depdencies_site_packages_directory, os.path.join(virtualenv_directory, 'python-dependencies'))
+
+            Toolbox._touch(running_marker)  # Make sure the running marker exists
+
+            # Keep track of the old version, so it can be manually restored if something goes wrong
+            logger.info('Tracking previous version')
+            if os.path.exists(UpdateConstants.VENV_PREVIOUS):
+                os.unlink(UpdateConstants.VENV_PREVIOUS)
+            os.symlink(old_version_folder, UpdateConstants.VENV_PREVIOUS)
+
+            # Prepare new code for first startup
+            logger.info('Preparing for first startup')
+            Toolbox.execute(command=[os.path.join(new_version_folder, 'venv/bin/python'),
+                                     os.path.join(new_version_folder, 'python/openmotics_update.py'),
+                                     '--prepare-gateway-service-for-first-startup', version],
+                            logger=logger)
+
+            # Symlink to new version
+            logger.info('Symlink to new version')
+            os.unlink(UpdateConstants.VENV_CURRENT)
+            os.symlink(new_version_folder, UpdateConstants.VENV_CURRENT)
+
+            # Startup
+            logger.info('Starting services')
+            System.reload_services(wait=True)
+
+            # Health-check
+            logger.info('Starting health check')
+            update_successful = GatewayUpdateController._check_gateway_service_health(logger=logger)
+
+            # Rollback to old version
+            if not update_successful:
+                logger.info('Update failed, restoring')
+                System.run_service_action('stop', System.Service.OPENMOTICS).wait()
+                System.run_service_action('stop', System.Service.VPN_SERVICE).wait()
+                os.unlink(UpdateConstants.VENV_CURRENT)
+                os.symlink(old_version_folder, UpdateConstants.VENV_CURRENT)
+                # Raise with actual reason
+                raise RuntimeError('Failed to start {0}'.format(version))
+
+            # Cleanup
+            GatewayUpdateController._clean_old_versions(firmware_type=Firmwares.VIRTUAL_ENVIRONMENT,
+                                                        base_template=UpdateConstants.VENV_BASE_TEMPLATE,
+                                                        logger=logger)
+            GatewayUpdateController._clean_obsolete_venv_dependencies(logger=logger)
+
+            # Update markers
+            Toolbox._touch(success_marker)
+            logger.info('Update completed')
+        except Exception as ex:
+            logger.exception('Unexpected exception setting up new version: {0}'.format(ex))
+            if old_version_folder and not os.path.exists(UpdateConstants.VENV_CURRENT):
+                os.symlink(old_version_folder, UpdateConstants.VENV_CURRENT)
+            # Start services again
+            System.run_service_action('start', System.Service.OPENMOTICS).wait()
+            System.run_service_action('start', System.Service.VPN_SERVICE).wait()
+            raise
+        finally:
+            if running_marker and os.path.exists(running_marker):
+                os.remove(running_marker)  # Cleanup running marker
+
+    @staticmethod
+    def _migrate_legacy_directory_structures(logger):
+        # type: (Logger) -> None
+        if os.path.exists(UpdateConstants.VENV_CURRENT):
+            # Already up-to-date
+            return
+
+        # Migrate pre-versions structure
+        service_current = UpdateConstants.SERVICE_BASE_TEMPLATE.format('current')
+        if not os.path.exists(service_current):
+            old_version_folder = UpdateConstants.SERVICE_BASE_TEMPLATE.format(gateway.__version__)
+            os.makedirs(old_version_folder)
+            os.symlink(old_version_folder, service_current)
+
+            for folder in ['python', 'etc', 'python-deps']:
+                old_location = os.path.join(UpdateConstants.PREFIX, folder)
+                new_location = os.path.join(service_current, folder)
+                shutil.move(old_location, new_location)
+                os.symlink(new_location, old_location)
+
+        # Migrate pre-nix structure
+        service_previous_symlink = UpdateConstants.SERVICE_BASE_TEMPLATE.format('previous')
+        service_current_symlink = UpdateConstants.SERVICE_BASE_TEMPLATE.format('current')
+        service_current_real = os.readlink(service_current_symlink)
+        python_version = '{0}.{1}.{2}'.format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)
+
+        # Create /x/versions/venv/<python>_<legacy>_<service>
+        old_version_folder = UpdateConstants.VENV_BASE_TEMPLATE.format(
+            GatewayUpdateController.build_venv_version(python_version,
+                                                       UpdateConstants.LEGACY_DEPENDENCIES_VERSION,
+                                                       gateway.__version__)
+        )
+        os.makedirs(old_version_folder)
+
+        # Symlink /x/versions/venv/current|legacy -> /x/versions/venv/<python>_<legacy>_<service>
+        os.symlink(old_version_folder, UpdateConstants.VENV_CURRENT)
+        os.symlink(old_version_folder, UpdateConstants.VENV_LEGACY)
+
+        # Symlink /x/versions/venv/current/python -> /x/versions/service/<service>/python
+        os.symlink(os.path.join(service_current_real, 'python'),
+                   os.path.join(UpdateConstants.VENV_CURRENT, 'python'))
+        # Move /x/versions/service/<service>/etc -> /x/versions/venv/current/etc
+        shutil.move(os.path.join(service_current_real, 'etc'),
+                    os.path.join(UpdateConstants.VENV_CURRENT, 'etc'))
+
+        # Unlink /x/python, /x/etc and /x/python-deps
+        os.unlink(os.path.join(UpdateConstants.PREFIX, 'python'))
+        os.unlink(os.path.join(UpdateConstants.PREFIX, 'etc'))
+        os.unlink(os.path.join(UpdateConstants.PREFIX, 'python-deps'))
+
+        # Unlink /x/versions/service/current and /x/versions/service/previous
+        os.unlink(service_current_symlink)
+        if os.path.exists(service_previous_symlink):
+            os.unlink(service_previous_symlink)
+
+        # Symlink /x/pyton -> /x/versions/venv/current/python
+        os.symlink(os.path.join(UpdateConstants.VENV_CURRENT, 'python'),
+                   os.path.join(UpdateConstants.PREFIX, 'python'))
+        # Symlink /x/etc -> /x/versions/venv/current/etc
+        os.symlink(os.path.join(UpdateConstants.VENV_CURRENT, 'etc'),
+                   os.path.join(UpdateConstants.PREFIX, 'etc'))
+
+        # Move ../versions/service/<service>/python-deps -> /x/versions/dependencies/<legacy>
+        shutil.move(os.path.join(service_current_real, 'python-deps'),
+                    UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE.format(UpdateConstants.LEGACY_DEPENDENCIES_VERSION))
+        # Symlink /x/versions/service/<service>/python-deps -> /x/versions/dependencies/<legacy>  # For rollback to legacy
+        os.symlink(UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE.format(UpdateConstants.LEGACY_DEPENDENCIES_VERSION),
+                   os.path.join(service_current_real, 'python-deps'))
+
+        # Symlink /x/versions/venv/current/venv/python-deps -> /x/versions/dependencies/<legacy>
+        site_packages_directory = os.path.join(UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE.format(UpdateConstants.LEGACY_DEPENDENCIES_VERSION),
+                                               'lib/python2.7/site-packages')
+        os.symlink(site_packages_directory,
+                   os.path.join(UpdateConstants.VENV_CURRENT, 'python-dependencies'))
+
+        # Symlink /x/versions/venv/current/venv/bin/python -> /usr/bin/python  # For rollback to legacy
+        os.makedirs(os.path.join(UpdateConstants.VENV_CURRENT, 'venv/bin'))
+        os.symlink('/usr/bin/python', os.path.join(UpdateConstants.VENV_CURRENT, 'venv/bin/python'))
+
+        # Create dummy python package startup scripts
+        for short_name, service in {'gw-service': 'openmotics_service',
+                                    'gw-vpn-service': 'vpn_service',
+                                    'gw-watchdog': 'watchdog'}.items():
+            file_name = os.path.join(UpdateConstants.VENV_CURRENT, 'venv/bin/{0}'.format(short_name))
+            with open(file_name, 'w') as fd:
+                fd.write('#!/bin/sh\n{0}/venv/bin/python {1}.py\n'.format(old_version_folder, service))
+            file_stat = os.stat(file_name)
+            os.chmod(file_name, file_stat.st_mode | stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH)
+
+    @staticmethod
+    def update_gateway_service_prepare_for_first_startup(version, logger):
+        # type: (str, Logger) -> None
+        """ Executed from within a separate process """
+        # This code will execute after the new version is in place and before the
+        # services are started. It runs the new code, has the new imports
+        # available, ...
+
+        if '_' in version:
+            _, _, gateway_service_version = version.split('_')
+            new_prefix = UpdateConstants.VENV_BASE_TEMPLATE.format(version)
+            venv_path = UpdateConstants.VENV_BASE_TEMPLATE.format(version)  # type: Optional[str]
+        else:
+            gateway_service_version = version
+            new_prefix = UpdateConstants.SERVICE_BASE_TEMPLATE.format(version)
+            venv_path = None
+
+        # Certificates
+        GatewayUpdateController._move_openvpn_certificates(logger)
+
+        # Create sqliterc file
+        GatewayUpdateController._create_sqliterc(logger)
+
+        # Update service files once the virtual environment is active
+        if venv_path is not None:
+            python_binary = os.path.join(venv_path, 'venv/bin/python')
+            if os.path.exists(python_binary):
+                logger.info('Updating service files...')
+                service_manager = System.get_system_manager()
+                services_path = os.path.join(UpdateConstants.SERVICE_BASE_TEMPLATE.format(gateway_service_version),
+                                             'python/etc/services',
+                                             service_manager)
+                if not os.path.exists(services_path):
+                    logger.error('  Could not load new service information')
+                else:
+                    with open(os.path.join(services_path, 'sha256.json'), 'r') as fd:
+                        checksums = json.load(fd)
+                    changed_files = []
+                    for service in System.ALL_SERVICES:
+                        config_filename = System.SERVICE_CONFIG_FILES[service_manager][service]
+                        main_filename = os.path.join(System.SERVICE_CONFIG_FOLDERS[service_manager],
+                                                     config_filename)
+                        temp_filename = '{0}.temp'.format(main_filename)
+                        if not os.path.exists(main_filename):
+                            need_update = True
+                        else:
+                            current_checksum = Toolbox.calculate_checksum(main_filename)
+                            need_update = current_checksum != checksums.get(service)
+                        if need_update:
+                            changed_files.append((main_filename,
+                                                  temp_filename,
+                                                  os.path.join(services_path, config_filename)))
+                    if changed_files:
+                        with Toolbox.rw_mounted_root(logger=logger):
+                            for main_filename, temp_filename, source_filename in changed_files:
+                                shutil.copy(source_filename, temp_filename)
+                                os.rename(temp_filename, main_filename)
+                                logger.info('  Updated {0}'.format(main_filename))
+
+        # Migrations of `openmotics.conf`
+        from six.moves.configparser import ConfigParser
+        openmotics_conf_path = constants.get_config_file(prefix=new_prefix)
+        openmotics_conf_path_temp = '{0}.temp'.format(openmotics_conf_path)
+        if sys.version_info.major == 3:
+            config = ConfigParser(interpolation=None)
+        else:
+            config = ConfigParser()
+        config.read(openmotics_conf_path)
+        if config.has_option('OpenMotics', 'version'):
+            config.remove_option('OpenMotics', 'version')
+        if config.has_option('OpenMotics', 'vpn_check_url'):
+            vpn_check_url = config.get('OpenMotics', 'vpn_check_url')
+            if '?uuid=%s' in vpn_check_url.strip():
+                vpn_check_url = vpn_check_url.strip().replace('?uuid=%s', '')
+                config.set('OpenMotics', 'vpn_check_url', vpn_check_url)
+        with open(openmotics_conf_path_temp, 'w') as fp:
+            config.write(fp)
+        os.rename(openmotics_conf_path_temp, openmotics_conf_path)
+
+        logger.info('Preparation for first virtual environment startup completed')
+
+    @staticmethod
+    def update_gateway_frontend(new_version, filename, logger):
+        # type: (str, str, Logger) -> None
+        logger.info('Updating gateway frontend to {0}'.format(new_version))
+
+        # Migrate legacy folder structure, if needed
+        if not os.path.exists(UpdateConstants.FRONTEND_CURRENT):
+            current_version = GatewayUpdateController.fetch_version(firmware_type=Firmwares.GATEWAY_FRONTEND, logger=logger)
+            if current_version is None:
+                current_version = 'legacy'
+            old_version_folder = UpdateConstants.FRONTEND_BASE_TEMPLATE.format(current_version)
+            os.makedirs(old_version_folder)
+            os.symlink(old_version_folder, UpdateConstants.FRONTEND_CURRENT)
+
+            old_location = os.path.join(UpdateConstants.PREFIX, 'static')
+            new_location = os.path.join(UpdateConstants.FRONTEND_CURRENT, 'static')
+            shutil.move(old_location, new_location)
+            os.symlink(new_location, old_location)
+
+        new_version_folder = UpdateConstants.FRONTEND_BASE_TEMPLATE.format(new_version)
+        if not os.path.exists(new_version_folder):
+            os.mkdir(new_version_folder)
+
+            # Extract new version
+            logger.info('Extracting archive')
+            os.makedirs(os.path.join(new_version_folder, 'static'))
+            Toolbox.extract_tgz(filename=filename,
+                                output_dir=os.path.join(new_version_folder, 'static'),
+                                logger=logger)
+
+            # Remove old archive
+            os.remove(filename)
+
+        # Symlink to new version
+        logger.info('Symlink to new version')
+        os.unlink(UpdateConstants.FRONTEND_CURRENT)
+        os.symlink(new_version_folder, UpdateConstants.FRONTEND_CURRENT)
+
+        # Cleanup
+        GatewayUpdateController._clean_old_versions(firmware_type=Firmwares.GATEWAY_FRONTEND,
+                                                    base_template=UpdateConstants.FRONTEND_BASE_TEMPLATE,
+                                                    logger=logger)
+
+        logger.info('Update completed')
+
+    @staticmethod
+    def _move_openvpn_certificates(logger):  # type: (Logger) -> None
+        vpn_prefix = UpdateConstants.CERTIFICATES_OPENVPN
+        settings = {'ca': os.path.join(vpn_prefix, 'ca.crt'),
+                    'cert': os.path.join(vpn_prefix, 'client.crt'),
+                    'key': os.path.join(vpn_prefix, 'client.key')}
+        if not System.legacy_authentication():
+            settings.update({'cipher': 'AES-256-CBC'})
+
+        changed = False
+        lines = []
+        with open(UpdateConstants.OPENVPN_CONFIG, 'r') as fd:
+            for line in (x.rstrip() for x in fd.readlines()):
+                prefix, _, value = line.partition(' ')
+                if prefix in settings and settings[prefix] != value:
+                    changed = True
+                    lines.append('{0} {1}'.format(prefix, settings[prefix]))
+                else:
+                    lines.append(line)
+        if not changed:
+            return
+
+        logger.info('Copying openvpn certificates...')
+        unknown = UpdateConstants.CERTIFICATES_BASE_TEMPLATE.format('unknown')
+        if os.path.exists(unknown):
+            shutil.rmtree(unknown)
+
+        os.makedirs(unknown)
+        for file_ in ('ca.crt', 'client.crt', 'client.key'):
+            shutil.copy(src=os.path.join(os.path.dirname(UpdateConstants.OPENVPN_CONFIG), file_),
+                        dst=os.path.join(unknown, file_))
+
+        for link in (UpdateConstants.CERTIFICATES_CURRENT, UpdateConstants.CERTIFICATES_OPENVPN):
+            if os.path.exists(link):
+                os.unlink(link)
+            os.symlink('unknown', link)
+
+        with Toolbox.rw_mounted_root(logger=logger):
+            logger.info('Updating openvpn config...')
+            if not os.path.exists(UpdateConstants.OPENVPN_CONFIG + '.BACKUP'):
+                shutil.copy(UpdateConstants.OPENVPN_CONFIG, UpdateConstants.OPENVPN_CONFIG + '.BACKUP')
+            temp_config = tempfile.mktemp(dir=os.path.dirname(UpdateConstants.OPENVPN_CONFIG))
+            with open(temp_config, 'w') as fd:
+                fd.write('\n'.join(lines))
+            os.rename(temp_config, UpdateConstants.OPENVPN_CONFIG)
+
+    @staticmethod
+    def _create_sqliterc(logger):  # type: (Logger) -> None
+        try:
+            if not os.path.exists(UpdateConstants.SQLITERC_FILE):
+                logger.info('Creating {} ...'.format(UpdateConstants.SQLITERC_FILE))
+                temp_rc = tempfile.mktemp(dir=os.path.dirname(UpdateConstants.SQLITERC_FILE))
+                with open(temp_rc, 'w') as fd:
+                    fd.write(UpdateConstants.SQLITERC_DEFAULT_CONFIG)
+                os.rename(temp_rc, UpdateConstants.SQLITERC_FILE)
+        except Exception as ex:
+            logger.warning('Could not create {0}: {1}'.format(UpdateConstants.SQLITERC_FILE, ex))
+
+    @staticmethod
+    def fetch_version(firmware_type, logger):  # type: (str, Logger) -> Optional[str]
+        try:
+            if firmware_type == Firmwares.GATEWAY_SERVICE:
+                return gateway.__version__
+            if firmware_type in [Firmwares.PYTHON_DEPENDENCIES, Firmwares.PYTHON_INTERPRETER]:
+                if os.path.exists(UpdateConstants.VENV_CURRENT):
+                    venv_version = os.readlink(UpdateConstants.VENV_CURRENT).split(os.path.sep)[-1]
+                    interpreter_version, dependencies_version, _ = venv_version.split('_')
+                    if firmware_type == Firmwares.PYTHON_INTERPRETER:
+                        return interpreter_version
+                    if firmware_type == Firmwares.PYTHON_DEPENDENCIES:
+                        return dependencies_version
+            if firmware_type == Firmwares.GATEWAY_FRONTEND:
+                if not os.path.exists(UpdateConstants.FRONTEND_CURRENT):
+                    with open(os.path.join(UpdateConstants.PREFIX, 'static', 'index.html'), 'r') as index:
+                        match = re.search(r"v(\d+?\.\d+?\.\d+)", index.read())
+                        if match is not None:
+                            return match.groups()[0]
+                return str(os.readlink(UpdateConstants.FRONTEND_CURRENT).split(os.path.sep)[-1])
+        except Exception as ex:
+            logger.warning('Could not load {0} version: {1}'.format(firmware_type, ex))
+        return None
+
+    @staticmethod
+    def _clean_obsolete_venv_dependencies(logger):
+        # type: (Logger) -> None
+        logger.info('Cleaning up obsolete virtual environment dependencies')
+        try:
+            # Collect current dependencies
+            versions = [set(), set()]  # type: List[Set[str]]
+            for version_path in glob.glob(UpdateConstants.VENV_BASE_TEMPLATE.format('*')):
+                version = version_path.strip('/').rsplit('/', 1)[-1]
+                match = re.search(r"^([\da-z.]+?)_([\da-z.]+?)_([\da-z.]+?)$", version)
+                if match is None:
+                    continue
+                _, dependencies_version, gateway_service_version = match.groups()
+                versions[0].add(str(dependencies_version))
+                versions[1].add(str(gateway_service_version))
+
+            # Clean out obsolete dependencies
+            firmware_type_info = {Firmwares.PYTHON_DEPENDENCIES: (0, UpdateConstants.PYTHON_DEPENDENCIES_BASE_TEMPLATE),
+                                  Firmwares.GATEWAY_SERVICE: (1, UpdateConstants.SERVICE_BASE_TEMPLATE)}  # type: Dict[str, Tuple[int, str]]
+            for firmware_type, info in firmware_type_info.items():
+                index, base_template = info
+                GatewayUpdateController._clean_old_versions(firmware_type=firmware_type,
+                                                            base_template=base_template,
+                                                            logger=logger,
+                                                            keep=lambda version_: version_ in versions[index])
+        except Exception as ex:
+            logger.warning('Could not clean up obsolete dependencies: {0}'.format(ex))
+
+    @staticmethod
+    def _clean_old_versions(firmware_type, base_template, logger, keep=None):
+        # type: (str, str, Logger, Optional[Callable[[str], bool]]) -> None
+        firmware_type_string = firmware_type.replace('_', ' ')
+        logger.info('Clean up old {0} versions'.format(firmware_type_string))
+        try:
+            all_versions = set()  # type: Set[str]
+            versions_to_keep = set()  # type: Set[str]
+            for version_path in glob.glob(base_template.format('*')):
+                version = version_path.strip('/').rsplit('/', 1)[-1]
+                if 'tgz' in version or version.endswith('.failure'):
+                    continue
+                if version in ['current', 'previous', 'legacy']:
+                    versions_to_keep.add(os.readlink(base_template.format(version)).split(os.path.sep)[-1])
+                elif keep is not None and keep(version):
+                    versions_to_keep.add(version)
+                else:
+                    all_versions.add(version)
+            versions_to_keep |= set(sorted(all_versions, reverse=True)[:3])
+            for version in all_versions:
+                if version in versions_to_keep:
+                    logger.info('Keeping {0} {1}'.format(firmware_type_string, version))
+                    continue
+                logger.info('Removing {0} {1}'.format(firmware_type_string, version))
+                shutil.rmtree(base_template.format(version))
+        except Exception as ex:
+            logger.warning('Could not clean up old versions with base_template {0}: {1}'.format(base_template, ex))
+
+    @staticmethod
+    def _check_gateway_service_health(logger, timeout=300):
+        since = time.time()
+        pending = ['unknown']
+        http_port = Platform.http_port()
+        while since > time.time() - timeout:
+            try:
+                logger.info('Checking gw service health...')
+                response = requests.get('http://127.0.0.1:{}/health_check'.format(http_port), timeout=2)
+                data = response.json()
+                if data['success']:
+                    pending = [k for k, v in data['health'].items() if not v['state']]
+                    if not pending:
+                        logger.info('Health-check completed successfully')
+                        return True
+            except Exception:
+                pass
+            time.sleep(10)
+        logger.error('Health-check failed with pending {0}'.format(', '.join(pending)))
+        return False
diff --git a/src/gateway/valve_pump/__init__.py b/src/gateway/valve_pump/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/src/gateway/thermostat/gateway/pump_driver.py b/src/gateway/valve_pump/pump_driver.py
similarity index 100%
rename from src/gateway/thermostat/gateway/pump_driver.py
rename to src/gateway/valve_pump/pump_driver.py
diff --git a/src/gateway/thermostat/gateway/valve_driver.py b/src/gateway/valve_pump/valve_driver.py
similarity index 95%
rename from src/gateway/thermostat/gateway/valve_driver.py
rename to src/gateway/valve_pump/valve_driver.py
index 8aff90a0..01b22f4e 100644
--- a/src/gateway/thermostat/gateway/valve_driver.py
+++ b/src/gateway/valve_pump/valve_driver.py
@@ -47,9 +47,9 @@ class ValveDriver(object):
     def percentage(self):  # type: () -> int
         return self._current_percentage
 
-    @property
-    def is_open(self):  # type: () -> bool
-        now_open = self._current_percentage > 0
+    def is_open(self, percentage=0):  # type: (int) -> bool
+        # return true if valve is open, return false if valve is not open or still moving
+        now_open = self._current_percentage > percentage
         return now_open if not self.in_transition else False
 
     @property
diff --git a/src/gateway/thermostat/gateway/pump_valve_controller.py b/src/gateway/valve_pump/valve_pump_controller.py
similarity index 68%
rename from src/gateway/thermostat/gateway/pump_valve_controller.py
rename to src/gateway/valve_pump/valve_pump_controller.py
index 39bf8bab..7f90b27e 100644
--- a/src/gateway/thermostat/gateway/pump_valve_controller.py
+++ b/src/gateway/valve_pump/valve_pump_controller.py
@@ -16,10 +16,10 @@
 import logging
 from threading import Lock
 
-from gateway.models import Database, Pump, Valve
-from gateway.thermostat.gateway.pump_driver import PumpDriver
-from gateway.thermostat.gateway.valve_driver import ValveDriver
-from ioc import Inject
+from gateway.models import Database, Pump, Valve, PumpToValveAssociation
+from gateway.valve_pump.pump_driver import PumpDriver
+from gateway.valve_pump.valve_driver import ValveDriver
+from ioc import INJECTED, Inject, Injectable, Singleton
 
 if False:  # MYPY
     from typing import List, Dict, Set
@@ -27,54 +27,69 @@ if False:  # MYPY
 logger = logging.getLogger(__name__)
 
 
-@Inject
-class PumpValveController(object):
-    def __init__(self):  # type: () -> None
+@Injectable.named('valve_pump_controller')
+class ValvePumpController(object):
+    def __init__(self, ):  # type: () -> None
+        # list of valves linked to this specific driver, which is linked to a thermostat:
         self._valve_drivers = {}  # type: Dict[int, ValveDriver]
         self._pump_drivers = {}  # type: Dict[int, PumpDriver]
         self._pump_drivers_per_valve = {}  # type: Dict[int, Set[PumpDriver]]
         self._config_change_lock = Lock()
 
-    def refresh_from_db(self):  # type: () -> None
+
+
+    def update_from_db(self):  # type: () -> None
         with self._config_change_lock, Database.get_session() as db:
+
             # Collect valve drivers
             current_ids = []
-            for item in db.query(Valve):
-                if item.id in self._valve_drivers:
-                    self._valve_drivers[item.id].update(item)
+            for valve in db.query(Valve):
+                if valve.id in self._valve_drivers:
+                    self._valve_drivers[valve.id].update(valve)
                 else:
-                    self._valve_drivers[item.id] = ValveDriver(item)
-                current_ids.append(item.id)
+                    self._valve_drivers[valve.id] = ValveDriver(valve)
+                current_ids.append(valve.id)
+
+            # remove valve drivers that are no longer needed
             for item_id in list(self._valve_drivers.keys()):
                 if item_id not in current_ids:
                     del self._valve_drivers[item_id]
+
             # Collect pump drivers
             current_ids = []
             pump_drivers_per_valve = {}  # type: Dict[int, Set[PumpDriver]]
-            for item in db.query(Pump):
-                if item.id in self._pump_drivers:
-                    pump_driver = self._pump_drivers[item.id]
-                    pump_driver.update(item)
+            for pump in db.query(Pump):
+                if pump.id in self._pump_drivers:
+                    pump_driver = self._pump_drivers[pump.id]
+                    pump_driver.update(pump)
                 else:
-                    pump_driver = PumpDriver(item)
-                    self._pump_drivers[item.id] = pump_driver
-                current_ids.append(item.id)
+                    pump_driver = PumpDriver(pump)
+                    self._pump_drivers[pump.id] = pump_driver
+                current_ids.append(pump.id)
                 for valve_id in pump_driver.valve_ids:
                     if valve_id not in pump_drivers_per_valve:
                         pump_drivers_per_valve[valve_id] = set()
                     pump_drivers_per_valve[valve_id].add(pump_driver)
+
+            # remove pump drivers that are no longer needed
             for item_id in list(self._pump_drivers.keys()):
                 if item_id not in current_ids:
                     del self._pump_drivers[item_id]
             self._pump_drivers_per_valve = pump_drivers_per_valve
 
+
+
+
     @staticmethod
     def _open_valves_cascade(total_percentage, valve_drivers):
         # type: (float, List[ValveDriver]) -> None
         n_valves = len(valve_drivers)
+        if n_valves == 0:
+            return
         percentage_per_valve = 100.0 / n_valves
         n_valves_fully_open = int(total_percentage / percentage_per_valve)
         last_valve_open_percentage = 100.0 * (total_percentage - n_valves_fully_open * percentage_per_valve) / percentage_per_valve
+
         for n in range(n_valves_fully_open):
             valve_driver = valve_drivers[n]
             valve_driver.set(100)
@@ -83,31 +98,58 @@ class PumpValveController(object):
             percentage = last_valve_open_percentage if n == n_valves_fully_open else 0
             valve_driver.set(percentage)
 
+
+
+
     @staticmethod
     def _open_valves_equal(percentage, valve_drivers):
         # type: (float, List[ValveDriver]) -> None
         for valve_driver in valve_drivers:
             valve_driver.set(percentage)
 
-    def set_valves(self, percentage, valve_ids, mode='cascade'):
-        # type: (float, List[int], str) -> None
-        if len(valve_ids) > 0:
-            valve_drivers = [self.get_valve_driver(valve_id) for valve_id in valve_ids]
-            if mode == 'cascade':
-                self._open_valves_cascade(percentage, valve_drivers)
-            else:
-                self._open_valves_equal(percentage, valve_drivers)
 
-    def steer(self):  # type: () -> None
+
+
+    def _set_valves(self, percentage, valve_ids, mode='equal'):  # type: (int, List[int], str) -> None
+        valve_drivers = [self.get_valve_driver(valve_id) for valve_id in valve_ids]
+        if mode == 'cascade':
+            self._open_valves_cascade(percentage, valve_drivers)
+        else:
+            self._open_valves_equal(percentage, valve_drivers)
+
+
+
+
+    def steer(self, percentage, valve_ids, mode='equal'):  # type: (int, List[int], str) -> None
+        self._set_valves(percentage, valve_ids, mode)
+        self.update_system()
+
+
+
+
+    def update_system(self):
         self._prepare_pumps_for_transition()
         self._steer_valves()
         self._steer_pumps()
 
+
+
+
+    def is_valve_open(self, valve_id, percentage):
+        if self._valve_drivers[valve_id].is_open(percentage=percentage) is True:
+            return True
+        return False
+
+
+
     def _prepare_pumps_for_transition(self):  # type: () -> None
         active_pump_drivers = set()
         potential_inactive_pump_drivers = set()
+
+        # loop over the valves
         for valve_id, valve_driver in self._valve_drivers.items():
-            if valve_driver.is_open:
+            # if valve is open, ior operation: create set with unique pump drivers for open valves
+            if valve_driver.is_open(percentage=10) is True:
                 active_pump_drivers |= self._pump_drivers_per_valve.get(valve_id, set())
             elif valve_driver.will_close:
                 potential_inactive_pump_drivers |= self._pump_drivers_per_valve.get(valve_id, set())
@@ -116,15 +158,21 @@ class PumpValveController(object):
         for pump_driver in inactive_pump_drivers:
             pump_driver.turn_off()
 
+
+
+
     def _steer_valves(self):  # type: () -> None
         for valve_driver in self._valve_drivers.values():
             valve_driver.steer_output()
 
+
+
+
     def _steer_pumps(self):  # type: () -> None
         active_pump_drivers = set()
         potential_inactive_pump_drivers = set()
         for valve_id, valve_driver in self._valve_drivers.items():
-            if valve_driver.is_open:
+            if valve_driver.is_open(percentage=10) is True:
                 active_pump_drivers |= self._pump_drivers_per_valve.get(valve_id, set())
             else:
                 potential_inactive_pump_drivers |= self._pump_drivers_per_valve.get(valve_id, set())
@@ -135,6 +183,9 @@ class PumpValveController(object):
         for pump_driver in active_pump_drivers:
             pump_driver.turn_on()
 
+
+
+
     def get_valve_driver(self, valve_id):  # type: (int) -> ValveDriver
         valve_driver = self._valve_drivers.get(valve_id)
         if valve_driver is None:
diff --git a/src/gateway/valve_pump/valve_pump_driver.py b/src/gateway/valve_pump/valve_pump_driver.py
new file mode 100644
index 00000000..38ac8828
--- /dev/null
+++ b/src/gateway/valve_pump/valve_pump_driver.py
@@ -0,0 +1,48 @@
+
+
+import logging
+from ioc import INJECTED, Inject
+from gateway.models import Database, IndoorLinkValves
+from gateway.valve_pump.valve_pump_controller import ValvePumpController
+
+if False:  # MYPY
+    from typing import Any, Dict, List, Optional, Union
+    from logging import Logger
+
+
+@Inject
+class ValvePumpDriver(object):  
+    def __init__(self, indoor_link_id, mode, valve_pump_controller=INJECTED):  # type: (int, str, ValvePumpController) -> None
+        self._link_id = indoor_link_id
+        self._valve_pump_controller = valve_pump_controller
+        self._valve_ids = []  # type: List[int]
+        self._mode = mode  # temporary include mode
+
+
+
+    def steer(self, percentage):  # type: (int) -> None
+        self._valve_pump_controller.steer(percentage=percentage, valve_ids=self._valve_ids)
+
+
+
+    @property
+    def is_ready(self): # type: () -> bool
+        # return true if any valve of this cluster is open
+        for valve_id in self._valve_ids:
+            if self._valve_pump_controller.is_valve_open(valve_id=valve_id, percentage=10) is True:
+                return True
+        return False
+
+
+
+    def update_from_db(self):  # type: () -> None
+        # update controller from database
+        self._valve_pump_controller.update_from_db()
+        
+        # fetch links between valves and indoor units
+        with Database.get_session() as db:
+            indoor_link_valves = db.query(IndoorLinkValves).filter_by(thermostat_link_id=self._link_id).filter_by(mode=self._mode).all()
+            valve_ids = []
+            for indoor_link_valve in indoor_link_valves:
+                valve_ids.append(indoor_link_valve.valve_id)
+            self._valve_ids = valve_ids
diff --git a/src/gateway/ventilation_controller.py b/src/gateway/ventilation_controller.py
index b11006ac..efc37b38 100644
--- a/src/gateway/ventilation_controller.py
+++ b/src/gateway/ventilation_controller.py
@@ -18,13 +18,13 @@ Ventilation BLL
 from __future__ import absolute_import
 
 import logging
-import time
 
 from sqlalchemy import select
 
 from gateway.daemon_thread import DaemonThread
-from gateway.dto import VentilationDTO, VentilationSourceDTO, \
-    VentilationStatusDTO
+from gateway.dto import VentilationDTO, \
+    VentilationStatusDTO, PluginVentilationDTO, SourceDTO
+from gateway.enums import VentilationEnums, Source
 from gateway.events import GatewayEvent
 from gateway.mappers import VentilationMapper
 from gateway.models import Database, Plugin, Ventilation
@@ -33,6 +33,7 @@ from ioc import INJECTED, Inject, Injectable, Singleton
 
 if False:  # MYPY
     from typing import Any, Dict, List, Optional
+    from plugins.base import PluginController
 
 logger = logging.getLogger(__name__)
 
@@ -41,19 +42,22 @@ logger = logging.getLogger(__name__)
 @Singleton
 class VentilationController(object):
     @Inject
-    def __init__(self, pubsub=INJECTED):
-        # type: (PubSub) -> None
+    def __init__(self, pubsub=INJECTED, plugin_controller=INJECTED):
+        # type: (PubSub, PluginController) -> None
         self._pubsub = pubsub
+        self._plugin_controller = plugin_controller
         self._status = {}  # type: Dict[int, VentilationStatusDTO]
+
         self.check_connected_runner = DaemonThread('check_connected_thread',
                                                    self._check_connected_timeout,
                                                    interval=30,
                                                    delay=15)
-
         self.periodic_event_update_runner = DaemonThread('periodic_update',
-                                                   self._periodic_event_update,
-                                                   interval=900,
-                                                   delay=90)
+                                                         self._periodic_event_update,
+                                                         interval=900,
+                                                         delay=90)
+
+        self._plugin_controller.ventilation_callback_action = self._plugin_ventilation_callback_action
 
     def start(self):
         # type: () -> None
@@ -66,32 +70,34 @@ class VentilationController(object):
         self.check_connected_runner.stop()
         self.periodic_event_update_runner.stop()
 
+    @staticmethod
+    def _get_source_from_ventilation(ventilation):  # type: (Ventilation) -> SourceDTO
+        source = SourceDTO(source=ventilation.source)
+        if ventilation.source == Source.PLUGIN:
+            source.source_id = ventilation.plugin_id
+        return source
+
+    @staticmethod
+    def _get_ventilation_from_source(db, source, external_id):  # type (Session, SourceDTO, str) -> Ventilation
+        lookup_kwargs = {'source': source.source,
+                         'external_id': external_id}
+        if source.source == Source.PLUGIN:
+            lookup_kwargs['plugin_id'] = source.source_id
+        return db.query(Ventilation).filter_by(**lookup_kwargs).one_or_none()
+
     def _publish_config(self):
         # type: () -> None
         gateway_event = GatewayEvent(GatewayEvent.Types.CONFIG_CHANGE, {'type': 'ventilation'})
         self._pubsub.publish_gateway_event(PubSub.GatewayTopics.CONFIG, gateway_event)
 
-    def _save_status_cache(self, state_dto):
-        if self._status.get(state_dto.id) is not None and \
-                not (state_dto.timer is None and state_dto.remaining_time is None):
-            if state_dto.timer is None:
-                state_dto.timer = self._status[state_dto.id].timer
-            if state_dto.remaining_time is None:
-                state_dto.remaining_time = self._status[state_dto.id].remaining_time
-        self._status[state_dto.id] = state_dto
-        return state_dto
-
-    def _publish_state(self, state_dto):
+    def _publish_state(self, status_dto):
         # type: (VentilationStatusDTO) -> None
-        # if the timer or remaining time is set, the other value will not be set,
-        # so cache the previous value so it does not get lost
-        state_dto = self._save_status_cache(state_dto)
-        event_data = {'id': state_dto.id,
-                      'mode': state_dto.mode,
-                      'level': state_dto.level,
-                      'timer': state_dto.timer,
-                      'remaining_time': state_dto.remaining_time,
-                      'is_connected': state_dto.is_connected}
+        self._status[status_dto.id] = status_dto
+        event_data = {'id': status_dto.id,
+                      'mode': status_dto.mode,
+                      'level': status_dto.level,
+                      'remaining_time': status_dto.remaining_time,
+                      'is_connected': status_dto.is_connected}
         gateway_event = GatewayEvent(GatewayEvent.Types.VENTILATION_CHANGE, event_data)
         self._pubsub.publish_gateway_event(PubSub.GatewayTopics.STATE, gateway_event)
 
@@ -109,7 +115,6 @@ class VentilationController(object):
                 ventilation_status_dto.mode = None
                 ventilation_status_dto.level = None
                 ventilation_status_dto.remaining_time = None
-                ventilation_status_dto.timer = None
                 # also update the instance in the dict
                 self._status[ventilation_id] = ventilation_status_dto
                 # timeout has passed, send a disconnect event with all relevant fields as None.
@@ -141,32 +146,60 @@ class VentilationController(object):
             self._publish_config()
         return ventilation_dto
 
-    def register_ventilation(self, source_dto, external_id, default_config=None):
-        # type: (VentilationSourceDTO, str, Optional[Dict[str, Any]]) -> VentilationDTO
-        default_config = default_config or {}
-        with Database.get_session() as db:
-            if source_dto.type == 'plugin':
-                plugin = db.query(Plugin).filter_by(name=source_dto.name).one()  # type: Plugin
-                lookup_kwargs = {'source': source_dto.type, 'plugin': plugin, 'external_id': external_id}
-            else:
-                raise ValueError('Can\'t register Ventilation with source {}'.format(source_dto.type))
-            ventilation = db.query(Ventilation).filter_by(**lookup_kwargs).one_or_none()  # type: Optional[Ventilation]
-            if ventilation is None:
-                ventilation = Ventilation(**lookup_kwargs)
-                for field in ('name',):
-                    setattr(ventilation, field, default_config.get(field, ''))
-                db.add(ventilation)
-            for field in ('amount_of_levels',):
-                setattr(ventilation, field, default_config.get(field, 0))
-            for field in ('device_vendor', 'device_type', 'device_serial'):
-                if field in default_config:
-                    setattr(ventilation, field, default_config.get(field, ''))
-            changed = ventilation in db.dirty
-            db.commit()
-            ventilation_dto = self.load_ventilation(ventilation.id)
-        if changed:
-            self._publish_config()
-        return ventilation_dto
+    def _plugin_ventilation_callback_action(self, source, action, action_payload):
+        # type: (SourceDTO, str, Any) -> Any
+        if action == VentilationEnums.CallbackAction.REGISTER:
+            with Database.get_session() as db:
+                if not isinstance(action_payload, PluginVentilationDTO):
+                    raise ValueError('Unexpected payload format')
+                if action_payload.external_id is None:
+                    raise ValueError('An external ID is mandatory for registration')
+                ventilation = VentilationController._get_ventilation_from_source(db=db,
+                                                                                 source=source,
+                                                                                 external_id=action_payload.external_id)
+                if ventilation is None:
+                    plugin = db.query(Plugin).where(Plugin.id == source.source_id).one()
+                    ventilation = Ventilation(name=action_payload.name,
+                                              amount_of_levels=action_payload.amount_of_levels,
+                                              device_type=action_payload.device_type,
+                                              device_serial=action_payload.device_serial,
+                                              device_vendor=action_payload.device_vendor,
+                                              source=Source.PLUGIN,
+                                              external_id=action_payload.external_id,
+                                              plugin=plugin)
+                    db.add(ventilation)
+                else:
+                    ventilation.amount_of_levels = action_payload.amount_of_levels
+                    ventilation.device_type = action_payload.device_type
+                    ventilation.device_serial = action_payload.device_serial
+                    ventilation.device_vendor = action_payload.device_vendor
+                changed = ventilation in db.dirty
+                db.commit()
+                if changed:
+                    self._publish_config()
+                return PluginVentilationDTO(id=ventilation.id,
+                                            external_id=ventilation.external_id,
+                                            name=ventilation.name,
+                                            amount_of_levels=ventilation.amount_of_levels,
+                                            device_type=ventilation.device_type,
+                                            device_serial=ventilation.device_serial,
+                                            device_vendor=ventilation.device_vendor)
+        if action == VentilationEnums.CallbackAction.REPORT_STATUS:
+            with Database.get_session() as db:
+                if not isinstance(action_payload, dict):
+                    raise ValueError('Unexpected payload format')
+                if action_payload.get('external_id') is None:
+                    raise ValueError('An external ID is mandatory for reporting state')
+                ventilation = VentilationController._get_ventilation_from_source(db=db,
+                                                                                 source=source,
+                                                                                 external_id=action_payload['external_id'])
+                if ventilation is None:
+                    raise RuntimeError('Ventilation does not exist')
+                self._report_status(VentilationStatusDTO(id=ventilation.id,
+                                                         mode=action_payload['mode'],
+                                                         level=action_payload['level'],
+                                                         remaining_time=action_payload['remaining_time'],
+                                                         last_seen=action_payload['last_seen']))
 
     def get_status(self):
         # type: () -> List[VentilationStatusDTO]
@@ -174,42 +207,46 @@ class VentilationController(object):
         with Database.get_session() as db:
             stmt = select(Ventilation.id)  # type: ignore
             for ventilation_id in db.execute(stmt).scalars():
-                state_dto = self._status.get(ventilation_id)
-                if state_dto:
-                    status.append(state_dto)
+                status_dto = self._status.get(ventilation_id)
+                if status_dto:
+                    status.append(status_dto)
         return status
 
-    def set_status(self, status_dto):
+    def _report_status(self, status_dto):
         # type: (VentilationStatusDTO) -> VentilationStatusDTO
         ventilation_dto = self.load_ventilation(status_dto.id)
-        self._validate_state(ventilation_dto, status_dto)
+        if status_dto.level:
+            if status_dto.mode == VentilationStatusDTO.Mode.AUTO:
+                raise ValueError('Ventilation mode {0} does not support level'.format(status_dto.mode))
+            if not (0 <= status_dto.level <= ventilation_dto.amount_of_levels):
+                raise ValueError('Ventilation level {0} should be an integer of 0 <= level <= {1}'.format(
+                    status_dto.level, ventilation_dto.amount_of_levels
+                ))
         if not(status_dto == self._status.get(status_dto.id)):
             self._publish_state(status_dto)
-        self._save_status_cache(status_dto)
+        self._status[status_dto.id] = status_dto
         return status_dto
 
     def set_mode_auto(self, ventilation_id):
         # type: (int) -> None
-        _ = self.load_ventilation(ventilation_id)
-        status_dto = VentilationStatusDTO(ventilation_id, mode=VentilationStatusDTO.Mode.AUTO)
-        if not (status_dto == self._status.get(ventilation_id)):
-            self._save_status_cache(status_dto)
-            self._publish_state(status_dto)
+        with Database.get_session() as db:
+            ventilation = db.query(Ventilation).filter_by(id=ventilation_id).one()
+            source = VentilationController._get_source_from_ventilation(ventilation=ventilation)
+        if not source.is_plugin:
+            raise RuntimeError('Only plugin driven ventilation is supported')
+        self._plugin_controller.execute_ventilation_action(action=VentilationEnums.Action.SET_AUTO,
+                                                           action_payload={'external_id': ventilation.external_id},
+                                                           destination=source)
 
     def set_level(self, ventilation_id, level, timer=None):
         # type: (int, int, Optional[float]) -> None
-        ventilation_dto = self.load_ventilation(ventilation_id)
-        status_dto = VentilationStatusDTO(ventilation_id, mode=VentilationStatusDTO.Mode.MANUAL, level=level, timer=timer)
-        self._validate_state(ventilation_dto, status_dto)
-        if not (status_dto == self._status.get(ventilation_id)):
-            self._save_status_cache(status_dto)
-            self._publish_state(status_dto)
-
-    def _validate_state(self, ventilation_dto, status_dto):
-        # type: (VentilationDTO, VentilationStatusDTO) -> None
-        if status_dto.level:
-            if status_dto.mode == VentilationStatusDTO.Mode.AUTO:
-                raise ValueError('ventilation mode {} does not support level'.format(status_dto.level))
-            if status_dto.level < 0 or status_dto.level > ventilation_dto.amount_of_levels:
-                values = list(range(ventilation_dto.amount_of_levels + 1))
-                raise ValueError('ventilation level {0} not in {1}'.format(status_dto.level, values))
+        with Database.get_session() as db:
+            ventilation = db.query(Ventilation).filter_by(id=ventilation_id).one()
+            source = VentilationController._get_source_from_ventilation(ventilation=ventilation)
+        if not source.is_plugin:
+            raise RuntimeError('Only plugin drive ventilation is supported')
+        self._plugin_controller.execute_ventilation_action(action=VentilationEnums.Action.SET_MANUAL,
+                                                           action_payload={'external_id': ventilation.external_id,
+                                                                           'level': level,
+                                                                           'timer': timer},
+                                                           destination=source)
diff --git a/src/gateway/watchdog.py b/src/gateway/watchdog.py
index 95800bbf..d6325f67 100644
--- a/src/gateway/watchdog.py
+++ b/src/gateway/watchdog.py
@@ -34,7 +34,7 @@ if False:  # MYPY
     from typing import Callable, Literal, Optional, Union, Dict, Any
     from gateway.hal.master_controller import MasterController
     from gateway.energy.energy_communicator import EnergyCommunicator
-    from gateway.update_controller import UpdateController
+    from gateway.updates.update_controller import UpdateController
 
     HEALTH = Literal['success', 'unstable', 'failure']
 
diff --git a/src/gateway/webservice.py b/src/gateway/webservice.py
index f0a87b40..2bedacb9 100644
--- a/src/gateway/webservice.py
+++ b/src/gateway/webservice.py
@@ -24,31 +24,31 @@ import platform
 import sys
 import time
 import uuid
+
 import cherrypy
 import requests
 import six
 import ujson as json
 from cherrypy.lib.static import serve_file
-from cloud.events import EventSender
 from decorator import decorator
-from sqlalchemy.orm.exc import NoResultFound
 from six.moves.urllib.parse import unquote_plus
+from sqlalchemy.orm.exc import NoResultFound
 
 import constants
 import gateway
 from gateway.api.serializers import DimmerConfigurationSerializer, \
-    EnergyModuleSerializer, GlobalFeedbackSerializer, GlobalRTD10Serializer, \
-    GroupActionSerializer, InputSerializer, InputStateSerializer, \
+    EnergyModuleSerializer, GlobalFeedbackSerializer, GroupActionSerializer, \
+    InputSerializer, InputStateSerializer, \
     LegacyThermostatGroupStatusSerializer, ModuleSerializer, \
     OutputSerializer, OutputStateSerializer, PulseCounterSerializer, \
-    PumpGroupSerializer, RoomSerializer, RTD10Serializer, ScheduleSerializer, \
+    PumpGroupSerializer, RoomSerializer, ScheduleSerializer, \
     SensorSerializer, SensorStatusSerializer, ShutterGroupSerializer, \
-    ShutterSerializer, ThermostatAircoStatusSerializer, \
-    ThermostatGroupSerializer, ThermostatGroupStatusSerializer, \
-    ThermostatSerializer, VentilationSerializer, VentilationStatusSerializer
+    ShutterSerializer, ThermostatGroupSerializer, \
+    ThermostatGroupStatusSerializer, ThermostatSerializer, \
+    VentilationSerializer, VentilationStatusSerializer
 from gateway.authentication_controller import AuthenticationToken
-from gateway.dto import GlobalRTD10DTO, InputStatusDTO, PumpGroupDTO, \
-    RoomDTO, ScheduleDTO, UserDTO
+from gateway.dto import InputStatusDTO, PumpGroupDTO, RoomDTO, ScheduleDTO, \
+    UserDTO
 from gateway.energy.energy_communicator import InAddressModeException
 from gateway.enums import ModuleType, ShutterEnums, UpdateEnums, UserEnums
 from gateway.events import BaseEvent, GatewayEvent
@@ -60,7 +60,7 @@ from gateway.mappers.thermostat import ThermostatMapper
 from gateway.models import Config, Database, Feature, Module, Schedule, User
 from gateway.thermostat.thermostat_controller import ThermostatController
 from gateway.uart_controller import UARTController
-from gateway.update_controller import UpdateController
+from gateway.updates.update_controller import UpdateController
 from gateway.websockets import EventsSocket, MaintenanceSocket, \
     MetricsSocket, OMPlugin, OMSocketTool, WebSocketEncoding
 from ioc import INJECTED, Inject, Injectable, Singleton
@@ -69,6 +69,8 @@ from platform_utils import Hardware, Platform, System
 from serial_utils import CommunicationTimedOutException
 from toolbox import Toolbox
 
+from cloud.events import EventSender
+
 if False:  # MYPY
     from typing import Dict, Optional, Any, List, Literal, Union
     from bus.om_bus_client import MessageClient
@@ -79,6 +81,7 @@ if False:  # MYPY
     from gateway.maintenance_controller import MaintenanceController
     from gateway.metrics_collector import MetricsCollector
     from gateway.metrics_controller import MetricsController
+    from gateway.hvac_controller import HvacController
     from gateway.module_controller import ModuleController
     from gateway.output_controller import OutputController
     from gateway.pulse_counter_controller import PulseCounterController
@@ -367,6 +370,7 @@ def openmotics_api(auth=False, check=None, pass_token=False, pass_role=False,
         if auth is True:
             func = cherrypy.tools.authenticated(pass_token=pass_token, pass_role=pass_role, version=version)(func)
         func = cherrypy.tools.params(**(check or {}))(func)
+        func = cherrypy.tools.cors()(func)
         func = log_access(func, mask)
         func.exposed = True
         func.plugin_exposed = plugin_exposed
@@ -386,7 +390,7 @@ class WebInterface(object):
 
     @Inject
     def __init__(self, user_controller=INJECTED, maintenance_controller=INJECTED,
-                 message_client=INJECTED, scheduling_controller=INJECTED,
+                 message_client=INJECTED, scheduling_controller=INJECTED, hvac_controller=INJECTED,
                  thermostat_controller=INJECTED, shutter_controller=INJECTED, output_controller=INJECTED,
                  room_controller=INJECTED, input_controller=INJECTED, sensor_controller=INJECTED,
                  pulse_counter_controller=INJECTED, group_action_controller=INJECTED,
@@ -399,6 +403,7 @@ class WebInterface(object):
         self._user_controller = user_controller  # type: UserController
         self._scheduling_controller = scheduling_controller  # type: SchedulingController
         self._thermostat_controller = thermostat_controller  # type: ThermostatController
+        self._hvac_controller = hvac_controller  # type: HvacController
         self._shutter_controller = shutter_controller  # type: ShutterController
         self._output_controller = output_controller  # type: OutputController
         self._room_controller = room_controller  # type: RoomController
@@ -775,7 +780,8 @@ class WebInterface(object):
                 'operating_system': System.get_operating_system().get('ID', 'unknown'),
                 'hardware': Hardware.get_board_type(),
                 'hardware_serial': Hardware.get_board_serial_number(),
-                'mac_address': Hardware.get_mac_address()}
+                'mac_address': Hardware.get_mac_address(),
+                'master_serial': self._system_controller.get_master_serial_number()}
 
     @openmotics_api(auth=True, check=types(type=int, id=int))
     def flash_leds(self, type, id):  # type: (int, int) -> Dict[str, str]
@@ -1115,18 +1121,6 @@ class WebInterface(object):
                                                    temperature=temperature)
         return {'status': 'OK'}
 
-    @openmotics_api(auth=True)
-    def get_airco_status(self):
-        """ Get the mode of the airco attached to a all thermostats. """
-        airco_status_dto = self._thermostat_controller.load_airco_status()
-        return ThermostatAircoStatusSerializer.serialize(airco_status_dto)
-
-    @openmotics_api(auth=True, check=types(thermostat_id=int, airco_on=bool))
-    def set_airco_status(self, thermostat_id, airco_on):
-        """ Set the mode of the airco attached to a given thermostat. """
-        self._thermostat_controller.set_airco_status(thermostat_id, airco_on)
-        return {'status': 'OK'}
-
     # Ventilation
 
     # methods=['GET']
@@ -1160,18 +1154,6 @@ class WebInterface(object):
         return {'status': [VentilationStatusSerializer.serialize(status_dto, fields)
                            for status_dto in status]}
 
-    # methods=['PUT']
-    @openmotics_api(auth=True, check=types(status='json'))
-    def set_ventilation_status(self, status):
-        # type: (Dict[str,Any]) -> Dict[str, Any]
-        """
-        Update the current ventilation status, used by plugins to report the current
-        status of devices.
-        """
-        status_dto = VentilationStatusSerializer.deserialize(status)
-        status_dto = self._ventilation_controller.set_status(status_dto)
-        return {'status': VentilationStatusSerializer.serialize(status_dto, fields=None)}
-
     # methods=['POST']
     @openmotics_api(auth=True, check=types(ventilation_id=int))
     def set_ventilation_mode_auto(self, ventilation_id):
@@ -1186,6 +1168,8 @@ class WebInterface(object):
         self._ventilation_controller.set_level(ventilation_id, level, timer)
         return {}
 
+    # Sensors
+
     # methods=['GET']
     @openmotics_api(auth=True)
     def get_sensor_status(self, fields=None):
@@ -1307,6 +1291,7 @@ class WebInterface(object):
             eeprom_extensions.db as a string of bytes.
         :rtype: dict
         """
+        cherrypy.response.stream = True
         cherrypy.response.headers['Content-Type'] = 'application/octet-stream'
         return self._system_controller.get_full_backup()
 
@@ -1321,7 +1306,7 @@ class WebInterface(object):
         :returns: dict with 'output' key.
         :rtype: dict
         """
-        data = backup_data.file.read()
+        data = bytearray(backup_data.file.read())
         if not data:
             raise RuntimeError('backup_data is empty')
         return self._system_controller.restore_full_backup(data)
@@ -1336,6 +1321,7 @@ class WebInterface(object):
             returns a string of bytes (size = 64kb).
         :rtype: bytearray
         """
+        cherrypy.response.stream = True
         cherrypy.response.headers['Content-Type'] = 'application/octet-stream'
         return self._module_controller.get_master_backup()
 
@@ -1772,95 +1758,6 @@ class WebInterface(object):
         self._thermostat_controller.save_cooling_pump_groups(data)
         return {}
 
-    @openmotics_api(auth=True, check=types(fields='json'))
-    def get_global_rtd10_configuration(self, fields=None):  # type: (Optional[List[str]]) -> Dict[str, Any]
-        """
-        Get the global_rtd10_configuration.
-        :param fields: The field of the global_rtd10_configuration to get, None if all
-        """
-        try:
-            global_rtd10_dto = self._thermostat_controller.load_global_rtd10()
-        except UnsupportedException:
-            global_rtd10_dto = GlobalRTD10DTO()  # Backwards compatibility
-        return {'config': GlobalRTD10Serializer.serialize(global_rtd10_dto=global_rtd10_dto, fields=fields)}
-
-    @openmotics_api(auth=True, check=types(config='json'))
-    def set_global_rtd10_configuration(self, config):  # type: (Dict[Any, Any]) -> Dict
-        """ Set the global_rtd10_configuration. """
-        data = GlobalRTD10Serializer.deserialize(config)
-        self._thermostat_controller.save_global_rtd10(data)
-        return {}
-
-    @openmotics_api(auth=True, check=types(id=int, fields='json'))
-    def get_rtd10_heating_configuration(self, id, fields=None):  # type: (int, Optional[List[str]]) -> Dict[str, Any]
-        """
-        Get a specific rtd10_heating_configuration defined by its id.
-        :param fields: The field of the rtd10_heating_configuration to get, None if all
-        """
-        return {'config': RTD10Serializer.serialize(rtd10_dto=self._thermostat_controller.load_heating_rtd10(id),
-                                                    fields=fields)}
-
-    @openmotics_api(auth=True, check=types(fields='json'))
-    def get_rtd10_heating_configurations(self, fields=None):  # type: (Optional[List[str]]) -> Dict[str, Any]
-        """
-        Get all rtd10_heating_configurations.
-        :param fields: The field of the rtd10_heating_configuration to get, None if all
-        """
-        try:
-            return {'config': [RTD10Serializer.serialize(rtd10_dto=rtd10_dto, fields=fields)
-                               for rtd10_dto in self._thermostat_controller.load_heating_rtd10s()]}
-        except UnsupportedException:
-            return {'config': []}  # Backwards compatibility
-
-    @openmotics_api(auth=True, check=types(config='json'))
-    def set_rtd10_heating_configuration(self, config):  # type: (Dict[Any, Any]) -> Dict
-        """ Set one rtd10_heating_configuration. """
-        data = RTD10Serializer.deserialize(config)
-        self._thermostat_controller.save_heating_rtd10s([data])
-        return {}
-
-    @openmotics_api(auth=True, check=types(config='json'))
-    def set_rtd10_heating_configurations(self, config):  # type: (List[Dict[Any, Any]]) -> Dict
-        """ Set multiple rtd10_heating_configurations. """
-        data = [RTD10Serializer.deserialize(entry) for entry in config]
-        self._thermostat_controller.save_heating_rtd10s(data)
-        return {}
-
-    @openmotics_api(auth=True, check=types(id=int, fields='json'))
-    def get_rtd10_cooling_configuration(self, id, fields=None):  # type: (int, Optional[List[str]]) -> Dict[str, Any]
-        """
-        Get a specific rtd10_cooling_configuration defined by its id.
-        :param fields: The field of the rtd10_cooling_configuration to get, None if all
-        """
-        return {'config': RTD10Serializer.serialize(rtd10_dto=self._thermostat_controller.load_cooling_rtd10(id),
-                                                    fields=fields)}
-
-    @openmotics_api(auth=True, check=types(fields='json'))
-    def get_rtd10_cooling_configurations(self, fields=None):  # type: (Optional[List[str]]) -> Dict[str, Any]
-        """
-        Get all rtd10_cooling_configurations.
-        :param fields: The field of the rtd10_cooling_configuration to get, None if all
-        """
-        try:
-            return {'config': [RTD10Serializer.serialize(rtd10_dto=rtd10_dto, fields=fields)
-                               for rtd10_dto in self._thermostat_controller.load_cooling_rtd10s()]}
-        except UnsupportedException:
-            return {'config': []}  # Backwards compatibility
-
-    @openmotics_api(auth=True, check=types(config='json'))
-    def set_rtd10_cooling_configuration(self, config):  # type: (Dict[Any, Any]) -> Dict
-        """ Set one rtd10_cooling_configuration. """
-        data = RTD10Serializer.deserialize(config)
-        self._thermostat_controller.save_cooling_rtd10s([data])
-        return {}
-
-    @openmotics_api(auth=True, check=types(config='json'))
-    def set_rtd10_cooling_configurations(self, config):  # type: (List[Dict[Any, Any]]) -> Dict
-        """ Set multiple rtd10_cooling_configurations. """
-        data = [RTD10Serializer.deserialize(entry) for entry in config]
-        self._thermostat_controller.save_cooling_rtd10s(data)
-        return {}
-
     # Group Actions
 
     @openmotics_api(auth=True, check=types(id=int, fields='json'))
@@ -2323,6 +2220,7 @@ class WebInterface(object):
         :rtype: dict
         """
         return {'output': '',
+                'logs': self._system_controller.get_update_logs(),
                 'version': gateway.__version__}
 
     @openmotics_api(auth=True, plugin_exposed=False, check=types(module_type=str, firmware_version=str, module_address=str, force=bool))
@@ -2461,7 +2359,7 @@ class WebInterface(object):
         ret = [{'name': p.name,
                 'version': p.version,
                 'interfaces': p.interfaces,
-                'status': 'RUNNING' if p.is_running() else 'STOPPED'} for p in plugins]
+                'status':  p.status} for p in plugins]
         return {'plugins': ret}
 
     @openmotics_api(auth=True, plugin_exposed=False)
@@ -2496,7 +2394,8 @@ class WebInterface(object):
         :param name: Name of the plugin to remove.
         :type name: str
         """
-        return self._plugin_controller.remove_plugin(name)
+        self._plugin_controller.remove_plugin(name)
+        return {'msg': 'Plugin successfully removed'}
 
     @openmotics_api(auth=True, plugin_exposed=False)
     def stop_plugin(self, name):
@@ -2763,26 +2662,9 @@ class WebService(object):
         logger.info('Stopping webserver... Done')
 
     def update_tree(self, mounts):
-        try:
-            self._http_server.stop()
-        except Exception as ex:
-            logger.error('Could not stop non-secure webserver: {0}'.format(ex))
-        try:
-            self._https_server.stop()
-        except Exception as ex:
-            logger.error('Could not stop secure webserver: {0}'.format(ex))
+        logger.info('Updating webservice tree')
         try:
             for mount in mounts:
                 cherrypy.tree.mount(**mount)
         except Exception as ex:
             logger.error('Could not mount updated tree: {0}'.format(ex))
-        try:
-            self._http_server.start()
-            self._http_server.httpserver.error_log = WebService._http_server_logger
-        except Exception as ex:
-            logger.error('Could not restart non-secure webserver: {0}'.format(ex))
-        try:
-            self._https_server.start()
-            self._https_server.httpserver.error_log = WebService._http_server_logger
-        except Exception as ex:
-            logger.error('Could not restart secure webserver: {0}'.format(ex))
diff --git a/src/logs.py b/src/logs.py
index 0506bd5c..183c55cc 100644
--- a/src/logs.py
+++ b/src/logs.py
@@ -15,7 +15,7 @@
 
 import logging
 import sys
-from logging import handlers
+from logging import handlers, Handler
 import os
 import re
 import constants
@@ -29,6 +29,23 @@ if False:  # MYPY
 global_logger = logging.getLogger(__name__)
 
 
+class FunctionLogHandler(Handler):
+    def __init__(self, log_function):
+        super(FunctionLogHandler, self).__init__()
+        self.log_function = log_function
+
+    def emit(self, record):
+        try:
+            message = self.format(record)
+            self.log_function(message=message,
+                              level=record.levelno)
+            self.flush()
+        except (KeyboardInterrupt, SystemExit):
+            raise
+        except:
+            pass  # Not much can be done here
+
+
 class Logs(object):
 
     LOG_FORMAT = "%(asctime)s - %(levelname)-8s - (%(threadName)s) - %(name)s - %(message)s"
@@ -75,15 +92,15 @@ class Logs(object):
         access_logger.propagate = False
 
     @staticmethod
-    def get_update_logger(name):  # type: (str) -> Logger
+    def get_update_logger(name, prefix='update'):  # type: (str, str) -> Logger
         """
         Sets up a logger for update logging;
-        * Logs to `{OPENMOTICS_PREFIX}/update/logs/{name}.log`
+        * Logs to `{OPENMOTICS_PREFIX}/update_logs/{name}.log`
         * Namespace is `update.{name}`
         """
         if not os.path.exists(Logs.UPDATE_LOGS_FOLDER):
             os.makedirs(Logs.UPDATE_LOGS_FOLDER)
-        namespace = 'update.{0}'.format(name)
+        namespace = '{0}.{1}'.format(prefix, name)
         filename = os.path.join(Logs.UPDATE_LOGS_FOLDER, '{0}.log'.format(name))
         update_handler = handlers.RotatingFileHandler(filename, maxBytes=3 * 1024 ** 2, backupCount=2)
         update_handler.setFormatter(logging.Formatter(Logs.LOG_FORMAT))
@@ -141,3 +158,22 @@ class Logs(object):
             return logging._checkLevel(log_level) if log_level else fallback  # type: ignore
         except (NoOptionError, NoSectionError):
             return fallback
+
+    @staticmethod
+    def setup_log_function_logger(logger, log_function):
+        formatter = logging.Formatter('%(message)s')
+        handler = FunctionLogHandler(log_function=log_function)
+        handler.setFormatter(formatter)
+        handler.setLevel(logging.INFO)
+        logger.setLevel(logging.INFO)
+        logger.addHandler(handler)
+
+    @staticmethod
+    def setup_plugin_runtime_logging(log_function):
+        root_logger = logging.getLogger()
+        while root_logger.handlers:
+            root_logger.removeHandler(root_logger.handlers[0])
+        Logs.setup_log_function_logger(logger=root_logger,
+                                       log_function=log_function)
+
+
diff --git a/src/master/core/core_api.py b/src/master/core/core_api.py
index 6f192b20..2f907c33 100644
--- a/src/master/core/core_api.py
+++ b/src/master/core/core_api.py
@@ -20,7 +20,7 @@ from __future__ import absolute_import
 from master.core.core_command import CoreCommandSpec
 from master.core.fields import (ByteField, WordField, ByteArrayField, WordArrayField, LiteralBytesField,
                                 AddressField, CharField, PaddingField, VersionField, TemperatureArrayField,
-                                HumidityArrayField, RawByteArrayField, SerialNumberField, Field, UInt32Field)
+                                HumidityArrayField, RawByteArrayField, SerialNumberField, Field, UInt32Field, TemperatureField, HumidityField)
 
 
 class CoreAPI(object):
@@ -92,6 +92,13 @@ class CoreAPI(object):
                                request_fields=[LiteralBytesField(1)],
                                response_fields=[ByteField('type'), ByteArrayField('information', lambda length: length - 1)])
 
+    @staticmethod
+    def device_information_list_serial_number():  # type: () -> CoreCommandSpec
+        """ Device information list for inputs """
+        return CoreCommandSpec(instruction='DL',
+                               request_fields=[LiteralBytesField(2)],
+                               response_fields=[ByteArrayField('serial_number', 7), ByteField('production_test_result')])
+
     @staticmethod
     def general_configuration_max_specs():  # type: () -> CoreCommandSpec
         """ Receives general configuration regarding maximum specifications (e.g. max number of input modules, max number of basic actions, ...) """
@@ -213,6 +220,22 @@ class CoreAPI(object):
                                                 UInt32Field('counter_4'), UInt32Field('counter_5'), UInt32Field('counter_6'), UInt32Field('counter_7'),
                                                 WordField('crc16')])
 
+    # HVAC setpoints
+    @staticmethod
+    def write_hvac_setpoint():  # type: () -> CoreCommandSpec
+        """ write a setpoint on the HVAC module of a given sensor """
+        return CoreCommandSpec(instruction='tW',
+                               request_fields=[ByteField('sensornr'), TemperatureField('setpoint'), ByteField('mode')],
+                               response_fields=[ByteField('sensornr'), TemperatureField('setpoint'), ByteField('mode')])
+
+
+    @staticmethod
+    def read_hvac_setpoint():
+        """ read a setpoint on the HVAC module of a given sensor """
+        return CoreCommandSpec(instruction="tR",
+                                request_fields=[ByteField('sensornr')],
+                                response_fields=[ByteField('sensornr'), TemperatureField('setpoint'), ByteField('mode'), TemperatureField('temperature'), HumidityField('humidity')])
+                            
     # Memory (EEPROM/FRAM) actions
 
     @staticmethod
@@ -229,6 +252,11 @@ class CoreAPI(object):
                                request_fields=[CharField('type'), WordField('page'), ByteField('start'), RawByteArrayField('data', length)],
                                response_fields=[CharField('type'), WordField('page'), ByteField('start'), ByteField('length'), CharField('result')])
 
+
+    # Memory (EEPROM/FRAM) actions of slave module
+    # TODO mR & mW (phase 2)
+
+
     # Slave bus
 
     @staticmethod
diff --git a/src/master/core/errors.py b/src/master/core/errors.py
index ef4e7d7a..95431bcd 100644
--- a/src/master/core/errors.py
+++ b/src/master/core/errors.py
@@ -45,7 +45,11 @@ class Error(object):
         SM_EXECUTE_GROUP_ACTION = 'SM_EXECUTE_GROUP_ACTION'
         SM_GROUP_DELAY_QUEUE = 'SM_GROUP_DELAY_QUEUE'
         SM_CAN_TX_QUEUE = 'SM_CAN_TX_QUEUE'
-        SM_INCORRECT_MODE = 'SM_INCORRECT_MODE'
+        API_SM_INCORRECT_MODE = 'API_SM_INCORRECT_MODE'
+        API_TW_INCORRECT_DATA = 'API_TW_INCORRECT_DATA'
+        API_BA_INCORRECT_LENGTH = 'API_BA_INCORRECT_LENGTH'
+        SLAVE_ERROR_EEPROM_RW = 'SLAVE_ERROR_EEPROM_RW'
+        INCORRECT_SLAVE_TYPE = 'INCORRECT_SLAVE_TYPE'
         MICRO_CAN_WATCHDOG_RESET = 'MICRO_CAN_WATCHDOG_RESET'
         MICRO_CAN_WARM_RESET = 'MICRO_CAN_WARM_RESET'
         MISSING_ENDIF = 'MISSING_ENDIF'
@@ -87,7 +91,11 @@ class Error(object):
                     19: Error.Types.MISSING_ENDIF,
                     20: Error.Types.SM_GROUP_DELAY_QUEUE,
                     21: Error.Types.SM_CAN_TX_QUEUE,
-                    22: Error.Types.SM_INCORRECT_MODE,
+                    22: Error.Types.API_SM_INCORRECT_MODE,
+                    23: Error.Types.API_TW_INCORRECT_DATA,
+                    24: Error.Types.API_BA_INCORRECT_LENGTH,
+                    25: Error.Types.SLAVE_ERROR_EEPROM_RW,
+                    26: Error.Types.INCORRECT_SLAVE_TYPE,
                     254: Error.Types.COMMAND_ERROR}
         return type_map.get(self._type, Error.Types.UNKNOWN)
 
@@ -106,6 +114,12 @@ class Error(object):
                     return 'Input module {0} is not responding'.format(self._parameter_b)
                 if self._parameter_a == 1:
                     return 'Address conflict during initialisation on {0}'.format(Error._decode_address(self._parameter_b, self._parameter_c))
+                if self._parameter_a == 2:
+                    return 'A communication error occurred (resulting in CRC error for example) while requesting pulse counter information from input {0}'.format(self._parameter_b)
+                if self._parameter_a == 3:
+                    return 'The external module didn\'t respond while requesting pulse counter information from input {0}'.format(self._parameter_b)
+                if self._parameter_a == 4:
+                    return 'No pulse counter information available for input {0}'.format(self._parameter_b)
             if self.type == Error.Types.SENSOR_ERROR:
                 if self._parameter_a == 0:
                     return 'Sensor module {0} is not responding'.format(self._parameter_b)
@@ -130,8 +144,29 @@ class Error(object):
                     return 'CRC error: An API instruction {0} has generated a CRC error and has not been interpreted'.format(Error._extract_command(self._parameter_b))
                 if self._parameter_b == 10:
                     return 'API parameters send on instruction {0} not in range to be an acceptable value'.format(Error._extract_command(self._parameter_b))
-            if self.type == Error.Types.SM_INCORRECT_MODE:
+                if self._parameter_b == 11:
+                    return 'Factory reset cannot be executed because the prepare instruction (BA254 2) has not been executed yet or wrong parameters are used to initiate the factory reset'
+            if self.type == Error.Types.API_SM_INCORRECT_MODE:
                 return 'API Instruction SM has set the wrong RS485 mode: {0} vs allowed 0 -> {1}'.format(self._parameter_b, self._parameter_c)
+            if self.type == Error.Types.API_TW_INCORRECT_DATA:
+                parameter = 'date' if self._parameter_b == 0 else 'time'
+                return 'API Instruction TW has set the wrong {0}'.format(parameter)
+            if self.type == Error.Types.API_BA_INCORRECT_LENGTH:
+                return 'API Instruction BA has the wrong length (length must be 6).'
+            if self.type == Error.Types.SLAVE_ERROR_EEPROM_RW:
+                parameter = 'module'
+                if self._parameter_a == ord('R'):
+                    parameter = 'RS485 slave'
+                elif self._parameter_a == ord('C'):
+                    parameter = 'uCAN'
+                return 'A remote {0} with address {1} is not responding on an eeprom read/write request'.format(parameter, Error._decode_address(self._parameter_b, self._parameter_c))
+            if self.type == Error.Types.INCORRECT_SLAVE_TYPE:
+                parameter = 'module'
+                if self._parameter_a == ord('R'):
+                    parameter = 'RS485 slave'
+                elif self._parameter_a == ord('C'):
+                    parameter = 'uCAN'
+                return 'An incorrect {0} module type is used for address {1}'.format(parameter, Error._decode_address(self._parameter_b, self._parameter_c))
             else:
                 return 'Unknown error type {0}. Parameters {1} / {2} / {3}'.format(self._type, self._parameter_a, self._parameter_b, self._parameter_c)
         except Exception as ex:
diff --git a/src/openmotics_cli.py b/src/openmotics_cli.py
index 15c13942..b5b00175 100644
--- a/src/openmotics_cli.py
+++ b/src/openmotics_cli.py
@@ -83,14 +83,17 @@ def cmd_shell(args):
           message_client=INJECTED,
           metrics_cache_controller=INJECTED,
           metrics_controller=INJECTED,
+          hvac_controller=INJECTED,
           module_controller=INJECTED,
           output_controller=INJECTED,
+          valve_pump_controller=INJECTED,
           plugin_controller=INJECTED,
           energy_module_controller=INJECTED,
           pubsub=INJECTED,
           pulse_counter_controller=INJECTED,
           room_controller=INJECTED,
           scheduling_controller=INJECTED,
+          setpoint_controller=INJECTED,
           sensor_controller=INJECTED,
           shutter_controller=INJECTED,
           thermostat_controller=INJECTED,
diff --git a/src/openmotics_service.py b/src/openmotics_service.py
index f1d1314b..df51aa63 100644
--- a/src/openmotics_service.py
+++ b/src/openmotics_service.py
@@ -17,12 +17,15 @@ The main module for the OpenMotics
 """
 from __future__ import absolute_import
 
+import os.path
+
 from platform_utils import Platform, System
 System.import_libs()
 
 import logging.handlers
 import sys
 import time
+import os
 from signal import SIGTERM, signal
 
 from sqlalchemy import select
@@ -37,26 +40,29 @@ from gateway.migrations.names import NamesMigrator
 from gateway.migrations.in_use import InUseMigrator
 from gateway.models import Database, Feature
 from gateway.pubsub import PubSub
+from gateway.updates.update_constants import UpdateConstants
 from ioc import INJECTED, Inject
 from logs import Logs
 
 
-
-
 if False:  # MYPY
     from gateway.authentication_controller import AuthenticationController
     from gateway.energy_module_controller import EnergyModuleController
     from gateway.output_controller import OutputController
+    from gateway.valve_pump.valve_pump_controller import ValvePumpController
     from gateway.group_action_controller import GroupActionController
     from gateway.input_controller import InputController
     from gateway.maintenance_controller import MaintenanceController
     from gateway.hal.master_controller import MasterController
     from gateway.metrics_collector import MetricsCollector
     from gateway.metrics_controller import MetricsController
+    from gateway.notification_controller import NotificationController
     from gateway.pulse_counter_controller import PulseCounterController
     from gateway.scheduling_controller import SchedulingController
+    from gateway.setpoint_controller import SetpointController
     from gateway.sensor_controller import SensorController
     from gateway.shutter_controller import ShutterController
+    from gateway.shutter_controller import ShutterController
     from gateway.system_controller import SystemController
     from gateway.thermostat.thermostat_controller import ThermostatController
     from gateway.ventilation_controller import VentilationController
@@ -68,7 +74,7 @@ if False:  # MYPY
     from gateway.hal.master_controller import MasterController
     from gateway.hal.frontpanel_controller import FrontpanelController
     from gateway.uart_controller import UARTController
-    from gateway.update_controller import UpdateController
+    from gateway.updates.update_controller import UpdateController
     from plugins.base import PluginController
     from master.classic.passthrough import PassthroughService
     from cloud.events import EventSender
@@ -116,8 +122,8 @@ class OpenmoticsService(object):
         scheduling_controller.set_webinterface(web_interface)
         metrics_collector.set_controllers(metrics_controller, plugin_controller)
         plugin_controller.set_webservice(web_service)
+        plugin_controller.set_webinterface(web_interface)
         plugin_controller.set_metrics_controller(metrics_controller)
-        plugin_controller.set_metrics_collector(metrics_collector)
         master_controller.set_plugin_controller(plugin_controller)
         authentication_controller.set_user_controller(user_controller)
 
@@ -132,6 +138,7 @@ class OpenmoticsService(object):
               metrics_controller=INJECTED,  # type: MetricsController
               passthrough_service=INJECTED,  # type: PassthroughService
               scheduling_controller=INJECTED,  # type: SchedulingController
+              setpoint_controller=INJECTED,  # type: SetpointController
               metrics_collector=INJECTED,  # type: MetricsCollector
               web_service=INJECTED,  # type: WebService
               web_interface=INJECTED,  # type: WebInterface
@@ -154,13 +161,30 @@ class OpenmoticsService(object):
               web_service_v1=INJECTED,  # type: WebServiceV1
               uart_controller=INJECTED,  # type: UARTController
               energy_module_controller=INJECTED,  # type: EnergyModuleController
-              update_controller=INJECTED  # type: UpdateController
+              update_controller=INJECTED,  # type: UpdateController
+              notification_controller=INJECTED  # type: NotificationController
               ):
         """ Main function. """
-        logger.info('Starting OM core service (%s) [%s]... ', gateway.__version__, Platform.get_platform())
+
+        interpreter_version, dependencies_version, service_version = '<unknown>', '<unknown>', gateway.__version__
+        if os.path.exists(UpdateConstants.VENV_CURRENT):
+            try:
+                interpreter_version, dependencies_version, service_version = os.readlink(UpdateConstants.VENV_CURRENT).split('/')[-1].split('_')
+            except Exception:
+                pass
+        logger.info('Starting OM core service (i%s, d%s, s%s) [%s]... ',
+                    interpreter_version,
+                    dependencies_version,
+                    service_version,
+                    Platform.get_platform())
+        actual_python_version = '{0}.{1}.{2}'.format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)
+        if interpreter_version != actual_python_version:
+            logger.warning('Actual python version: {0}'.format(actual_python_version))
 
         DefaultsMigrator.migrate()
 
+        _ = notification_controller  # Doesn't run anything, just needs to be instantiated, so it exists
+
         # MasterController should be running
         master_controller.start()
 
@@ -178,7 +202,7 @@ class OpenmoticsService(object):
             stmt = select(Feature.enabled).filter_by(name=Feature.THERMOSTATS_GATEWAY)  # type: ignore
             thermostats_gateway_enabled = db.execute(stmt).scalar()
         if thermostats_gateway_enabled:
-            ThermostatsMigrator.migrate()
+            ThermostatsMigrator.migrate(fatal=True)
         NamesMigrator.migrate()
         InUseMigrator.migrate()
 
diff --git a/src/openmotics_update.py b/src/openmotics_update.py
index b1899500..6c977238 100644
--- a/src/openmotics_update.py
+++ b/src/openmotics_update.py
@@ -36,7 +36,10 @@ logger = logging.getLogger()
 
 
 if __name__ == '__main__':
-    from gateway.update_controller import UpdateController
+    Logs.setup_logger()
+    from gateway.updates.update_constants import UpdateConstants
+    from gateway.updates.update_controller import UpdateController
+    from gateway.updates.update_gateway import GatewayUpdateController
 
     parser = ArgumentParser(description='Tool to update various components.',
                             epilog='Footnotes:\n'
@@ -44,14 +47,14 @@ if __name__ == '__main__':
                                    '  2. When the --file argument is not specified, the firmware will be download.\n'
                                    '  3. Address in format xxx.xxx.xxx.xxx (rs485 slaves) or xxx.xxx.xxx (uCAN)',
                             formatter_class=RawDescriptionHelpFormatter)
-    parser.add_argument('--execute-gateway-service-update',
-                        dest='update_gateway_service',
+    parser.add_argument('--build-virtual-environment',
+                        dest='build_virtual_environment',
                         help=SUPPRESS)
     parser.add_argument('--prepare-gateway-service-for-first-startup',
                         dest='prepare_gateway_service',
                         help=SUPPRESS)
     group = parser.add_mutually_exclusive_group()
-    for module_type in UpdateController.MODULE_TYPE_MAP.keys():
+    for module_type in UpdateConstants.MODULE_TYPE_MAP.keys():
         if module_type in ['master_core', 'master_classic']:
             platform = Platform.get_platform()
             supported = ((platform in Platform.CoreTypes and module_type == 'master_core') or
@@ -78,26 +81,26 @@ if __name__ == '__main__':
                         help='Only update a single module, specified by this address (3)')
     args = parser.parse_args()
 
-    if args.update_gateway_service or args.prepare_gateway_service:
-        Logs.setup_logger()
-        from gateway.update_controller import UpdateController
+    if args.build_virtual_environment or args.prepare_gateway_service:
         task = 'unknown'
         version = 'unknown'
         try:
-            if args.update_gateway_service:
-                task = 'update gateway service'
-                version = args.update_gateway_service
-                component_logger = Logs.get_update_logger('gateway_service')
+            if args.build_virtual_environment:
+                task = 'build virtual environment'
+                version = args.build_virtual_environment
+                component_logger = Logs.get_update_logger('virtual_environment')
                 component_logger.propagate = False
-                UpdateController.update_gateway_service(new_version=version, logger=component_logger)
+                GatewayUpdateController.generate_virtual_environment(version=version,
+                                                                     logger=component_logger)
             elif args.prepare_gateway_service:
                 task = 'prepare gateway service for first startup'
                 version = args.prepare_gateway_service
                 component_logger = Logs.get_print_logger('update.gateway_service')
-                UpdateController.update_gateway_service_prepare_for_first_startup(logger=component_logger)
+                GatewayUpdateController.update_gateway_service_prepare_for_first_startup(version=version,
+                                                                                         logger=component_logger)
             sys.exit(0)
         except Exception as ex:
-            with open(UpdateController.SERVICE_BASE_TEMPLATE.format('{0}.failure'.format(version)), 'a') as failure:
+            with open(UpdateConstants.VENV_BASE_TEMPLATE.format('{0}.failure'.format(version)), 'w') as failure:
                 failure.write('Failed to {0} ({1}): {2}\n'.format(task, version, ex))
             sys.exit(1)
 
@@ -126,7 +129,7 @@ if __name__ == '__main__':
         start_energy_stack = False
         start_master_stack = False
 
-        for module_type in UpdateController.MODULE_TYPE_MAP.keys():
+        for module_type in UpdateConstants.MODULE_TYPE_MAP.keys():
             args_key = 'update_{0}'.format(module_type)
             update_requested = hasattr(args, args_key) and getattr(args, args_key)
             if update_requested:
@@ -136,7 +139,6 @@ if __name__ == '__main__':
                     start_master_stack = True
 
                 if module_type is not None:
-                    Logs.setup_logger()
                     from gateway.initialize import setup_platform
                     setup_platform(message_client_name=None)
                     if start_energy_stack:
diff --git a/src/platform_utils.py b/src/platform_utils.py
index ba2f8ca8..c50bfee8 100644
--- a/src/platform_utils.py
+++ b/src/platform_utils.py
@@ -201,15 +201,69 @@ class System(object):
     Abstracts the system related functions
     """
 
-    SERVICES = ('vpn_service', 'openmotics')
-
-    SYSTEMD_UNIT_MAP = {'openmotics': 'openmotics-api.service',
-                        'vpn_service': 'openmotics-vpn.service'}
+    class ServiceManager(object):
+        SYSTEMD = 'systemd'
+        SUPERVISORD = 'supervisord'
+
+    class Service(object):
+        OPENMOTICS = 'openmotics'
+        VPN_SERVICE = 'vpn_service'
+        WATCHDOG = 'watchdog'
+
+    ALL_SERVICES = [Service.OPENMOTICS, Service.VPN_SERVICE, Service.WATCHDOG]
+    RESTARTABLE_SERVICES = [Service.OPENMOTICS, Service.VPN_SERVICE]
+
+    SERVICE_CONFIG_FOLDERS = {ServiceManager.SUPERVISORD: '/etc/supervisor/conf.d',
+                              ServiceManager.SYSTEMD: '/etc/systemd/system'}
+
+    SERVICE_CONFIG_FILES = {ServiceManager.SUPERVISORD: {Service.OPENMOTICS: 'openmotics.conf',
+                                                         Service.VPN_SERVICE: 'vpn_service.conf',
+                                                         Service.WATCHDOG: 'watchdog.conf'},
+                            ServiceManager.SYSTEMD: {Service.OPENMOTICS: 'openmotics-api.service',
+                                                     Service.VPN_SERVICE: 'openmotics-vpn.service',
+                                                     Service.WATCHDOG: 'openmotics-watchdog.service'}}
+    SERVICE_NAMES = {ServiceManager.SUPERVISORD: {Service.OPENMOTICS: 'openmotics',
+                                                  Service.VPN_SERVICE: 'vpn_service',
+                                                  Service.WATCHDOG: 'watchdog'},
+                     ServiceManager.SYSTEMD: {Service.OPENMOTICS: 'openmotics-api.service',
+                                              Service.VPN_SERVICE: 'openmotics-vpn.service',
+                                              Service.WATCHDOG: 'openmotics-watchdog.service'}}
 
     class OS(object):
         ANGSTROM = 'angstrom'
         DEBIAN = 'debian'
 
+    @staticmethod
+    def get_system_manager():
+        # Uses static file analysis, as it's faster than executing service manager helpers
+        service_manager = System.ServiceManager.SUPERVISORD
+        for config_file in System.SERVICE_CONFIG_FILES[service_manager].values():
+            if os.path.exists(os.path.join(System.SERVICE_CONFIG_FOLDERS[service_manager],
+                                           config_file)):
+                return System.ServiceManager.SUPERVISORD
+        return System.ServiceManager.SYSTEMD
+
+    @staticmethod
+    def reload_services(wait=False):
+        # type: (bool) -> None
+        service_manager = System.get_system_manager()
+        if service_manager == System.ServiceManager.SUPERVISORD:
+            process = subprocess.Popen(['supervisorctl', 'reload'],
+                                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
+                                       close_fds=True)
+            if wait:
+                process.wait()
+        else:
+            subprocess.Popen(['systemctl', 'daemon-reload'],
+                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
+                             close_fds=True).wait()
+            processes = [subprocess.Popen(['systemctl', 'restart', '--no-pager', System.SERVICE_NAMES[service_manager][service]],
+                                          stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
+                                          close_fds=True)
+                         for service in System.ALL_SERVICES]
+            for process in processes:
+                process.wait()
+
     @staticmethod
     def restart_service(service, wait=False):
         # type: (str, bool) -> None
@@ -220,35 +274,15 @@ class System(object):
     @staticmethod
     def run_service_action(action, service):
         # type: (str, str) -> subprocess.Popen
-        unit_name = System.SYSTEMD_UNIT_MAP.get(service, service)
-        is_systemd = False
-        is_supervisor = False
-        try:
-            subprocess.check_output(['systemctl', 'is-enabled', unit_name])
-            is_systemd = True
-        except subprocess.CalledProcessError:
-            is_systemd = False
-        except Exception:  # Python 3 error (FileNotFoundErr) but is not known in python 2...
-            is_systemd = False
-
-        try:
-            subprocess.check_output(['supervisorctl', 'status', service])
-            is_supervisor = True
-        except subprocess.CalledProcessError:
-            is_supervisor = False
-        except Exception:  # Python 3 error (FileNotFoundErr) but is not known in python 2...
-            is_supervisor = False
-
-        if is_systemd:
-            return subprocess.Popen(['systemctl', action, '--no-pager', unit_name],
-                                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
-                                    close_fds=True)
-        elif is_supervisor:
-            return subprocess.Popen(['supervisorctl', action, service],
+        service_manager = System.get_system_manager()
+        service_name = System.SERVICE_NAMES[service_manager][service]
+        if service_manager == System.ServiceManager.SUPERVISORD:
+            return subprocess.Popen(['supervisorctl', action, service_name],
                                     stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                                     close_fds=True)
-        else:
-            raise RuntimeError('Could not find the appropriate service manager to run the service action command')
+        return subprocess.Popen(['systemctl', action, '--no-pager', service_name],
+                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
+                                close_fds=True)
 
     @staticmethod
     def get_operating_system():
@@ -289,12 +323,20 @@ class System(object):
         return 'openvpn.service' if System.get_operating_system().get('ID') == System.OS.ANGSTROM else 'openvpn-client@omcloud'
 
     @staticmethod
-    def _use_pyopenssl():
+    def verify_requests():
+        if sys.version_info.major == 3:
+            return True
+        return System.get_operating_system().get('ID') != System.OS.ANGSTROM
+
+    @staticmethod
+    def legacy_authentication():
+        if sys.version_info.major == 3:
+            return False
         return System.get_operating_system().get('ID') == System.OS.ANGSTROM
 
     @staticmethod
     def get_ssl_socket(sock, private_key_filename, certificate_filename):
-        if System._use_pyopenssl():
+        if System.legacy_authentication():
             from OpenSSL import SSL
             context = SSL.Context(SSL.SSLv23_METHOD)
             context.use_privatekey_file(private_key_filename)
@@ -310,7 +352,7 @@ class System(object):
 
     @staticmethod
     def setup_cherrypy_ssl(https_server):
-        if System._use_pyopenssl():
+        if System.legacy_authentication():
             https_server.ssl_module = 'pyopenssl'
         else:
             import ssl
@@ -320,7 +362,7 @@ class System(object):
 
     @staticmethod
     def handle_socket_exception(connection, exception, logger):
-        if System._use_pyopenssl():
+        if System.legacy_authentication():
             import select
             from OpenSSL import SSL
             if isinstance(exception, SSL.SysCallError):
@@ -349,18 +391,14 @@ class System(object):
 
     @staticmethod
     def import_libs():
-        operating_system = System.get_operating_system().get('ID')
-        # check if running in python 2 mode, otherwise packages should be included in the build (PyInstaller)
+        import site
         if sys.version_info.major == 2:
-            import site
-            path = os.path.abspath(os.path.join(__file__, '../../python-deps/lib/python2.7/site-packages'))
+            path = os.path.abspath(os.path.join(__file__, '../../python-deps/lib/python{0}.{1}/site-packages'.format(sys.version_info[0], sys.version_info[1])))
             if os.path.exists(path):
                 site.addsitedir(path)
                 sys.path.remove(path)
                 sys.path.insert(0, path)
-
-        if operating_system in [System.OS.ANGSTROM, System.OS.DEBIAN]:
-            path = os.path.abspath(os.path.join(__file__, '../libs/cacert.pem'))
+            path = os.path.abspath(os.path.join(__file__, '../etc/cacert.pem'))
             os.environ['REQUESTS_CA_BUNDLE'] = path
 
 
diff --git a/src/plugin_runtime/base.py b/src/plugin_runtime/base.py
index 5b8d6ebd..ca2023b7 100644
--- a/src/plugin_runtime/base.py
+++ b/src/plugin_runtime/base.py
@@ -3,10 +3,7 @@ from __future__ import absolute_import
 import base64
 import logging
 import os
-import sys
-
 import six
-
 import constants
 from plugin_runtime.decorators import *  # Import for backwards compatibility
 
@@ -17,9 +14,9 @@ except ImportError:
     import json  # type: ignore
 
 if False:  # MyPy
-    from typing import Dict, Optional, Any, Union, AnyStr
+    from typing import Dict, Optional, Any, AnyStr
 
-logger = logging.getLogger(__name__)
+global_logger = logging.getLogger(__name__)
 
 
 class PluginException(Exception):
@@ -33,18 +30,21 @@ class OMPluginBase(object):
     module with the name 'main' that contains a class that extends this class.
     """
 
-    def __init__(self, webinterface, logger):
+    def __init__(self, *args, **kwargs):
         """
         The web interface is provided to the plugin to interface with the OpenMotics system.
-
-        :param webinterface: Reference the OpenMotics webinterface, this can be used to
-        perform actions, fetch status data, etc.
-        :param logger: Function that can be called with one parameter: message (String),
-        the message will be appended to the plugin's log. This log can be fetched using
-        the webinterface.
         """
-        self.webinterface = webinterface
-        self.logger = logger
+        if len(args) == 0:  # This means we'll use kwargs
+            self.webinterface = kwargs.get('webinterface')
+            self.connector = kwargs.get('connector')
+        elif len(args) == 2:
+            self.webinterface = args[0]
+            self.logger = args[1]
+            global_logger.warning('Using positional arguments is deprecated, use keyword arguments instead')
+            global_logger.warning('The `logger` is deprecated. Use a global `logger = logging.getLogger(__name__)` instead')
+        else:
+            global_logger.error('Use only keyword arguments (`webinterface` and/or `connector`)')
+            raise RuntimeError('Invalid arguments')
 
     def __get_config_path(self):
         """ Get the path for the plugin configuration file based on the plugin name. """
@@ -67,7 +67,7 @@ class OMPluginBase(object):
             try:
                 return json.loads(config)
             except Exception as exception:
-                logger.error('Exception while getting config for plugin \'{0}\': {1}'.format(self.__class__.name, exception))
+                global_logger.error('Exception while getting config for plugin \'{0}\': {1}'.format(self.__class__.name, exception))
 
         return default_config
 
@@ -78,6 +78,10 @@ class OMPluginBase(object):
         with open(self.__get_config_path(), 'w') as config_file:
             config_file.write(json.dumps(config))
 
+    def on_remove(self):
+        """ Can be overridden for an on-remove handler """
+        pass
+
 
 class PluginConfigChecker(object):
     """
@@ -379,7 +383,8 @@ class PluginWebRequest(object):
         )
         return '<PluginWebRequest>   {}'.format(vars_str)
 
-class PluginWebBody():
+
+class PluginWebBody(object):
     """
     Class that will hold the PluginWebBody content and can serialize the content in Base64 string.
     """
diff --git a/src/plugin_runtime/connectors/__init__.py b/src/plugin_runtime/connectors/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/src/plugin_runtime/connectors/base_connector.py b/src/plugin_runtime/connectors/base_connector.py
new file mode 100644
index 00000000..9f536f08
--- /dev/null
+++ b/src/plugin_runtime/connectors/base_connector.py
@@ -0,0 +1,94 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" BaseImplementationConnector """
+
+from __future__ import absolute_import
+import copy
+import logging
+
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Dict, Any, Tuple, Callable, Optional, List
+
+global_logger = logging.getLogger(__name__)
+
+
+class BaseImplementationConnector(object):
+    ACTION = None  # type: Optional[str]
+    CALLBACK_ACTION = None  # type: Optional[str]
+    SUPPORTED_EVENT_VERSIONS = []  # type: List[int]
+    EVENT_TYPE = None  # type: Optional[str]
+
+    def __init__(self, connector):
+        self._connector = connector
+        self._status_event_handler_infos = {}  # type: Dict[str, Tuple[Callable[..., Any], int]]
+        self._action_handler_infos = {}  # type: Dict[str, Tuple[Callable[..., Any], int]]
+
+    def _stop(self):
+        pass  # Can optionally be overridden to for example stop threads
+
+    def subscribe_status_event(self, handler, version=None):
+        if not self.SUPPORTED_EVENT_VERSIONS:
+            raise RuntimeError('This connector does not support status events')
+        if version is None:
+            version = self.SUPPORTED_EVENT_VERSIONS[-1]
+            global_logger.warning('No version specified, using latest version. This might break in the future.')
+        if version not in self.SUPPORTED_EVENT_VERSIONS:
+            raise ValueError('This connector does not support version {0}. Supported versions: {1}'.format(
+                version, ', '.join(str(version) for version in self.SUPPORTED_EVENT_VERSIONS)
+            ))
+        self._connector._subscribe_status_event_type(event_type=self.EVENT_TYPE)
+        self._status_event_handler_infos[handler.__name__] = (handler, version)
+
+    def _distribute_status_event(self, event):  # type: (_PluginStatusEvent) -> None
+        if event.type != self.EVENT_TYPE:
+            raise RuntimeError('This connector does not support event type {0}'.format(event.type))
+        for handler_info in self._status_event_handler_infos.values():
+            handler, version = handler_info
+            try:
+                self._process_status_event(event=copy.deepcopy(event),
+                                           handler=handler,
+                                           version=version)
+            except Exception as ex:
+                global_logger.exception('Error while processing status event: {0}'.format(ex))
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        raise NotImplementedError()
+
+    def _attach_action(self, action, handler, version):
+        # type: (str, Callable[..., Any], int) -> None
+        self._action_handler_infos[action] = (handler, version)
+
+    def _distribute_action(self, action, action_payload):
+        handler_info = self._action_handler_infos.get(action)
+        if handler_info is None:
+            return
+        handler, version = handler_info
+        return self._process_action(action=action,
+                                    payload=action_payload,
+                                    handler=handler,
+                                    version=version)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise NotImplementedError()
+
+    def _callback_action(self, action, payload):
+        return self._connector._callback_action(connector=self,
+                                                action=action,
+                                                payload=payload)
diff --git a/src/plugin_runtime/connectors/connector.py b/src/plugin_runtime/connectors/connector.py
new file mode 100644
index 00000000..e39c61e0
--- /dev/null
+++ b/src/plugin_runtime/connectors/connector.py
@@ -0,0 +1,95 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" Connector """
+
+from __future__ import absolute_import
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+from plugin_runtime.connectors.input import InputConnector as _InputConnector
+from plugin_runtime.connectors.metrics import MetricsConnector as _MetricsConnector
+from plugin_runtime.connectors.output import OutputConnector as _OutputConnector
+from plugin_runtime.connectors.screen import ScreenConnector as _ScreenConnector
+from plugin_runtime.connectors.sensor import SensorConnector as _SensorConnector
+from plugin_runtime.connectors.shutter import ShutterConnector as _ShutterConnector
+from plugin_runtime.connectors.thermostat import ThermostatConnector as _ThermostatConnector
+from plugin_runtime.connectors.thermostat_group import ThermostatGroupConnector as _ThermostatGroupConnector
+from plugin_runtime.connectors.ventilation import VentilationConnector as _VentilationConnector
+from plugin_runtime.connectors.notification import NotificationConnector as _NotificationConnector
+
+if False:  # MYPY
+    from typing import Dict, Any, List
+    from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+
+
+class Connector(object):
+    class Enums(object):
+        StatusEventType = _PluginActionEnums.StatusEventType
+
+    # TODO:
+    #  * Split up driving vs controlling?
+
+    def __init__(self, forward_callback_actions, forward_status_event_subscriptions):
+        self._forward_callback_actions = forward_callback_actions
+        self._forward_status_event_subscriptions = forward_status_event_subscriptions
+
+        self.input = _InputConnector(self)
+        self.metrics = _MetricsConnector(self)
+        self.output = _OutputConnector(self)
+        self.screen = _ScreenConnector(self)
+        self.sensor = _SensorConnector(self)
+        self.shutter = _ShutterConnector(self)
+        self.thermostat = _ThermostatConnector(self)
+        self.thermostat_group = _ThermostatGroupConnector(self)
+        self.ventilation = _VentilationConnector(self)
+        self.notification = _NotificationConnector(self)
+
+        self._connectors = [self.input, self.metrics, self.output, self.screen,
+                            self.sensor, self.shutter, self.thermostat,
+                            self.thermostat_group, self.ventilation, self.notification]  # type: List[BaseImplementationConnector]
+
+    def _stop(self):
+        for connector in self._connectors:
+            connector._stop()
+
+    def _distribute_status_event(self, event):  # type: (_PluginStatusEvent) -> None
+        for connector in self._connectors:
+            if event.type == connector.EVENT_TYPE:
+                connector._distribute_status_event(event=event)
+
+    def _subscribe_status_event_type(self, event_type):  # type: (str) -> None
+        self._forward_status_event_subscriptions(types=[event_type])
+
+    def _subscribe_for_type(self, event_type, handler, version):
+        # To be used in the PluginRuntime for attaching decorators
+        for connector in self._connectors:
+            if event_type == connector.EVENT_TYPE:
+                connector.subscribe_status_event(handler=handler,
+                                                 version=version)
+
+    def _callback_action(self, connector, action, payload):
+        if connector.CALLBACK_ACTION is None:
+            raise RuntimeError('Cannot forward callback action for this controller')
+        return self._forward_callback_actions(action=connector.CALLBACK_ACTION,
+                                              payload={'action': action,
+                                                       'action_payload': payload})
+
+    def _distribute_action(self, action, payload):  # type: (str, Dict[str, Any]) -> None
+        for connector in self._connectors:
+            if connector.ACTION == action:
+                # There should be only one connector supporting every action
+                return connector._distribute_action(action=payload['action'],
+                                                    action_payload=payload['action_payload'])
diff --git a/src/plugin_runtime/connectors/input.py b/src/plugin_runtime/connectors/input.py
new file mode 100644
index 00000000..90979a71
--- /dev/null
+++ b/src/plugin_runtime/connectors/input.py
@@ -0,0 +1,45 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" InputConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class InputConnector(BaseImplementationConnector):
+    SUPPORTED_EVENT_VERSIONS = [1, 2, 3]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.INPUT_CHANGE
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        input_id = event.data['id']
+        input_status = event.data['status']
+        if version == 1:
+            if input_status:
+                handler((input_id, None))
+        elif version == 2:
+            handler({'input_id': input_id, 'status': input_status})
+        else:  # version == 3
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
diff --git a/src/plugin_runtime/connectors/metrics.py b/src/plugin_runtime/connectors/metrics.py
new file mode 100644
index 00000000..ec3ec21e
--- /dev/null
+++ b/src/plugin_runtime/connectors/metrics.py
@@ -0,0 +1,114 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" MetricConnector """
+
+from __future__ import absolute_import
+import time
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.daemon_thread import DaemonThread
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+from gateway.enums import MetricsEnums as _MetricsEnums
+
+if False:  # MYPY
+    from typing import Callable, Any, Dict, Tuple
+
+
+class MetricsConnector(BaseImplementationConnector):
+    ACTION = _PluginActionEnums.Action.METRIC_ACTION
+    CALLBACK_ACTION = _PluginActionEnums.Action.METRIC_CALLBACK_ACTION
+
+    def __init__(self, connector):
+        super(MetricsConnector, self).__init__(connector=connector)
+        self._delivery_handlers = {}  # type: Dict[str, Tuple[str, Callable[..., Any], int]]
+        self._polling_handlers = {}  # type: Dict[str, Tuple[Callable[..., Any], int]]
+
+        self._metrics_poller = DaemonThread(name='pluginpoller',
+                                            target=self._poll_metrics,
+                                            interval=1.0)
+        self._last_poll = {}  # type: Dict[str, float]
+
+    def _stop(self):
+        if self._metrics_poller.is_started:
+            self._metrics_poller.stop()
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        raise RuntimeError('This connector does not support status events')
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        _ = version  # Only one supported version
+        if action == _MetricsEnums.Action.DELIVER_METRICS:
+            return handler(identifier=payload['identifier'],
+                           metrics=payload['metrics'])
+
+    # Subscription of metrics delivered from Gateway to Plugin
+
+    def _deliver_metrics_to_plugin(self, identifier, metrics):
+        for handler_info in self._delivery_handlers.values():
+            needed_identifier, handler, version = handler_info
+            if identifier != needed_identifier:
+                continue
+            if version == 1:
+                for metric in metrics:
+                    handler(metric)
+            else:  # version == 2:
+                handler(metrics=metrics)
+
+    def attach_metrics_subscription(self, handler, source=None, metric_type=None, interval=None, version=2):
+        # Note that the `interval` is merely a desire towards the collectors. The rate of delivery might be higher
+        # if more metrics are available
+
+        # Subscribe to metrics with the given filters
+        identifier = '{0}_{1}_{2}'.format(source, metric_type, interval)
+        self._callback_action(action=_MetricsEnums.CallbackAction.SUBSCRIBE_METRICS,
+                              payload={'identifier': identifier,
+                                       'source': source,
+                                       'metric_type': metric_type,
+                                       'interval': interval})
+        # Add this specific handler
+        self._delivery_handlers[handler.__name__] = (identifier, handler, version)
+        # Re-attach internal action handler
+        self._attach_action(action=_MetricsEnums.Action.DELIVER_METRICS,
+                            handler=self._deliver_metrics_to_plugin,
+                            version=version)
+
+    # Deliver metrics from Plugin to Gateway
+
+    def _attach_collector(self, handler, interval):
+        self._polling_handlers[handler.__name__] = (handler, interval)
+        if not self._metrics_poller.is_started:
+            self._metrics_poller.start()
+
+    def _poll_metrics(self):
+        now = time.time()
+        for handler_name, handler_info in self._polling_handlers.items():
+            handler, interval = handler_info
+            last_poll = self._last_poll.get(handler_name, now + 60)  # delay at startup
+            self._last_poll[handler_name] = last_poll
+            if last_poll > now - interval:
+                continue
+            metrics = list(handler())
+            self._last_poll[handler_name] = now
+            self.deliver_metrics(metrics=metrics)
+
+    def deliver_metrics(self, metrics, version=1):
+        if version != 1:
+            raise RuntimeError('Only version 1 is accepted')
+        # TODO: This is currently a direct forward. If needed, batching can be added
+        self._callback_action(action=_MetricsEnums.CallbackAction.DELIVER_METRICS,
+                              payload={'metrics': metrics})
diff --git a/src/plugin_runtime/connectors/notification.py b/src/plugin_runtime/connectors/notification.py
new file mode 100644
index 00000000..db87db2f
--- /dev/null
+++ b/src/plugin_runtime/connectors/notification.py
@@ -0,0 +1,49 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" NotificationConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import (
+    PluginActionEnums as _PluginActionEnums,
+    NotificationEnums as _NotificationEnums
+)
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class NotificationConnector(BaseImplementationConnector):
+    CALLBACK_ACTION = _PluginActionEnums.Action.NOTIFICATION_CALLBACK_ACTION
+
+    class Enums(object):
+        Type = _NotificationEnums.Type
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        raise RuntimeError('This connector does not support status events')
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
+
+    def send(self, topic, message, message_type=_NotificationEnums.Type.USER):
+        # type: (str, str, str) -> Any
+        return self._callback_action(action=_NotificationEnums.CallbackAction.SEND,
+                                     payload={'type': message_type,
+                                              'topic': topic,
+                                              'message': message})
diff --git a/src/plugin_runtime/connectors/output.py b/src/plugin_runtime/connectors/output.py
new file mode 100644
index 00000000..0ced4c0e
--- /dev/null
+++ b/src/plugin_runtime/connectors/output.py
@@ -0,0 +1,44 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" OutputConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class OutputConnector(BaseImplementationConnector):
+    SUPPORTED_EVENT_VERSIONS = [1, 2, 3]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.OUTPUT_CHANGE
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        states = event.data['states']
+        event.data = event.data['event']
+        if version == 1:
+            handler(states)
+        elif version == 2:
+            handler(event.data)
+        else:  # version == 3
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
diff --git a/src/plugin_runtime/connectors/screen.py b/src/plugin_runtime/connectors/screen.py
new file mode 100644
index 00000000..fd5f0832
--- /dev/null
+++ b/src/plugin_runtime/connectors/screen.py
@@ -0,0 +1,136 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" ScreenConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+from gateway.enums import ScreenEnums as _ScreenEnums
+from gateway.exceptions import FeatureUnavailableException
+
+if False:  # MYPY
+    from typing import Callable, Any, Optional
+
+
+class ScreenConnector(BaseImplementationConnector):
+    ACTION = _PluginActionEnums.Action.SCREEN_ACTION
+    CALLBACK_ACTION = _PluginActionEnums.Action.SCREEN_CALLBACK_ACTION
+    SUPPORTED_EVENT_VERSIONS = [1]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.SCREEN_CHANGE
+
+    class DTOs(object):
+        from gateway.dto.screen import (
+            ScreenStateDTO as _ScreenStateDTO,
+            PluginScreenDTO as _PluginScreenDTO
+        )
+        ScreenStateDTO = _ScreenStateDTO
+        ScreenDTO = _PluginScreenDTO
+
+    class Enums(object):
+        State = _ScreenEnums.State
+        Type = _ScreenEnums.Type
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        _ = version  # Only one supported version
+        handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        _ = version  # Only one supported version
+        if action in [_ScreenEnums.Action.OPEN,
+                      _ScreenEnums.Action.STOP,
+                      _ScreenEnums.Action.CLOSE]:
+            return handler(external_id=payload['external_id'])
+        if action == _ScreenEnums.Action.GOTO_POSITION:
+            return handler(external_id=payload['external_id'],
+                           rotational_position=payload['rotational_position'],
+                           translational_position=payload['translational_position'])
+
+    # Driver (e.g. a plugin that integrates a third-party screen)
+
+    def register(self, external_id, name, type, translational_steps, rotational_steps):
+        _ = external_id, name, type, translational_steps, rotational_steps
+        raise FeatureUnavailableException('Screens are currently unavailable')  # TODO: Temporarily disabled
+
+        from gateway.dto import PluginScreenDTO
+        return self._callback_action(action=_ScreenEnums.CallbackAction.REGISTER,
+                                     payload=PluginScreenDTO(external_id=external_id,
+                                                             name=name,
+                                                             type=type,
+                                                             translational_steps=translational_steps,
+                                                             rotational_steps=rotational_steps))
+
+    def report_state(self, external_id, translational_state, rotational_state):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.REPORT_STATUS,
+                                     payload={'external_id': external_id,
+                                              'translational_state': translational_state,
+                                              'rotational_state': rotational_state})
+
+    def attach_open(self, handler, version=1):
+        # type: (Callable[[str], Any], int) -> None
+        """ Expected definition: handler([self,] external_id) """
+        self._attach_action(action=_ScreenEnums.Action.OPEN,
+                            handler=handler,
+                            version=version)
+
+    def attach_close(self, handler, version=1):
+        # type: (Callable[[str], Any], int) -> None
+        """ Expected definition: handler([self,] external_id) """
+        self._attach_action(action=_ScreenEnums.Action.CLOSE,
+                            handler=handler,
+                            version=version)
+
+    def attach_stop(self, handler, version=1):
+        # type: (Callable[[str], Any], int) -> None
+        """ Expected definition: handler([self,] external_id) """
+        self._attach_action(action=_ScreenEnums.Action.STOP,
+                            handler=handler,
+                            version=version)
+
+    def attach_goto_position(self, handler, version=1):
+        # type: (Callable[[str, Optional[int], Optional[int]], Any], int) -> None
+        """ Expected definition: handler([self,] external_id, rotational_position, translational_position) """
+        self._attach_action(action=_ScreenEnums.Action.GOTO_POSITION,
+                            handler=handler,
+                            version=version)
+
+    # General
+
+    def load_screens(self, all_screens=False):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.LOAD_SCREENS,
+                                     payload={'all_screens': all_screens})
+
+    # Controller (e.g. a plugin that controls screens based on weather conditions)
+
+    def open(self, screen_id):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.OPEN,
+                                     payload={'screen_id': screen_id})
+
+    def close(self, screen_id):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.CLOSE,
+                                     payload={'screen_id': screen_id})
+
+    def stop(self, screen_id):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.STOP,
+                                     payload={'screen_id': screen_id})
+
+    def goto_position(self, screen_id, rotational_position=None, translational_position=None):
+        return self._callback_action(action=_ScreenEnums.CallbackAction.GOTO_POSITION,
+                                     payload={'screen_id': screen_id,
+                                              'rotational_position': rotational_position,
+                                              'translational_position': translational_position})
diff --git a/src/plugin_runtime/connectors/sensor.py b/src/plugin_runtime/connectors/sensor.py
new file mode 100644
index 00000000..ffeacffe
--- /dev/null
+++ b/src/plugin_runtime/connectors/sensor.py
@@ -0,0 +1,109 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" SensorConnector """
+
+from __future__ import absolute_import
+
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+from gateway.dto.sensor import PluginSensorDTO as _PluginSensorDTO
+from gateway.dto.sensor import SensorStateDTO as _SensorStateDTO
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.enums import SensorEnums as _SensorEnums
+from plugin_runtime.connectors.base_connector import \
+    BaseImplementationConnector
+
+if False:  # MYPY
+    from typing import Callable, Any, Optional
+
+
+class SensorConnector(BaseImplementationConnector):
+    ACTION = _PluginActionEnums.Action.SENSOR_ACTION
+    CALLBACK_ACTION = _PluginActionEnums.Action.SENSOR_CALLBACK_ACTION
+    SUPPORTED_EVENT_VERSIONS = [1, 2]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.SENSOR_CHANGE
+
+    class DTOs(object):
+        SensorStateDTO = _SensorStateDTO
+        SensorDTO = _PluginSensorDTO
+
+    class Enums(object):
+        Units = _SensorEnums.Units
+        ALL_UNITS = _SensorEnums.ALL_UNITS
+        PhysicalQuantities = _SensorEnums.PhysicalQuantities
+        ALL_PHYSICAL_QUANTITIES = _SensorEnums.ALL_PHYSICAL_QUANTITIES
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        if version == 1:
+            handler(event.data)
+        else:  # version == 2
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
+
+    def register_power_watt(self, external_id, name=None):
+        # type: (str, Optional[str]) -> _PluginSensorDTO
+        return self.register(external_id=external_id, name=name,
+                             physical_quantity=_SensorEnums.PhysicalQuantities.POWER,
+                             unit=_SensorEnums.Units.WATT)
+
+    def register_energy_kwh(self, external_id, name=None):
+        # type: (str, Optional[str]) -> _PluginSensorDTO
+        return self.register(external_id=external_id, name=name,
+                             physical_quantity=_SensorEnums.PhysicalQuantities.ENERGY,
+                             unit=_SensorEnums.Units.KILO_WATT_HOUR)
+
+    def register_temperature_celcius(self, external_id, name=None):
+        # type: (str, Optional[str]) -> _PluginSensorDTO
+        return self.register(external_id=external_id, name=name,
+                             physical_quantity=_SensorEnums.PhysicalQuantities.TEMPERATURE,
+                             unit=_SensorEnums.Units.CELCIUS)
+
+    def register_humidity_percent(self, external_id, name=None):
+        # type: (str, Optional[str]) -> _PluginSensorDTO
+        return self.register(external_id=external_id, name=name,
+                             physical_quantity=_SensorEnums.PhysicalQuantities.HUMIDITY,
+                             unit=_SensorEnums.Units.PERCENT)
+
+    def register_co2_ppm(self, external_id, name=None):
+        # type: (str, Optional[str]) -> _PluginSensorDTO
+        return self.register(external_id=external_id, name=name,
+                             physical_quantity=_SensorEnums.PhysicalQuantities.CO2,
+                             unit=_SensorEnums.Units.PARTS_PER_MILLION)
+
+    def register(self, external_id, physical_quantity, unit, name=None):
+        # type: (str, str, str, Optional[str]) -> _PluginSensorDTO
+        if physical_quantity not in SensorConnector.Enums.ALL_PHYSICAL_QUANTITIES:
+            raise ValueError('The given physical quantity `{0}` is invalid. Should be one of: {1}'.format(
+                physical_quantity, ', '.join(SensorConnector.Enums.ALL_PHYSICAL_QUANTITIES)
+            ))
+        if unit not in SensorConnector.Enums.ALL_UNITS:
+            raise ValueError('The given unit `{0}` is invalid. Should be one of: {1}'.format(
+                unit, ', '.join(SensorConnector.Enums.ALL_PHYSICAL_QUANTITIES)
+            ))
+        return self._callback_action(action=_SensorEnums.CallbackAction.REGISTER,
+                                     payload=_PluginSensorDTO(external_id=external_id,
+                                                              physical_quantity=physical_quantity,
+                                                              unit=unit,
+                                                              name=name))
+
+    def report_state(self, sensor, value):
+        # type: (_PluginSensorDTO, float) -> _SensorStateDTO
+        return self._callback_action(action=_SensorEnums.CallbackAction.REPORT_STATUS,
+                                     payload={'sensor': sensor,
+                                              'value': value})
diff --git a/src/plugin_runtime/connectors/shutter.py b/src/plugin_runtime/connectors/shutter.py
new file mode 100644
index 00000000..b1c33987
--- /dev/null
+++ b/src/plugin_runtime/connectors/shutter.py
@@ -0,0 +1,47 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" ShutterConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class ShutterConnector(BaseImplementationConnector):
+    SUPPORTED_EVENT_VERSIONS = [1, 2, 3, 4]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.SHUTTER_CHANGE
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        status = event.data['status']
+        detail = event.data['detail']
+        event.data = event.data['event']
+        if version == 1:
+            handler(status)
+        elif version == 2:
+            handler(status, detail)
+        elif version == 3:
+            handler(event.data)
+        else:  # version == 4
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
diff --git a/src/plugin_runtime/connectors/thermostat.py b/src/plugin_runtime/connectors/thermostat.py
new file mode 100644
index 00000000..66e57bee
--- /dev/null
+++ b/src/plugin_runtime/connectors/thermostat.py
@@ -0,0 +1,40 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" ThermostatConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class ThermostatConnector(BaseImplementationConnector):
+    SUPPORTED_EVENT_VERSIONS = [1, 2]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.THERMOSTAT_CHANGE
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        if version == 1:
+            handler(event.data)
+        else:  # version == 2
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
diff --git a/src/plugin_runtime/connectors/thermostat_group.py b/src/plugin_runtime/connectors/thermostat_group.py
new file mode 100644
index 00000000..a0d283a5
--- /dev/null
+++ b/src/plugin_runtime/connectors/thermostat_group.py
@@ -0,0 +1,40 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" ThermostatGroupConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import PluginActionEnums as _PluginActionEnums
+from gateway.dto import PluginStatusEvent as _PluginStatusEvent
+
+if False:  # MYPY
+    from typing import Callable, Any
+
+
+class ThermostatGroupConnector(BaseImplementationConnector):
+    SUPPORTED_EVENT_VERSIONS = [1, 2]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.THERMOSTAT_GROUP_CHANGE
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        if version == 1:
+            handler(event.data)
+        else:  # version == 2
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        raise RuntimeError('This connector does not support processing actions')
diff --git a/src/plugin_runtime/connectors/ventilation.py b/src/plugin_runtime/connectors/ventilation.py
new file mode 100644
index 00000000..925c44a8
--- /dev/null
+++ b/src/plugin_runtime/connectors/ventilation.py
@@ -0,0 +1,90 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+""" VentilationConnector """
+
+from __future__ import absolute_import
+from plugin_runtime.connectors.base_connector import BaseImplementationConnector
+from gateway.enums import (
+    PluginActionEnums as _PluginActionEnums,
+    VentilationEnums as _VentilationEnums
+)
+from gateway.dto import (
+    PluginStatusEvent as _PluginStatusEvent,
+    PluginVentilationDTO as _PluginVentilationDTO
+)
+
+if False:  # MYPY
+    from typing import Callable, Any, Optional
+
+
+class VentilationConnector(BaseImplementationConnector):
+    ACTION = _PluginActionEnums.Action.VENTILATION_ACTION
+    CALLBACK_ACTION = _PluginActionEnums.Action.VENTILATION_CALLBACK_ACTION
+    SUPPORTED_EVENT_VERSIONS = [1, 2]
+    EVENT_TYPE = _PluginActionEnums.StatusEventType.VENTILATION_CHANGE
+
+    class DTOs(object):
+        VentilationDTO = _PluginVentilationDTO
+
+    def _process_status_event(self, event, handler, version):
+        # type: (_PluginStatusEvent, Callable[..., Any], int) -> None
+        if version == 1:
+            handler(event.data)
+        else:  # version == 2
+            handler(event=event)
+
+    def _process_action(self, action, payload, handler, version):
+        # type: (str, Any, Callable[..., Any], int) -> Any
+        _ = version  # Only one supported version
+        if action == _VentilationEnums.Action.SET_AUTO:
+            return handler(external_id=payload['external_id'])
+        if action == _VentilationEnums.Action.SET_MANUAL:
+            return handler(external_id=payload['external_id'],
+                           level=payload['level'],
+                           timer=payload['timer'])
+
+    # Driver (e.g. a plugin that integrates a thrid-party ventilation system)
+
+    def register(self, external_id, name, amount_of_levels, device_type, device_vendor, device_serial):
+        return self._callback_action(action=_VentilationEnums.CallbackAction.REGISTER,
+                                     payload=_PluginVentilationDTO(external_id=external_id,
+                                                                   name=name,
+                                                                   amount_of_levels=amount_of_levels,
+                                                                   device_type=device_type,
+                                                                   device_vendor=device_vendor,
+                                                                   device_serial=device_serial))
+
+    def report_state(self, external_id, mode, level, remaining_time, last_seen=None):
+        return self._callback_action(action=_VentilationEnums.CallbackAction.REPORT_STATUS,
+                                     payload={'external_id': external_id,
+                                              'mode': mode,
+                                              'level': level,
+                                              'remaining_time': remaining_time,
+                                              'last_seen': last_seen})
+
+    def attach_set_auto(self, handler, version=1):
+        # type: (Callable[[str], Any], int) -> None
+        """ Expected definition: handler([self,] external_id) """
+        self._attach_action(action=_VentilationEnums.Action.SET_AUTO,
+                            handler=handler,
+                            version=version)
+
+    def attach_set_manual(self, handler, version=1):
+        # type: (Callable[[str, int, Optional[float]], Any], int) -> None
+        """ Expected definition: handler([self,] external_id, level, timer) """
+        self._attach_action(action=_VentilationEnums.Action.SET_MANUAL,
+                            handler=handler,
+                            version=version)
diff --git a/src/plugin_runtime/decorators.py b/src/plugin_runtime/decorators.py
index f8bb866a..51f18430 100644
--- a/src/plugin_runtime/decorators.py
+++ b/src/plugin_runtime/decorators.py
@@ -16,235 +16,85 @@
 
 from __future__ import absolute_import
 import inspect
-import logging
 
 
-logger = logging.getLogger(__name__)
-
-
-def input_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive input status messages.
-    The receiving method should accept one parameter, a tuple of (input, output).
-    Each time an input changes status, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on input status messages.
-
-    Initially only presses (rising edges) of input signals were handled, a version was introduced to support all
-    input status changes, both falling and rising edges.
-    """
-    if method is not None:
-        method.input_status = {'version': 1}
-        return method
-
+def _fill_version(field, version, method=None):
     def wrapper(_method):
-        _method.input_status = {'version': version}
+        setattr(_method, field, {'version': version})
         return _method
-    return wrapper
-
 
-def output_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive output status messages.
+    if method is not None:
+        return wrapper(method)
+    return wrapper
 
-    Version 1
-    The receiving method should accept one parameter, a list of tuples (output, dimmer value).
-    Each time an output status is changed, the method will be called.
 
-    Version 2
-    The receiving method should accept output_event data, only the output that has changed will be sent
-    sample data:  {'id': 1, 'status': {'on': True, 'value': 5}, 'location': {'room_id': 5}}
+def input_status(method=None, version=1):
+    return _fill_version(field='input_status',
+                         version=version,
+                         method=method)
 
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on output status messages.
-    """
-    if method is not None:
-        method.output_status = {'version': 1}
-        return method
 
-    def wrapper(_method):
-        _method.output_status = {'version': version}
-        return _method
-    return wrapper
+def output_status(method=None, version=1):
+    return _fill_version(field='output_status',
+                         version=version,
+                         method=method)
 
 
 def shutter_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive shutter status messages.
-    The receiving method should accept one parameter, the list of shutter states.
-    Each time an shutter status is changed, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on shutten status messages.
-    """
-    # if the method requires more than one arg, it needs detail
-    def needs_detail(method):
+    if method is not None:
         args, varargs, kwargs, _ = inspect.getargspec(method)
-        args.pop(0)
-        return len(args) > 1 or (varargs is not None and len(varargs) >= 1) or kwargs is not None
-
-    if method is not None:  # no version was given
-        needs_detail = needs_detail(method)
-        # make it version 2 if add_detail was set (used for backwards compatibility)
-        # ideally plugins should just use @shutter_status(version=2)
-        method.shutter_status = {'version': 2 if needs_detail else 1}
-        return method
-
-    def wrapper(_method):
-        _method.shutter_status = {'version': version}
-        return _method
-    return wrapper
+        args.pop(0)  # Remove `self`
+        needs_detail = len(args) > 1 or (varargs is not None and len(varargs) >= 1) or kwargs is not None
+        version = 2 if needs_detail else 1
+    return _fill_version(field='shutter_status',
+                         version=version,
+                         method=method)
 
 
 def ventilation_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive ventilation status messages.
-    The receiving method should accept one parameter, the list of ventilation states.
-    Each time an ventilation status is changed, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on shutten status messages.
-    """
-    if method is not None:
-        method.ventilation_status = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.ventilation_status = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='ventilation_status',
+                         version=version,
+                         method=method)
 
 
 def thermostat_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive thermostat status messages.
-    The receiving method should accept one parameter, the list of thermostat states.
-    Each time a thermostat status is changed, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on shutten status messages.
-    """
-    if method is not None:
-        method.thermostat_status = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.thermostat_status = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='thermostat_status',
+                         version=version,
+                         method=method)
 
 
 def thermostat_group_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive thermostat status messages.
-    The receiving method should accept one parameter, the list of thermostat states.
-    Each time a thermostat status is changed, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on shutten status messages.
-    """
-    if method is not None:
-        method.thermostat_group_status = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.thermostat_group_status = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='thermostat_group_status',
+                         version=version,
+                         method=method)
 
 
 def sensor_status(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive sensor status messages.
-
-    The receiving method should accept sensor_event data, only the sensor that has changed will be sent
-    sample data:  {'id': 1, 'value': 20.5, 'timestamp': 164434668.79582}
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on sensor status messages.
-    """
-    if method is not None:
-        method.sensor_status = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.sensor_status = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='sensor_status',
+                         version=version,
+                         method=method)
 
 
 def receive_events(method=None, version=1):
-    """
-    Decorator to indicate that the method should receive event messages.
-    The receiving method should accept one parameter: the event code.
-    Each time an event is triggered, the method will be called.
-
-    Important! This method should not block, as this will result in an unresponsive system.
-    Please use a separate thread to perform complex actions on event messages.
-    """
-    if method is not None:
-        method.receive_events = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.receive_events = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='receive_events',
+                         version=version,
+                         method=method)
 
 
 def background_task(method=None, version=1):
-    """
-    Decorator to indicate that the method is a background task. A thread running this
-    background task will be started on startup.
-    """
-    if method is not None:
-        method.background_task = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.background_task = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='background_task',
+                         version=version,
+                         method=method)
 
 
 def on_remove(method=None, version=1):
-    """
-    Decorator to indicate that the method should be called just before removing the plugin.
-    This can be used to cleanup files written by the plugin. Note: the plugin package and plugin
-    configuration data will be removed automatically and should not be touched by this method.
-    """
-    if method is not None:
-        method.on_remove = {'version': 1}
-        return method
-
-    def wrapper(_method):
-        _method.on_remove = {'version': version}
-        return _method
-    return wrapper
+    return _fill_version(field='on_remove',
+                         version=version,
+                         method=method)
 
 
 def om_expose(method=None, auth=True, content_type='application/json', version=1):
-    """
-    Decorator to expose a method of the plugin class through the
-    webinterface. The url will be /plugins/<plugin-name>/<method>.
-
-    Normally an authentication token is required to access the method.
-    The token will be checked and removed automatically when using the
-    following construction:
-
-    @om_expose
-    def method_to_expose(self, ...):
-        pass
-
-    It is possible to expose a method without authentication: no token
-    will be required to access the method, this is done as follows:
-
-    @om_expose(auth=False)
-    def method_to_expose(self, ...):
-        pass
-    """
-    def decorate(_method):
+    def wrapper(_method):
         _method.om_expose = {'method': _method,
                              'auth': auth,
                              'content_type': content_type,
@@ -252,35 +102,26 @@ def om_expose(method=None, auth=True, content_type='application/json', version=1
         return _method
 
     if method is not None:
-        return decorate(method)
-    return decorate
+        return wrapper(method)
+    return wrapper
 
 
 def om_metric_data(interval=5):
-    """
-    Decorator to indicate that the method should be called periodically to retrieve metrics
-    provided by the plugin.
-    """
     try:
         interval = int(interval)
     except ValueError:
         interval = 5
 
-    def decorate(method):
-        method.om_metric_data = {'interval': interval}
-        return method
-    return decorate
+    def wrapper(_method):
+        _method.om_metric_data = {'interval': interval}
+        return _method
+    return wrapper
 
 
 def om_metric_receive(source=None, metric_type=None, interval=None):
-    """
-    Decorator to indicate that the decorated method should be called when new data mathing the
-    filter is available.
-    """
-    def decorate(method):
-        """ The decorated method. """
-        method.om_metric_receive = {'source': source,
-                                    'metric_type': metric_type,
-                                    'interval': interval}
-        return method
-    return decorate
+    def wrapper(_method):
+        _method.om_metric_receive = {'source': source,
+                                     'metric_type': metric_type,
+                                     'interval': interval}
+        return _method
+    return wrapper
diff --git a/src/plugin_runtime/runtime.py b/src/plugin_runtime/runtime.py
index 159cc864..33add1ee 100644
--- a/src/plugin_runtime/runtime.py
+++ b/src/plugin_runtime/runtime.py
@@ -15,64 +15,86 @@ System.import_libs()
 import constants
 import six
 from gateway.daemon_thread import BaseThread
-from gateway.events import GatewayEvent
+from gateway.enums import PluginActionEnums as ActionEnums, MetricsEnums
+from gateway.dto import PluginActionDTO as ActionDTO, PluginStatusEvent
 from plugin_runtime import base
 from plugin_runtime.base import PluginWebRequest, PluginWebResponse
+from plugin_runtime.connectors.connector import Connector
 from plugin_runtime.interfaces import has_interface
 from plugin_runtime.utils import get_plugin_class, check_plugin, get_special_methods
 from plugin_runtime.web import WebInterfaceDispatcher
 from six.moves.configparser import ConfigParser, NoSectionError, NoOptionError
-from toolbox import PluginIPCReader, PluginIPCWriter, Toolbox
-
-logger = logging.getLogger(__name__)
+from logs import Logs
+from toolbox import PluginIPCCommunicator, Toolbox
 
 if False:  # MYPY
-    from typing import Any, Callable, Dict, List, Optional, Union
+    from typing import Any, Callable, Dict, List, Optional
+
+global_logger = logging.getLogger(__name__)
 
 
 class PluginRuntime(object):
 
-    SUPPORTED_DECORATOR_VERSIONS = {'input_status': [1, 2],
+    # This version mapping should not be updated anymore! All future data format
+    # changes must be implemented in the respective connectors.
+    SUPPORTED_DECORATOR_VERSIONS = {'receive_events': [1],
+                                    'background_task': [1],
+                                    'on_remove': [1],
+                                    'input_status': [1, 2],
                                     'output_status': [1, 2],
                                     'shutter_status': [1, 2, 3],
                                     'thermostat_status': [1],
                                     'thermostat_group_status': [1],
                                     'ventilation_status': [1],
-                                    'sensor_status': [1],
-                                    'receive_events': [1],
-                                    'background_task': [1],
-                                    'on_remove': [1]}
+                                    'sensor_status': [1]}
+
+    CONNECTOR_DECORATORS = {'input_status': ActionEnums.StatusEventType.INPUT_CHANGE,
+                            'output_status': ActionEnums.StatusEventType.OUTPUT_CHANGE,
+                            'shutter_status': ActionEnums.StatusEventType.SHUTTER_CHANGE,
+                            'thermostat_status': ActionEnums.StatusEventType.THERMOSTAT_CHANGE,
+                            'thermostat_group_status': ActionEnums.StatusEventType.THERMOSTAT_GROUP_CHANGE,
+                            'ventilation_status': ActionEnums.StatusEventType.VENTILATION_CHANGE,
+                            'sensor_status': ActionEnums.StatusEventType.SENSOR_CHANGE}
+    DEPRECATED_DECORATORS = {'on_remove': 'Override the `on_remove` method from OMPluginBase'}
 
     def __init__(self, path):
         # type: (str) -> None
         self._stopped = False
         self._path = path.rstrip('/')
 
-        self._decorated_methods = {'input_status': [],
-                                   'output_status': [],
-                                   'shutter_status': [],
-                                   'thermostat_status': [],
-                                   'thermostat_group_status': [],
-                                   'ventilation_status': [],
-                                   'sensor_status': [],
-                                   'receive_events': [],
+        self._decorated_methods = {'receive_events': [],
                                    'background_task': [],
-                                   'on_remove': []}  # type: Dict[str,List[Any]]
+                                   'on_remove': []}  # type: Dict[str, List[Any]]
 
         self._name = None
         self._version = None
         self._interfaces = []  # type: List[Any]
         self._exposes = []  # type: List[Any]
         self._metric_definitions = []  # type: List[Any]
-        self._metric_collectors = []  # type: List[Any]
-        self._metric_receivers = []  # type: List[Any]
 
         self._plugin = None
-        self._writer = PluginIPCWriter(os.fdopen(sys.stdout.fileno(), 'wb', 0))
-        self._reader = PluginIPCReader(os.fdopen(sys.stdin.fileno(), 'rb', 0),
-                                       self._writer.log_exception)
-
+        self._connector = Connector(forward_callback_actions=self._forward_callback_actions,
+                                    forward_status_event_subscriptions=self._forward_status_event_subscriptions)
+        # The re-opening of the stdin/stdout devices below are required for the tests to work
+        self._ipc = PluginIPCCommunicator(input_stream=os.fdopen(sys.stdin.fileno(), 'rb', 0),
+                                          output_stream=os.fdopen(sys.stdout.fileno(), 'wb', 0),
+                                          name='plugin',
+                                          side=PluginIPCCommunicator.Side.PLUGIN,
+                                          request_processor=self._request_processor)  # type: PluginIPCCommunicator
         self._webinterface = None  # type: Optional[WebInterfaceDispatcher]
+        Logs.setup_plugin_runtime_logging(log_function=self._log_to_ipc)
+
+    def run(self):
+        self._ipc.start()
+        self._handle_start()
+        while not self._stopped:
+            time.sleep(0.5)
+
+    def _log_to_ipc(self, message, level):
+        self._ipc.write(payload=ActionDTO(action=ActionEnums.Action.LOGS,
+                                          payload={'message': str(message),
+                                                   'level': level}),
+                        timeout=0.0)
 
     def _init_plugin(self):
         # type: () -> None
@@ -104,19 +126,53 @@ class PluginRuntime(object):
         self._name = plugin_class.name
         self._version = plugin_class.version
         self._interfaces = plugin_class.interfaces
-        self._webinterface = WebInterfaceDispatcher(self._writer.log,
-                                                    self._name,
+        self._webinterface = WebInterfaceDispatcher(plugin_name=self._name,
                                                     port=http_port)
 
         # Initialze the plugin
-        self._plugin = plugin_class(self._webinterface, self._writer.log)
-
+        kwargs = {}  # type: Dict[str, Any]
+        parameter_names = Toolbox.get_parameter_names(plugin_class.__init__)
+        generic_init = (parameter_names == ['self', 'args', 'kwargs'] or
+                        parameter_names == ['self', 'kwargs'])
+        if 'webinterface' in parameter_names or generic_init:
+            kwargs['webinterface'] = self._webinterface
+        for key in ('logger', 'gateway_logger'):
+            if key in parameter_names or generic_init:
+                kwargs[key] = lambda m: self._log_to_ipc(message=m, level=logging.INFO)
+        if 'connector' in parameter_names or generic_init:
+            kwargs['connector'] = self._connector
+        self._plugin = plugin_class(**kwargs)
+
+        # Legacy decorators
+        used_decorators = set()
         for decorator_name, decorated_methods in six.iteritems(self._decorated_methods):
-            for decorated_method, decorator_version in get_special_methods(self._plugin, decorator_name):
-                # only add if supported, raise if an unsupported version is found
+            for decorated_method, decorator_version in get_special_methods(plugin_object=self._plugin,
+                                                                           decorator_name=decorator_name):
+                # Only add if supported, raise if an unsupported version is found
+                if decorator_version not in PluginRuntime.SUPPORTED_DECORATOR_VERSIONS[decorator_name]:
+                    raise NotImplementedError('Decorator {0} version {1} is not supported'.format(decorator_name, decorator_version))
+                used_decorators.add(decorator_name)
+                decorated_methods.append(decorated_method)
+        for decorator_name in used_decorators:
+            if decorator_name in PluginRuntime.DEPRECATED_DECORATORS:
+                message = PluginRuntime.DEPRECATED_DECORATORS[decorator_name]
+                global_logger.warning('The `{0}` decorator is deprecated. {1}'.format(decorator_name, message))
+
+        # Connector related decorators
+        used_decorators = set()
+        for decorator_name, event_type in six.iteritems(PluginRuntime.CONNECTOR_DECORATORS):
+            for decorated_method, decorator_version in get_special_methods(plugin_object=self._plugin,
+                                                                           decorator_name=decorator_name):
                 if decorator_version not in PluginRuntime.SUPPORTED_DECORATOR_VERSIONS[decorator_name]:
-                    raise NotImplementedError('Decorator {} version {} is not supported'.format(decorator_name, decorator_version))
-                decorated_methods.append(decorated_method)  # add the decorated method to the list
+                    global_logger.error('Decorator `{0}` version `{1}` is not supported'.format(decorator_name, decorator_version))
+                    continue
+                self._connector._subscribe_for_type(event_type=event_type,
+                                                    handler=decorated_method,
+                                                    version=decorator_version)
+                used_decorators.add(decorator_name)
+        # TODO: Deprecate decorators in favor of connectors when needed
+        # for decorator_name in used_decorators:
+        #     global_logger.warning('The `{0}` decorator is deprecated. Use the connector instead'.format(decorator_name))
 
         # Set the exposed methods
         for decorated_method, _ in get_special_methods(self._plugin, 'om_expose'):
@@ -125,17 +181,18 @@ class PluginRuntime(object):
                                   'content_type': decorated_method.om_expose['content_type'],
                                   'version': decorated_method.om_expose['version']})
 
-        # Set the metric collectors
-        for decorated_method, _ in get_special_methods(self._plugin, 'om_metric_data'):
-            self._metric_collectors.append({'name': decorated_method.__name__,
-                                            'interval': decorated_method.om_metric_data['interval']})
-
-        # Set the metric receivers
+        # Attach metric related decorators to connector
+        used_decorators = set()
         for decorated_method, _ in get_special_methods(self._plugin, 'om_metric_receive'):
-            self._metric_receivers.append({'name': decorated_method.__name__,
-                                           'source': decorated_method.om_metric_receive['source'],
-                                           'metric_type': decorated_method.om_metric_receive['metric_type'],
-                                           'interval': decorated_method.om_metric_receive['interval']})
+            used_decorators.add('om_metric_receive')
+            self._connector.metrics.attach_metrics_subscription(handler=decorated_method,
+                                                                source=decorated_method.om_metric_receive['source'],
+                                                                metric_type=decorated_method.om_metric_receive['metric_type'],
+                                                                interval=decorated_method.om_metric_receive['interval'],
+                                                                version=1)
+        # TODO: Deprecate decorators in favor of connectors when needed
+        # for decorator_name in used_decorators:
+        #     global_logger.warning('The `{0}` decorator is deprecated. Use the connector instead'.format(decorator_name))
 
         # Set the metric definitions
         if has_interface(plugin_class, 'metrics', '1.0'):
@@ -150,17 +207,18 @@ class PluginRuntime(object):
             thread.daemon = True
             thread.start()
 
-    def get_decorators_in_use(self):
-        registered_decorators = {}
-        for decorator_name, decorated_methods in six.iteritems(self._decorated_methods):
-            decorator_versions_in_use = set()
-            for decorated_method in decorated_methods:
-                decorator_version = getattr(decorated_method, decorator_name).get('version', 1)
-                decorator_versions_in_use.add(decorator_version)
-            registered_decorators[decorator_name] = list(decorator_versions_in_use)
+    def _start_metric_tasks(self):
+        # type: () -> None
+        if self._metric_definitions:
+            used_decorators = set()
+            for decorated_method, _ in get_special_methods(self._plugin, 'om_metric_data'):
+                used_decorators.add('om_metric_data')
+                self._connector.metrics._attach_collector(handler=decorated_method,
+                                                          interval=decorated_method.om_metric_data['interval'])
+            # TODO: Deprecate decorators in favor of connectors when needed
+            # for decorator_name in used_decorators:
+            #     global_logger.warning('The `{0}` decorator is deprecated. Use the connector instead'.format(decorator_name))
 
-        # something in the form of e.g. {'output_status': [1,2], 'input_status': [1]} where 1,2,... are the versions
-        return registered_decorators
 
     def _run_background_task(self, task):
         # type: (Callable[[],None]) -> None
@@ -170,209 +228,104 @@ class PluginRuntime(object):
                 task()
                 running = False  # Stop execution if the task returns without exception
             except Exception as exception:
-                self._writer.log_exception('background task', exception)
+                global_logger.exception('Background task exception: {0}'.format(exception))
                 time.sleep(30)
 
-    def process_stdin(self):
-        # type: () -> None
-        self._reader.start()
-        while not self._stopped:
-            command = self._reader.get(block=True)
-            if command is None:
-                continue
-
-            action = command['action']
-            action_version = command['action_version']
-            response = {'cid': command['cid'], 'action': action}
-            try:
-                ret = None
-                if action == 'start':
-                    ret = self._handle_start()
-                elif action == 'stop':
-                    ret = self._handle_stop()
-                elif action == 'input_status':
-                    # v1 = state, v2 = event
-                    if action_version == 1:
-                        ret = self._handle_input_status(command['status'], data_type='status')
-                    else:
-                        ret = self._handle_input_status(command['event'], data_type='event')
-                elif action == 'output_status':
-                    # v1 = state, v2 = event
-                    if action_version == 1:
-                        ret = self._handle_output_status(command['status'], data_type='status')
-                    else:
-                        ret = self._handle_output_status(command['event'], data_type='event')
-                elif action == 'ventilation_status':
-                    ret = self._handle_ventilation_status(command['event'])
-                elif action == 'thermostat_status':
-                    ret = self._handle_thermostat_status(command['event'])
-                elif action == 'thermostat_group_status':
-                    ret = self._handle_thermostat_group_status(command['event'])
-                elif action == 'shutter_status':
-                    # v1 = state as list, v2 = state as dict, v3 = event
-                    if action_version == 1:
-                        ret = self._handle_shutter_status(command['status'], data_type='status')
-                    elif action_version == 2:
-                        ret = self._handle_shutter_status(command['status'], data_type='status_dict')
-                    else:
-                        ret = self._handle_shutter_status(command['event'], data_type='event')
-                elif action == 'sensor_status':
-                    ret = self._handle_sensor_status(command['event'])
-                elif action == 'receive_events':
-                    ret = self._handle_receive_events(command['code'])
-                elif action == 'get_metric_definitions':
-                    ret = self._handle_get_metric_definitions()
-                elif action == 'collect_metrics':
-                    ret = self._handle_collect_metrics(command['name'])
-                elif action == 'distribute_metrics':
-                    ret = self._handle_distribute_metrics(command['name'], command['metrics'])
-                elif action == 'request':
-                    ret = self._handle_request(command['method'], command['args'], command['kwargs'])
-                elif action == 'remove_callback':
-                    ret = self._handle_remove_callback()
-                elif action == 'ping':
-                    pass  # noop
-                else:
-                    raise RuntimeError('Unknown action: {0}'.format(action))
-
-                if ret is not None:
-                    response.update(ret)
-            except Exception as exception:
-                response['_exception'] = str(exception)
-            self._writer.write(response)
+    def _request_processor(self, action_dto):
+        # type: (ActionDTO) -> Any
+        action = action_dto.action
+        payload = action_dto.payload
+
+        # Legacy master `EV` event  # TODO: Should be deprecated in the future
+        if action == ActionEnums.Action.RECEIVE_EVENTS:
+            assert isinstance(payload, dict), 'Payload should be a dict'
+            return self._handle_receive_events(code=payload['code'])
+
+        # API
+        if action == ActionEnums.Action.REQUEST:
+            assert isinstance(payload, dict), 'Payload should be a dict'
+            return self._handle_request(method=payload['method'],
+                                        args=payload['args'],
+                                        kwargs=payload['kwargs'])
+
+        # Connector actions
+        if action in ActionEnums.CONNECTOR_ACTIONS:
+            assert isinstance(payload, dict), 'Payload should be a dict'
+            assert self._connector, 'Connector not initialized'
+            return self._connector._distribute_action(action=action,
+                                                      payload=payload)
+
+        # Connector events
+        if action == ActionEnums.Action.PROCESS_STATUS_EVENT:
+            assert isinstance(payload, PluginStatusEvent), 'Payload should be a PluginStatusEvent'
+            if payload.type in ActionEnums.STATUS_EVENT_TYPES:
+                assert self._connector, 'Connector not initialized'
+                return self._connector._distribute_status_event(event=payload)
+
+        # Technical
+        if action == ActionEnums.Action.START:
+            return self._handle_start()
+        if action == ActionEnums.Action.STOP:
+            return self._handle_stop()
+        if action == ActionEnums.Action.REMOVE:
+            return self._handle_remove()
+        if action == ActionEnums.Action.PING:
+            return None
+
+        raise RuntimeError('Unknown action: {0}'.format(action))
+
+    # Technical
 
     def _handle_start(self):
         # type: () -> Dict[str,Any]
-        """ Handles the start command. Cover exceptions manually to make sure as much metadata is returned as possible. """
-        data = {}  # type: Dict[str,Any]
-        try:
-            self._init_plugin()
-            self._start_background_tasks()
-        except Exception as exception:
-            data['exception'] = str(exception)
-        data.update({'name': self._name,
-                     'version': self._version,
-                     'decorators': self.get_decorators_in_use(),
-                     'exposes': self._exposes,
-                     'interfaces': self._interfaces,
-                     'metric_collectors': self._metric_collectors,
-                     'metric_receivers': self._metric_receivers})
-        return data
+        self._init_plugin()
+        self._start_background_tasks()
+        self._start_metric_tasks()
+        return {'name': self._name,
+                'version': self._version,
+                'exposes': self._exposes,
+                'interfaces': self._interfaces,
+                'metric_definitions': self._metric_definitions}
 
     def _handle_stop(self):
-
         def delayed_stop():
-            time.sleep(2)
+            time.sleep(1)
             os._exit(0)
 
         stop_thread = BaseThread(name='pluginstop', target=delayed_stop)
         stop_thread.daemon = True
         stop_thread.start()
 
+        if self._connector:
+            self._connector._stop()
         self._stopped = True
 
-    def _handle_input_status(self, data, data_type='status'):
-        event = GatewayEvent.deserialize(data) if data_type == 'event' else None
-        for decorated_method in self._decorated_methods['input_status']:
-            decorator_version = decorated_method.input_status.get('version', 1)
-            if decorator_version not in PluginRuntime.SUPPORTED_DECORATOR_VERSIONS['input_status']:
-                error = NotImplementedError('Version {} is not supported for input status decorators'.format(decorator_version))
-                self._writer.log_exception('input status', error)
-            else:
-                if decorator_version == 1 and data_type == 'status':
-                    self._writer.with_catch('input status', decorated_method, [data])
-                elif decorator_version == 2 and event is not None:
-                    # get relevant event details
-                    input_id = event.data['id']
-                    status = event.data['status']
-                    # Version 2 will send ALL input status changes AND in a dict format
-                    self._writer.with_catch('input status', decorated_method, [{'input_id': input_id, 'status': status}])
-
-    def _handle_output_status(self, data, data_type='status'):
-        event = GatewayEvent.deserialize(data) if data_type == 'event' else None
-        for decorated_method in self._decorated_methods['output_status']:
-            decorator_version = decorated_method.output_status.get('version', 1)
-            if decorator_version not in PluginRuntime.SUPPORTED_DECORATOR_VERSIONS['output_status']:
-                error = NotImplementedError('Version {} is not supported for output status decorators'.format(decorator_version))
-                self._writer.log_exception('output status', error)
-            else:
-                if decorator_version == 1 and data_type == 'status':
-                    self._writer.with_catch('output status', decorated_method, [data])
-                elif decorator_version == 2 and event is not None:
-                    self._writer.with_catch('output status', decorated_method, [event.data])
-
-    def _handle_ventilation_status(self, data):
-        event = GatewayEvent.deserialize(data)
-        for receiver in self._decorated_methods['ventilation_status']:
-            self._writer.with_catch('ventilation status', receiver, [event.data])
-
-    def _handle_thermostat_status(self, data):
-        event = GatewayEvent.deserialize(data)
-        for receiver in self._decorated_methods['thermostat_status']:
-            self._writer.with_catch('thermostat status', receiver, [event.data])
-
-    def _handle_thermostat_group_status(self, data):
-        event = GatewayEvent.deserialize(data)
-        for receiver in self._decorated_methods['thermostat_group_status']:
-            self._writer.with_catch('thermostat group status', receiver, [event.data])
-
-    def _handle_shutter_status(self, data, data_type='status'):
-        event = GatewayEvent.deserialize(data) if data_type == 'event' else None
-        for receiver in self._decorated_methods['shutter_status']:
-            decorator_version = receiver.shutter_status.get('version', 1)
-            if decorator_version not in PluginRuntime.SUPPORTED_DECORATOR_VERSIONS['shutter_status']:
-                error = NotImplementedError('Version {} is not supported for shutter status decorators'.format(decorator_version))
-                self._writer.log_exception('shutter status', error)
-            else:
-                if decorator_version == 1 and data_type == 'status':
-                    self._writer.with_catch('shutter status', receiver, [data])
-                elif decorator_version == 2 and data_type == 'status_dict':
-                    self._writer.with_catch('shutter status', receiver, [data['status'], data['detail']])
-                elif decorator_version == 3 and event:
-                    self._writer.with_catch('shutter status', receiver, [event.data])
-
-    def _handle_sensor_status(self, data):
-        event = GatewayEvent.deserialize(data)
-        for receiver in self._decorated_methods['sensor_status']:
-            self._writer.with_catch('sensor status', receiver, [event.data])
+    def _handle_remove(self):
+        if self._plugin is not None and hasattr(self._plugin, 'on_remove'):
+            self._plugin.on_remove()
 
-    def _handle_receive_events(self, code):
-        for receiver in self._decorated_methods['receive_events']:
-            decorator_version = receiver.receive_events.get('version', 1)
-            if decorator_version == 1:
-                self._writer.with_catch('process event', receiver, [code])
-            else:
-                error = NotImplementedError('Version {} is not supported for receive events decorators'.format(decorator_version))
-                self._writer.log_exception('receive events', error)
-
-    def _handle_remove_callback(self):
+        # TODO: Below code should be deprecated in favor of the `on_remove` method above
         for decorated_method in self._decorated_methods['on_remove']:
             decorator_version = decorated_method.on_remove.get('version', 1)
             if decorator_version == 1:
                 try:
                     decorated_method()
                 except Exception as exception:
-                    self._writer.log_exception('on remove', exception)
+                    global_logger.exception('Error during on_remove: {0}'.format(exception))
             else:
-                error = NotImplementedError('Version {} is not supported for shutter status decorators'.format(decorator_version))
-                self._writer.log_exception('on remove', error)
+                global_logger.error('Version {0} is not supported for on remove decorators'.format(decorator_version))
 
-    def _handle_get_metric_definitions(self):
-        return {'metric_definitions': self._metric_definitions}
+    # Legacy master `EV` event.
 
-    def _handle_collect_metrics(self, name):
-        metrics = []
-        collect = getattr(self._plugin, name)
-        try:
-            metrics.extend(list(collect()))
-        except Exception as exception:
-            self._writer.log_exception('collect metrics', exception)
-        return {'metrics': metrics}
+    def _handle_receive_events(self, code):
+        for receiver in self._decorated_methods['receive_events']:
+            decorator_version = receiver.receive_events.get('version', 1)
+            if decorator_version == 1:
+                receiver(code)
+            else:
+                global_logger.error('Version {0} is not supported for receive events decorators'.format(decorator_version))
 
-    def _handle_distribute_metrics(self, name, metrics):
-        receive = getattr(self._plugin, name)
-        for metric in metrics:
-            self._writer.with_catch('distribute metric', receive, [metric])
+    # Handle plugin API requests
 
     def _handle_request(self, method, args, kwargs):
         func = getattr(self._plugin, method)
@@ -384,34 +337,34 @@ class PluginRuntime(object):
         requested_parameters = set(Toolbox.get_parameter_names(func)) - {'self'}
         difference = set(passed_parameters) - requested_parameters
         if difference and web_request.version == 1:
-            # Analog error message as the default CherryPy behavior
-            return {'success': False, 'exception': 'Unexpected query string parameters: {0}'.format(', '.join(difference))}
+            raise RuntimeError('Unexpected query string parameters: {0}'.format(', '.join(difference)))
         difference = requested_parameters - (set(passed_parameters) | {'request_body'})
         if difference:
-            # Analog error message as the default CherryPy behavior
-            return {'success': False, 'exception': 'Missing parameters: {0}'.format(', '.join(difference))}
-        try:
-            to_pass_arguments = {}  # type: Dict[str, Any]
-            for req_param in requested_parameters:
-                if req_param == 'plugin_web_request':
-                    to_pass_arguments[req_param] = web_request
-                elif req_param == 'request_body':
-                    to_pass_arguments[req_param] = web_request.body
-                else:
-                    to_pass_arguments[req_param] = web_request.params[req_param]
-            func_return = func(*args, **to_pass_arguments)
-            try:
-                if isinstance(func_return, PluginWebResponse):
-                    serialized_func_return = func_return.serialize()
-                else:
-                    serialized_func_return = PluginWebResponse(status_code=200, body=func_return, version=web_request.version).serialize()
-            except AttributeError as ex:
-                error_msg = "[RUNTIME] Could not serialize the returned object for function call {} with return data: {}".format(method, func_return)
-                self._writer.log(error_msg)
-                return {'success': False, 'exception': str(error_msg)}
-            return {'success': True, 'response': serialized_func_return}
-        except Exception as exception:
-            return {'success': False, 'exception': str(exception), 'stacktrace': traceback.format_exc()}
+            raise RuntimeError('Missing parameters: {0}'.format(', '.join(difference)))
+        function_kwargs = {}  # type: Dict[str, Any]
+        for req_param in requested_parameters:
+            if req_param == 'plugin_web_request':
+                function_kwargs[req_param] = web_request
+            elif req_param == 'request_body':
+                function_kwargs[req_param] = web_request.body
+            else:
+                function_kwargs[req_param] = web_request.params[req_param]
+        return_data = func(*args, **function_kwargs)
+        if isinstance(return_data, PluginWebResponse):
+            serialized_func_return = return_data.serialize()
+        else:
+            serialized_func_return = PluginWebResponse(status_code=200, body=return_data, version=web_request.version).serialize()
+        return serialized_func_return
+
+    def _forward_callback_actions(self, action, payload):
+        action_dto = ActionDTO(action=action,
+                               payload=payload)
+        return self._ipc.write(payload=action_dto)
+
+    def _forward_status_event_subscriptions(self, types):
+        action_dto = ActionDTO(action=ActionEnums.Action.SUBSCRIBE_STATUS_EVENT,
+                               payload=types)
+        return self._ipc.write(payload=action_dto)
 
 
 def start_runtime(plugin_location=None):
@@ -437,13 +390,8 @@ def start_runtime(plugin_location=None):
     watcher.start()
 
     # Start the runtime
-    try:
-        runtime = PluginRuntime(path=plugin_location)
-        runtime.process_stdin()
-    except BaseException as ex:
-        writer = PluginIPCWriter(os.fdopen(sys.stdout.fileno(), 'wb', 0))
-        writer.log_exception('__main__', ex)
-        os._exit(1)
+    runtime = PluginRuntime(path=plugin_location)
+    runtime.run()
 
     os._exit(0)
 
diff --git a/src/plugin_runtime/sdk.py b/src/plugin_runtime/sdk.py
deleted file mode 100644
index d071579f..00000000
--- a/src/plugin_runtime/sdk.py
+++ /dev/null
@@ -1,102 +0,0 @@
-from __future__ import absolute_import
-
-import requests
-import ujson as json
-
-from gateway.dto.sensor import SensorDTO, SensorStatusDTO
-from gateway.dto.ventilation import VentilationDTO, VentilationStatusDTO
-
-if False:  # MYPY
-    from typing import Any, Dict
-
-
-
-class BaseSDK(object):
-    def __init__(self, base_url, plugin_name):
-        self._base_url = base_url
-        self._plugin_name = plugin_name
-        self._request_kwargs = {
-            'timeout': 30.0,
-            'headers': {'User-Agent': 'Plugin {0}'.format(self._plugin_name)}
-        }  # type: Dict[str,Any]
-
-    def _api(self, method, path, **kwargs):
-        kwargs.update(self._request_kwargs)
-        response = requests.request(method, '{0}/{1}'.format(self._base_url, path.strip('/')), **kwargs)
-        response.raise_for_status()
-        return response.json()
-
-
-class NotificationSDK(BaseSDK):
-    def send(self, topic, message, type='USER'):
-        data = {'source': 'plugin',
-                'plugin': self._plugin_name,
-                'type': type,
-                'topic': topic,
-                'message': message}
-        self._api('POST', '/plugin/notification', json=data)
-
-
-class SensorSDK(BaseSDK):
-    def register_temperature_celcius(self, external_id, config=None):
-        return self.register(external_id, 'temperature', 'celcius', config)
-
-    def register_humidity_percent(self, external_id, config=None):
-        return self.register(external_id, 'humidity', 'percent', config)
-
-    def register_co2_ppm(self, external_id, config=None):
-        return self.register(external_id, 'co2', 'parts_per_million', config)
-
-    def register(self, external_id, physical_quantity, unit, config=None):
-        data = {'source': 'plugin',
-                'plugin': self._plugin_name,
-                'external_id': external_id,
-                'physical_quantity': physical_quantity,
-                'unit': unit,
-                'config': config or {}}
-        data = self._api('POST', '/plugin/sensor/register', json=data)
-        return SensorDTO(data['id'], external_id=external_id)
-
-    def set_status(self, sensor_id, value):
-        status = {'id': sensor_id, 'value': value}
-        # TODO replace with proper sensor api
-        data = self._api('POST', '/set_sensor_status', params={'status': json.dumps(status)})
-        if data.get('success', False) is True:
-            return SensorStatusDTO(data['status']['id'],
-                                   value=data['status']['value'])
-        else:
-            return None
-
-
-class VentilationSDK(BaseSDK):
-    def register(self, external_id, config=None):
-        data = {'source': 'plugin',
-                'plugin': self._plugin_name,
-                'external_id': external_id,
-                'config': config or {}}
-        data = self._api('POST', '/plugin/ventilation/register', json=data)
-        return VentilationDTO(data['id'], external_id=external_id)
-
-    def set_auto(self, ventilation_id, **kwargs):
-        return self.set_status(ventilation_id, VentilationStatusDTO.Mode.AUTO, **kwargs)
-
-    def set_manual(self, ventilation_id, **kwargs):
-        return self.set_status(ventilation_id, VentilationStatusDTO.Mode.MANUAL, **kwargs)
-
-    def set_status(self, ventilation_id, mode, level=None, timer=None, remaining_time=None):
-        status = {'id': ventilation_id, 'mode': mode}
-        for key, value in [('level', level),
-                           ('timer', timer),
-                           ('remaining_time', remaining_time)]:
-            if value is not None:
-                status.update({key: value})
-        # TODO replace with proper ventilation api
-        data = self._api('POST', '/set_ventilation_status', params={'status': json.dumps(status)})
-        if data.get('success', False) is True:
-            return VentilationStatusDTO(data['status']['id'],
-                                        mode=data['status']['mode'],
-                                        level=data['status']['mode'],
-                                        timer=data['status']['timer'],
-                                        remaining_time=data['status']['remaining_time'])
-        else:
-            return None
diff --git a/src/plugin_runtime/web.py b/src/plugin_runtime/web.py
index 57c22ac3..04a16ef8 100644
--- a/src/plugin_runtime/web.py
+++ b/src/plugin_runtime/web.py
@@ -1,17 +1,17 @@
 from __future__ import absolute_import
 
+import logging
 import re
-
 import requests
 
-from plugin_runtime.sdk import NotificationSDK, SensorSDK, VentilationSDK
-
 try:
     import ujson as json
 except ImportError:
     # This is the case when the plugin runtime is unittested
     import json  # type: ignore
 
+global_logger = logging.getLogger(__name__)
+
 
 def _load_webinterface():
     """
@@ -40,17 +40,13 @@ def _load_webinterface():
 
 
 class WebInterfaceDispatcher(object):
-    # TODO: Use SDK in the future
+    # TODO: Replace by connector CallbackActions
 
-    def __init__(self, logger, plugin_name=None, hostname='localhost', port=80):
-        self._logger = logger
+    def __init__(self, plugin_name=None, hostname='localhost', port=80):
         self._warned = False
         self._available_calls = _load_webinterface()
         self._base_url = 'http://{0}:{1}'.format(hostname, port)
         self._plugin_name = plugin_name
-        self.notification = NotificationSDK(self._base_url, self._plugin_name)
-        self.sensor = SensorSDK(self._base_url, self._plugin_name)
-        self.ventilation = VentilationSDK(self._base_url, self._plugin_name)
 
     def __getattr__(self, attribute):
         if attribute in self._available_calls:
@@ -61,9 +57,9 @@ class WebInterfaceDispatcher(object):
 
     def warn(self):
         if self._warned is False:
-            self._logger('[W] Deprecation warning:')
-            self._logger('[W] - Plugins should not pass \'token\' to API calls')
-            self._logger('[W] - Plugins should use keyword arguments for API calls')
+            global_logger.warning('Deprecation warning:')
+            global_logger.warning('- Plugins should not pass \'token\' to API calls')
+            global_logger.warning('- Plugins should use keyword arguments for API calls')
             self._warned = True
 
     def get_wrapper(self, name):
diff --git a/src/plugins/base.py b/src/plugins/base.py
index 6605786f..e56afd31 100644
--- a/src/plugins/base.py
+++ b/src/plugins/base.py
@@ -20,24 +20,28 @@ import logging
 import os
 import pkgutil
 import traceback
-from datetime import datetime
-from threading import Lock, Timer
-
 import six
-
 import constants
+from collections import defaultdict
+from datetime import datetime
+from threading import Lock, Timer
+from gateway.dto import PluginDTO, SourceDTO, PluginStatusEvent
 from gateway.events import GatewayEvent
+from gateway.enums import PluginEnums, Source, PluginActionEnums, MetricsEnums, NotificationEnums
+from gateway.exceptions import PluginException
 from gateway.models import Config, Database, Plugin
 from ioc import INJECTED, Inject, Injectable, Singleton
 from plugins.runner import PluginRunner, RunnerWatchdog
+from gateway.pubsub import PubSub
 
 if False:  # MYPY
-    from typing import Dict, List, Optional
+    from typing import Dict, List, Optional, Any, Callable, Set
     from gateway.output_controller import OutputController
     from gateway.shutter_controller import ShutterController
     from gateway.webservice import WebInterface
 
-logger = logging.getLogger(__name__)
+
+global_logger = logging.getLogger(__name__)
 
 
 @Injectable.named('plugin_controller')
@@ -45,222 +49,241 @@ logger = logging.getLogger(__name__)
 class PluginController(object):
     """ The controller keeps track of all plugins in the system. """
 
-    DEPENDENCIES_TIMER = 30.0
-
     @Inject
     def __init__(self,
-                 web_interface=INJECTED, output_controller=INJECTED,
+                 output_controller=INJECTED,
                  shutter_controller=INJECTED,
+                 pubsub=INJECTED,
                  runtime_path=None,
-                 plugins_path=None,
-                 plugin_config_path=None):
-        # type: (WebInterface, OutputController, ShutterController, str, str, str) -> None
-        self._webinterface = web_interface
+                 plugins_path=None):
+        # type: (OutputController, ShutterController, PubSub, str, str) -> None
         self._output_controller = output_controller
         self._shuttercontroller = shutter_controller
+        self._pubsub = pubsub
         self._runtime_path = runtime_path or constants.get_plugin_runtime_dir()
         self._plugins_path = plugins_path or constants.get_plugin_dir()
         self._plugin_config_path = constants.get_plugin_config_dir()
 
         self._stopped = True
-        self._logs = {}  # type: Dict[str, List[str]]
-        self._runners = {}  # type: Dict[str, PluginRunner]
-        self._runner_watchdogs = {}  # type: Dict[str, RunnerWatchdog]
-        self._dependencies_timer = None  # type: Optional[Timer]
-        self._dependencies_lock = Lock()
+        self._runners = {}  # type: Dict[int, PluginRunner]
+        self._runner_watchdogs = {}  # type: Dict[int, RunnerWatchdog]
+
+        self._forwarding_event_subscriptions = defaultdict(lambda: set())  # type: Dict[str, Set[int]]
+
+        self.sensor_callback_action = None  # type: Optional[Callable[..., None]]
+        self.screen_callback_action = None  # type: Optional[Callable[..., None]]
+        self.metrics_callback_action = None  # type: Optional[Callable[..., None]]
+        self.ventilation_callback_action = None  # type: Optional[Callable[..., None]]
+        self.notification_callback_action = None  # type: Optional[Callable[..., None]]
 
         self._metrics_controller = None
-        self._metrics_collector = None
+
         self._web_service = None
+        self._webinterface = None
 
     def start(self):
         # type: () -> None
         """ Start the plugins and expose them via the webinterface. """
         if not self._stopped:
-            logger.error('The PluginController is already running')
+            global_logger.error('The PluginController is already running')
             return
 
-        # TODO query the orm instead, used now to initialize already installed plugins.
-        objects = pkgutil.iter_modules([self._plugins_path])  # (module_loader, name, ispkg)
-        package_names = [o[1] for o in objects if o[2]]
-
-        self._runners = {}
-        self._runner_watchdogs = {}
-        runners = []
-        for package_name in package_names:
-            runner = self._init_plugin_runner(package_name)
-            if runner is not None:
-                runners.append(runner)
+        with Database.get_session() as db:
+            plugins = db.query(Plugin).all()
+            plugin_names = [plugin.name for plugin in plugins]
+
+            # Sync reality with ORM - for backwards compatibiliy
+            found_names = []
+            modules = pkgutil.iter_modules([self._plugins_path])  # (module_loader, name, ispkg)
+            package_names = [o[1] for o in modules if o[2]]
+            for name in package_names:
+                if name not in plugin_names:
+                    global_logger.warning('Created missing plugin `{0}` in the ORM'.format(name))
+                    plugin = Plugin(name=name, version='0.0.0')
+                    db.add(plugin)
+                found_names.append(name)
+            for name in plugin_names:
+                if name not in found_names:
+                    global_logger.warning('Removed deleted plugin `{0}` from the ORM'.format(name))
+                    db.query(Plugin).filter_by(name=name).delete()
+            db.commit()
+            plugins = db.query(Plugin).all()
+
+            # Start all plugins
+            self._runners = {}
+            self._runner_watchdogs = {}
+            runners = []
+            for plugin in plugins:
+                runner = self._init_plugin_runner(plugin)
+                if runner is not None:
+                    runners.append(runner)
+
         for runner in runners:
-            self._start_plugin_runner(runner, runner.name)
+            self._start_plugin_runner(runner)
 
     def stop(self):
         # type: () -> None
-        for runner_name in list(self._runners.keys()):
-            self._destroy_plugin_runner(runner_name)
+        for runner in list(self._runners.values()):
+            self._destroy_plugin_runner(runner)
         self._stopped = True
 
     def set_metrics_controller(self, metrics_controller):
         """ Sets the metrics controller """
         self._metrics_controller = metrics_controller
 
-    def set_metrics_collector(self, metrics_collector):
-        """ Sets the metrics collector """
-        self._metrics_collector = metrics_collector
-
     def set_webservice(self, web_service):
         """ Sets the web service """
         self._web_service = web_service
 
-    def _runner_state_changed(self, runner_name, state):
-        runner = self._runners.get(runner_name)
+    def set_webinterface(self, _webinterface):
+        """ Sets the webinterface """
+        self._webinterface = _webinterface
+
+    def _runner_state_changed(self, plugin_id, state):
+        runner = self._runners.get(plugin_id)
         if runner is None:
             return
         if state == PluginRunner.State.RUNNING:
-            PluginController._update_orm(runner.name, runner.version)
-        with self._dependencies_lock:
-            if self._dependencies_timer is not None:
-                self._dependencies_timer.cancel()
-            self._dependencies_timer = Timer(PluginController.DEPENDENCIES_TIMER, self._update_dependencies)
-            self._dependencies_timer.start()
-
-    def _init_plugin_runner(self, plugin_name):
+            PluginController._update_orm(runner.plugin_id, runner.version)
+        if self._webinterface is not None and self._web_service is not None:
+            self._web_service.update_tree(self._get_cherrypy_mounts())
+        if self._metrics_controller is not None:
+            self._metrics_controller.set_plugin_definitions(runner.name, runner.metric_definitions)
+        self._publish_state(plugin_id, state)
+
+    def _publish_state(self, plugin_id, state):
+        runner = self._runners.get(plugin_id)
+        event_data = {'id': runner.plugin_id, 'name': runner.name, 'version': runner.version, 'state': state}
+        gateway_event = GatewayEvent(GatewayEvent.Types.PLUGIN_CHANGE, event_data)
+        self._pubsub.publish_gateway_event(PubSub.GatewayTopics.STATE, gateway_event)
+
+    def _get_logger_for_plugin(self, plugin_name):
+        with Database.get_session() as db:
+            plugin = db.query(Plugin).filter_by(name=plugin_name).one()
+        return self._get_plugin_runner(plugin_id=plugin.id).logger
+
+    def _init_plugin_runner(self, plugin):  # type: (Plugin) -> Optional[PluginRunner]
         """ Initializes a single plugin runner """
         try:
-            if plugin_name in self._runners.keys():
-                self.log(plugin_name, '[Runner] Could not init plugin', 'Multiple plugins with the same name found')
-                return
-            plugin_path = os.path.join(self._plugins_path, plugin_name)
-            runner = PluginRunner(name=plugin_name,
+            plugin_path = os.path.join(self._plugins_path, plugin.name)
+            runner = PluginRunner(plugin_id=plugin.id,
+                                  name=plugin.name,
                                   runtime_path=self._runtime_path,
                                   plugin_path=plugin_path,
-                                  logger=self.get_logger(plugin_name),
-                                  state_callback=self._runner_state_changed)
-            self._runners[runner.name] = runner
-            self._runner_watchdogs[runner.name] = RunnerWatchdog(runner)
+                                  state_callback=self._runner_state_changed,
+                                  action_callback=self._forward_callback_action)
+            self._runners[plugin.id] = runner
+            self._runner_watchdogs[plugin.id] = RunnerWatchdog(runner)
             return runner
         except Exception as exception:
-            self.log(plugin_name, '[Runner] Could not initialize plugin', exception)
+            global_logger.error('[Runner] Could not initialize plugin {0}: {1}'.format(plugin.name, exception))
+            return None
 
-    def _start_plugin_runner(self, runner, runner_name):
-        # type: (PluginRunner, str) -> None
+    def _start_plugin_runner(self, runner):
+        # type: (PluginRunner) -> None
         """ Starts a single plugin runner """
         watchdog = None
         try:
-            logger.info('Plugin {0}: {1}'.format(runner_name, 'Starting...'))
-            watchdog = self._runner_watchdogs.get(runner_name)
+            global_logger.info('Plugin {0}: {1}'.format(runner.name, 'Starting...'))
+            watchdog = self._runner_watchdogs.get(runner.plugin_id)
             if watchdog is not None:
                 success = watchdog.start()  # The plugin will be started by the watchdog
                 if success:
-                    PluginController._update_orm(runner.name, runner.version)
-                    logger.info('Plugin {0}: {1}'.format(runner_name, 'Starting... Done'))
+                    PluginController._update_orm(runner.plugin_id, runner.version)
+                    global_logger.info('Plugin {0}: {1}'.format(runner.name, 'Starting... Done'))
                 else:
-                    logger.error('Plugin {0}: {1}'.format(runner_name, 'Starting... Failed'))
+                    global_logger.error('Plugin {0}: {1}'.format(runner.name, 'Starting... Failed'))
         except Exception as exception:
-            logger.exception('Plugin {0}: {1}'.format(runner_name, 'Starting... Failed'))
+            global_logger.exception('Plugin {0}: {1}'.format(runner.name, 'Starting... Failed'))
             try:
                 if watchdog is not None:
                     watchdog.stop()
                 runner.stop()
             except Exception:
-                pass  # Try as best as possible to stop the plugin
-            self.log(runner.name, '[Runner] Could not start plugin', exception, traceback.format_exc())
+                pass  # Try as good as possible to stop the plugin
+            runner.logger.error('[Runner] Could not start plugin', exception, traceback.format_exc())
 
-    def start_plugin(self, plugin_name):
+    def start_plugin(self, plugin_name):  # type: (str) -> bool
         """ Request to start a runner """
-        runner = self._runners.get(plugin_name)
+        with Database.get_session() as db:
+            plugin = db.query(Plugin).where(Plugin.name == plugin_name).one()
+        runner = self._runners.get(plugin.id)
         if runner is None:
             return False
         if not runner.is_running():
-            self._start_plugin_runner(runner, plugin_name)
+            self._start_plugin_runner(runner)
         return runner.is_running()
 
-    def _stop_plugin_runner(self, runner_name):
+    def _stop_plugin_runner(self, runner):  # type: (PluginRunner) -> None
         """ Stops a single plugin runner """
-        runner = self._runners.get(runner_name)
-        if runner is None:
-            return
         try:
-            logger.info('Plugin {0}: {1}'.format(runner.name, 'Stopping...'))
-            watchdog = self._runner_watchdogs.get(runner_name)
+            global_logger.info('Plugin {0}: {1}'.format(runner.name, 'Stopping...'))
+            watchdog = self._runner_watchdogs.get(runner.plugin_id)
             if watchdog is not None:
                 watchdog.stop()
             runner.stop()
-            logger.info('Plugin {0}: {1}'.format(runner.name, 'Stopping... Done'))
+            global_logger.info('Plugin {0}: {1}'.format(runner.name, 'Stopping... Done'))
         except Exception as exception:
-            self.log(runner.name, '[Runner] Could not stop plugin', exception)
+            runner.logger.exception('[Runner] Could not stop plugin: {0}'.format(exception))
 
-    def stop_plugin(self, plugin_name):
+    def stop_plugin(self, plugin_name):  # type: (str) -> bool
         """ Request to stop a runner """
-        runner = self._runners.get(plugin_name)
+        with Database.get_session() as db:
+            plugin = db.query(Plugin).where(Plugin.name == plugin_name).one()
+        runner = self._runners.get(plugin.id)
         if runner is None:
             return False
-        self._stop_plugin_runner(runner.name)
+        self._stop_plugin_runner(runner)
         return runner.is_running()
 
-    def _destroy_plugin_runner(self, runner_name):
+    def _destroy_plugin_runner(self, runner):  # type: (PluginRunner) -> None
         """ Removes a runner """
-        self._stop_plugin_runner(runner_name)
-
-        self._logs.pop(runner_name, None)
-        self._runners.pop(runner_name, None)
-        self._runner_watchdogs.pop(runner_name, None)
+        self._stop_plugin_runner(runner)
 
-    def _update_dependencies(self):
-        """ When a runner is added/removed, this call updates all code that needs to know about plugins """
-        if self._webinterface is not None and self._web_service is not None:
-            self._web_service.update_tree(self._get_cherrypy_mounts())
-        if self._metrics_collector is not None:
-            self._metrics_collector.set_plugin_intervals(self._get_metric_receivers())
-        if self._metrics_controller is not None:
-            self._metrics_controller.set_plugin_definitions(self._get_metric_definitions())
+        self._runners.pop(runner.plugin_id, None)
+        self._runner_watchdogs.pop(runner.plugin_id, None)
 
     @staticmethod
-    def _update_orm(name, version):
-        # type: (str, str) -> None
+    def _update_orm(plugin_id, version):
+        # type: (int, str) -> None
         try:
             with Database.get_session() as db:
-                plugin = db.query(Plugin).filter_by(name=name).one_or_none()  # type: Optional[Plugin]
-                if plugin is None:
-                    plugin = Plugin(name=name, version=version)
-                    db.add(plugin)
+                plugin = db.query(Plugin).filter_by(id=plugin_id).one()  # type: Plugin
                 if plugin.version != version:
                     plugin.version = version
-                db.commit()
+                    db.commit()
         except Exception as ex:
-            logger.error('Could not store Plugin version: {0}'.format(ex))
+            global_logger.error('Could not store Plugin version: {0}'.format(ex))
 
     def get_plugins(self):
-        # type: () -> List[PluginRunner]
+        # type: () -> List[PluginDTO]
         """
         Get a list of all installed plugins.
         """
-        plugins = []
+        dtos = []
         with Database.get_session() as db:
-            for plugin_orm in db.query(Plugin).all():
-                plugin = self._runners.get(plugin_orm.name)
-                if plugin:
-                    plugins.append(plugin)
+            for plugin in db.query(Plugin).all():
+                runner = self._runners.get(plugin.id)
+                if runner:
+                    status = PluginEnums.State.RUNNING if runner.is_running() else PluginEnums.State.STOPPED
+                    dtos.append(PluginDTO(id=plugin.id,
+                                          name=plugin.name,
+                                          version=plugin.version,
+                                          interfaces=runner.interfaces,
+                                          status=status))
                 else:
-                    logger.warning('missing runner for plugin {}'.format(plugin_orm.name))
-        return plugins
+                    global_logger.warning('Missing runner for plugin {}'.format(plugin.name))
+        return dtos
 
-    def _get_plugin(self, name):
-        """
-        Get a plugin by name, None if it the plugin is not installed.
-
-        :rtype: plugins.runner.PluginRunner
-        """
-        return self._runners.get(name)
+    def _get_plugin_runner(self, plugin_id):
+        return self._runners.get(plugin_id)
 
     def install_plugin(self, md5, package_data):
-        """ Install a new plugin. """
         from tempfile import mkdtemp
         from shutil import rmtree
         from subprocess import call
         import hashlib
 
-
         # Check if the md5 sum matches the provided md5 sum
         hasher = hashlib.md5()
         hasher.update(package_data)
@@ -275,6 +298,8 @@ class PluginController(object):
             with open('{0}/package.tgz'.format(tmp_dir), "wb") as tgz:
                 tgz.write(package_data)
 
+            global_logger.info('Validating new plugin...')
+
             retcode = call('cd {0}; mkdir new_package; gzip -d package.tgz; tar xf package.tar -C new_package/'.format(tmp_dir),
                            shell=True)
             if retcode != 0:
@@ -295,15 +320,15 @@ class PluginController(object):
                     raise Exception('Could not create the base plugin folder')
 
             # Check if the package contains a valid plugin
-            _logger = self.get_logger('new_package')
-            runner = PluginRunner(name=None,
+            runner = PluginRunner(plugin_id=None,
+                                  name='installation',
                                   runtime_path=self._runtime_path,
-                                  plugin_path='{0}/new_package'.format(tmp_dir),
-                                  logger=_logger)
+                                  plugin_path='{0}/new_package'.format(tmp_dir))
             runner.start()
             runner.stop()
             name, version = runner.name, runner.version
-            self._logs.pop('new_pacakge', None)
+
+            global_logger.info('Validation completed')
 
             def parse_version(version_string):
                 """ Parse the version from a string "x.y.z" to a tuple(x, y, z). """
@@ -311,41 +336,52 @@ class PluginController(object):
                     return 0, 0, 0  # A stopped plugin doesn't announce it's version, so make sure we can update stopped plugins
                 return tuple([int(x) for x in version_string.split('.')])
 
-            # Check if a newer version of the package is already installed
-            installed_plugin = self._get_plugin(name)
-            if installed_plugin is not None:
-                if parse_version(version) <= parse_version(installed_plugin.version):
-                    raise Exception('A newer version of plugins {0} is already installed (current version = {1}, to installed = {2}).'.format(name, installed_plugin.version, version))
-                else:
-                    # Remove the old version of the plugin
-                    self._destroy_plugin_runner(name)
-                    retcode = call('cd {0}; rm -R {1}'.format(self._plugins_path, name),
-                                   shell=True)
-                    if retcode != 0:
-                        raise Exception('The old version of the plugin could not be removed.')
-
-            # Check if the package directory exists, this can only be the case if a previous
-            # install failed or if the plugin has gone corrupt: remove it!
-            plugin_path = os.path.join(self._plugins_path, name)
-            if os.path.exists(plugin_path):
-                rmtree(plugin_path)
-
-
-            # Install the package
-            retcode = call('cd {0}; mv new_package {1}'.format(tmp_dir, plugin_path), shell=True)
-            if retcode != 0:
-                raise Exception('The package could not be installed.')
+            # Check if plugin already exists in DB
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).where(Plugin.name == name).one_or_none()  # type: Optional[Plugin]
+
+                # Check if a newer version of the package is already installed
+                if plugin is not None:
+                    runner = self._get_plugin_runner(plugin_id=plugin.id)
+                    if parse_version(version) <= parse_version(runner.version):
+                        raise Exception('A newer version of plugins {0} is already installed (current version = {1}, to installed = {2}).'.format(name, runner.version, version))
+                    else:
+                        # Remove the old version of the plugin
+                        self._destroy_plugin_runner(runner)
+                        retcode = call('cd {0}; rm -R {1}'.format(self._plugins_path, name),
+                                       shell=True)
+                        if retcode != 0:
+                            raise Exception('The old version of the plugin could not be removed.')
+
+                # Check if the package directory exists, this can only be the case if a previous
+                # installation failed or if the plugin has gone corrupt: remove it!
+                plugin_path = os.path.join(self._plugins_path, name)
+                if os.path.exists(plugin_path):
+                    rmtree(plugin_path)
+
+                # Install the package
+                retcode = call('cd {0}; mv new_package {1}'.format(tmp_dir, plugin_path), shell=True)
+                if retcode != 0:
+                    raise Exception('The package could not be installed.')
+
+                global_logger.info('Register new plugin: {0}'.format(name))
+                if plugin is None:
+                    plugin = Plugin(name=name,
+                                    version=version)
+                    db.add(plugin)
+                    db.commit()
 
-            runner = self._init_plugin_runner(name)
-            if runner is None:
-                raise Exception('Could not initialize plugin.')
-            self._start_plugin_runner(runner, name)
+                global_logger.info('Starting new plugin: {0}'.format(name))
+                runner = self._init_plugin_runner(plugin)
+                if runner is None:
+                    raise Exception('Could not initialize plugin.')
+                self._start_plugin_runner(runner)
 
             return 'Plugin successfully installed'
         finally:
             rmtree(tmp_dir)
 
-    def remove_plugin(self, name):
+    def remove_plugin(self, name):  # type: (str) -> None
         """
         Remove a plugin, this removes the plugin package and configuration.
         It also calls the remove function on the plugin to cleanup other files written by the
@@ -353,134 +389,171 @@ class PluginController(object):
         """
         from shutil import rmtree
 
-        plugin = self._get_plugin(name)
+        with Database.get_session() as db:
+            plugin = db.query(Plugin).where(Plugin.name == name).one_or_none()  # type: Optional[Plugin]
 
         # Check if the plugin in installed
         if plugin is None:
             raise Exception('Plugin \'{0}\' is not installed.'.format(name))
 
+        runner = self._get_plugin_runner(plugin.id)
+
         # Execute the on_remove callbacks
         try:
-            plugin.remove_callback()
+            runner.remove()
         except Exception as exception:
-            logger.error('Exception while removing plugin \'{0}\': {1}'.format(name, exception))
+            global_logger.error('Exception while removing plugin \'{0}\': {1}'.format(name, exception))
 
         # Stop the plugin process
-        self._destroy_plugin_runner(name)
-        self._update_dependencies()
+        self._destroy_plugin_runner(runner)
 
         # Remove the plugin package
-        plugin_path = '{0}/{1}'.format(self._plugins_path, name)
+        plugin_path = '{0}/{1}'.format(self._plugins_path, plugin.name)
         try:
             rmtree(plugin_path)
         except Exception as exception:
             raise Exception('Error while removing package for plugin \'{0}\': {1}'.format(name, exception))
 
         # Remove the plugin configuration
-        conf_file = '{0}/pi_{1}.conf'.format(self._plugin_config_path, name)
+        conf_file = '{0}/pi_{1}.conf'.format(self._plugin_config_path, plugin.name)
         if os.path.exists(conf_file):
             os.remove(conf_file)
 
-        # Finally remove database entry.
+        # Finally, remove database entry.
         with Database.get_session() as db:
             db.query(Plugin).where(Plugin.name == name).delete()
             db.commit()
 
-        return {'msg': 'Plugin successfully removed'}
-
     def _iter_running_runners(self):
         """
         :rtype: list of plugins.runner.PluginRunner
         """
-        for runner_name in list(self._runners.keys()):
-            runner = self._runners.get(runner_name)
+        for plugin_id in list(self._runners.keys()):
+            runner = self._runners.get(plugin_id)
             if runner is not None and runner.is_running():
                 yield runner
 
     def process_gateway_event(self, event):
-        if event.type == GatewayEvent.Types.INPUT_CHANGE:
-            # Should be called when the input status changes, notifies all plugins.
-            input_id = event.data['id']
-            input_status = event.data['status']
+        if event.type in GatewayEvent.STATUS_EVENT_TYPES:
+            status_event = PluginStatusEvent(type=event.type,
+                                             data=event.data)
+            if event.type == GatewayEvent.Types.OUTPUT_CHANGE:
+                # Extra data is required for version 1, so re-package the PluginStatusEvent
+                states = [(state.id, state.dimmer) for state in self._output_controller.get_output_statuses()
+                          if state.status]
+                status_event.data = {'event': event.data,
+                                     'states': states}
+            elif event.type == GatewayEvent.Types.SHUTTER_CHANGE:
+                # Extra data is required for versions 1 and 2, so re-package the PluginStatusEvent
+                states = self._shuttercontroller.get_states()
+                status_event.data = {'event': event.data,
+                                     'status': states['status'],
+                                     'detail': states['detail']}
             for runner in self._iter_running_runners():
-                if input_status:  # Backwards compatibility: only send rising edges of the input for v1
-                    runner.process_input_status(data=(input_id, None), action_version=1)
-                runner.process_input_status(data=event, action_version=2)
-        if event.type == GatewayEvent.Types.OUTPUT_CHANGE:
-            # TODO: deprecate old versions that use state and move to events
-            states = [(state.id, state.dimmer) for state in self._output_controller.get_output_statuses() if state.status]
-            for runner in self._iter_running_runners():
-                runner.process_output_status(data=states, action_version=1)  # send states as action version 1
-                runner.process_output_status(data=event, action_version=2)   # send event as action version 2
-        if event.type == GatewayEvent.Types.SHUTTER_CHANGE:
-            # TODO: deprecate old versions that use state and move to events
-            states = self._shuttercontroller.get_states()
-            status = states['status']
-            details = states['detail']
-            for runner in self._iter_running_runners():
-                runner.process_shutter_status(data=status, action_version=1)  # send states as action version 1
-                runner.process_shutter_status(data=(status, details), action_version=2)  # send event as action version 2
-                runner.process_shutter_status(data=event, action_version=3)  # send event as action version 3
-        if event.type == GatewayEvent.Types.VENTILATION_CHANGE:
-            for runner in self._iter_running_runners():
-                runner.process_ventilation_status(data=event)
-        if event.type == GatewayEvent.Types.THERMOSTAT_CHANGE:
-            for runner in self._iter_running_runners():
-                runner.process_thermostat_status(data=event)
-        if event.type == GatewayEvent.Types.THERMOSTAT_GROUP_CHANGE:
-            for runner in self._iter_running_runners():
-                runner.process_thermostat_group_status(data=event)
-        if event.type == GatewayEvent.Types.SENSOR_CHANGE:
-            for runner in self._iter_running_runners():
-                runner.process_sensor_status(data=event)
+                try:
+                    if runner.plugin_id in self._forwarding_event_subscriptions[event.type]:
+                        runner.forward_action(action=PluginActionEnums.Action.PROCESS_STATUS_EVENT,
+                                              payload=status_event)
+                except Exception as ex:
+                    if isinstance(ex, PluginException):
+                        global_logger.error(ex.stacktrace)
+                    global_logger.error('Could not forward {0} event to runner {1}: {2}'.format(status_event.type, runner.name, ex))
+
+    # Actions
+
+    def execute_sensor_action(self, action, action_payload, destination):  # type: (str, Dict[str, Any], SourceDTO) -> Any
+        return self._forward_action(action=PluginActionEnums.Action.SENSOR_ACTION,
+                                    payload={'action': action,
+                                             'action_payload': action_payload},
+                                    destination=destination)
+
+    def execute_screen_action(self, action, action_payload, destination):  # type: (str, Dict[str, Any], SourceDTO) -> Any
+        return self._forward_action(action=PluginActionEnums.Action.SCREEN_ACTION,
+                                    payload={'action': action,
+                                             'action_payload': action_payload},
+                                    destination=destination)
+
+    def execute_metric_action(self, action, action_payload, destination):  # type: (str, Dict[str, Any], SourceDTO) -> Any
+        return self._forward_action(action=PluginActionEnums.Action.METRIC_ACTION,
+                                    payload={'action': action,
+                                             'action_payload': action_payload},
+                                    destination=destination)
+
+    def execute_ventilation_action(self, action, action_payload, destination):  # type: (str, Dict[str, Any], SourceDTO) -> Any
+        return self._forward_action(action=PluginActionEnums.Action.VENTILATION_ACTION,
+                                    payload={'action': action,
+                                             'action_payload': action_payload},
+                                    destination=destination)
+
+    # Forwarding actions
+
+    def _forward_action(self, action, payload, destination):
+        if destination.source != Source.PLUGIN:
+            raise ValueError('Only plugin sources can be processed by the PluginController')
+        with Database.get_session() as db:
+            plugin = db.query(Plugin).where((Plugin.id == destination.source_id)).one_or_none()
+            if plugin is None:
+                raise ValueError('Could not find a plugin for this source')
+            runner = self._runners.get(plugin.id)
+            if runner is None or not runner.is_running():
+                raise RuntimeError('Plugin `{0}` is currently not running'.format(plugin.name))
+            return runner.forward_action(action=action,
+                                         payload=payload)
+
+    # Forwarding callback actions
+
+    def _forward_callback_action(self, runner, action, payload):
+        source = SourceDTO(source=Source.PLUGIN,
+                           source_id=runner.plugin_id)
+        if action == PluginActionEnums.Action.SUBSCRIBE_STATUS_EVENT:
+            for event_type in payload:
+                self._forwarding_event_subscriptions[event_type].add(runner.plugin_id)
+            return None
+        if action == PluginActionEnums.Action.SENSOR_CALLBACK_ACTION:
+            if self.sensor_callback_action is None:
+                raise RuntimeError('Callback sensor forwarding not attached')
+            return self.sensor_callback_action(source=source,
+                                               action=payload['action'],
+                                               action_payload=payload['action_payload'])
+        if action == PluginActionEnums.Action.SCREEN_CALLBACK_ACTION:
+            if self.screen_callback_action is None:
+                raise RuntimeError('Callback screen forwarding not attached')
+            return self.screen_callback_action(source=source,
+                                               action=payload['action'],
+                                               action_payload=payload['action_payload'])
+        if action == PluginActionEnums.Action.METRIC_CALLBACK_ACTION:
+            if self.metrics_callback_action is None:
+                raise RuntimeError('Callback metrics forwarding not attached')
+            return self.metrics_callback_action(source=source,
+                                                action=payload['action'],
+                                                action_payload=payload['action_payload'])
+        if action == PluginActionEnums.Action.VENTILATION_CALLBACK_ACTION:
+            if self.ventilation_callback_action is None:
+                raise RuntimeError('Callback ventilation forwarding not attached')
+            return self.ventilation_callback_action(source=source,
+                                                    action=payload['action'],
+                                                    action_payload=payload['action_payload'])
+        if action == PluginActionEnums.Action.NOTIFICATION_CALLBACK_ACTION:
+            if self.notification_callback_action is None:
+                raise RuntimeError('Callback notification forwarding not attached')
+            return self.notification_callback_action(source=source,
+                                                     action=payload['action'],
+                                                     action_payload=payload['action_payload'])
+        raise RuntimeError('Unsupported PluginAction {0}'.format(action))
+
+    # Events
 
     def process_event(self, code):
         """ Should be called when an event is triggered, notifies all plugins. """
         for runner in self._iter_running_runners():
             runner.process_event(code)
 
-    def _request(self, name, method, args=None, kwargs=None):
+    def _request(self, plugin_id, method, args=None, kwargs=None):
         """ Allows to execute a programmatorical http request to the plugin """
-        runner = self._runners.get(name)
+        runner = self._runners.get(plugin_id)
         if runner is not None:
             return runner.request(method, args=args, kwargs=kwargs)
 
-    def collect_metrics(self):
-        """ Collects all metrics from all plugins """
-        for runner in self._iter_running_runners():
-            for metric in runner.collect_metrics():
-                if metric is None:
-                    continue
-                else:
-                    yield metric
-
-    def distribute_metrics(self, metrics):
-        """ Enqueues all metrics in a separate queue per plugin """
-        rates = {'total': 0}
-        rate_keys = []
-        # Preprocess rate keys
-        for metric in metrics:
-            rate_key = '{0}.{1}'.format(metric['source'].lower(), metric['type'].lower())
-            if rate_key not in rates:
-                rates[rate_key] = 0
-            rate_keys.append(rate_key)
-        # Distribute
-        for runner in self._iter_running_runners():
-            for receiver in runner.get_metric_receivers():
-                receiver_metrics = []
-                try:
-                    sources = self._metrics_controller.get_filter('source', receiver['source'])
-                    metric_types = self._metrics_controller.get_filter('metric_type', receiver['metric_type'])
-                    for index, metric in enumerate(metrics):
-                        if metric['source'] in sources and metric['type'] in metric_types:
-                            receiver_metrics.append(metric)
-                            rates[rate_keys[index]] += 1
-                            rates['total'] += 1
-                    runner.distribute_metrics(receiver['name'], receiver_metrics)
-                except Exception as ex:
-                    self.log(runner.name, 'Exception while distributing metrics', ex, traceback.format_exc())
-        return rates
-
     def _get_cherrypy_mounts(self):
         mounts = []
         cors_enabled = Config.get_entry('cors_enabled', False)
@@ -498,36 +571,7 @@ class PluginController(object):
             receivers.extend(runner.get_metric_receivers())
         return receivers
 
-    def _get_metric_definitions(self):
-        """ Loads all metric definitions of all plugins """
-        definitions = {}
-        for runner in self._iter_running_runners():
-            definitions[runner.name] = runner.get_metric_definitions()
-        return definitions
-
-    def log(self, plugin, msg, exception, stacktrace=None):
-        """ Append an exception to the log for the plugins. This log can be retrieved using get_logs. """
-        logs = self._logs.setdefault(plugin, [])
-        logger.error('Plugin {0}: {1} ({2})'.format(plugin, msg, exception))
-        if stacktrace is None:
-            logs.append('{0} - {1}: {2}'.format(datetime.now(), msg, exception))
-        else:
-            logs.append('{0} - {1}: {2}\n{3}'.format(datetime.now(), msg, exception, stacktrace))
-        if len(logs) > 100:
-            logs.pop(0)
-
-    def get_logger(self, plugin_name):
-        """ Get a logger for a plugin. """
-        logs = self._logs.setdefault(plugin_name, [])
-
-        def log(msg):
-            """ Log function for the given plugin."""
-            logs.append('{0} - {1}'.format(datetime.now(), msg))
-            if len(logs) > 100:
-                logs.pop(0)
-
-        return log
-
     def get_logs(self):
         """ Get the logs for all plugins. Returns a dict where the keys are the plugin names and the value is a string. """
-        return dict((plugin, '\n'.join(entries)) for plugin, entries in six.iteritems(self._logs))
+        return {runner.name: '\n'.join(runner.logs)
+                for runner in self._runners.values()}
diff --git a/src/plugins/runner.py b/src/plugins/runner.py
index 52172338..cd989c6e 100644
--- a/src/plugins/runner.py
+++ b/src/plugins/runner.py
@@ -2,24 +2,27 @@ from __future__ import absolute_import
 
 import logging
 import subprocess
-import sys
 import time
-import traceback
-from threading import Lock, Thread
-
 import cherrypy
-import six
+import os
+import sys
 import ujson as json
-from six.moves.queue import Empty, Full, Queue
+from threading import Thread
+from datetime import datetime
 from gateway.daemon_thread import BaseThread
-from toolbox import PluginIPCReader, PluginIPCWriter
+from gateway.dto import PluginActionDTO as ActionDTO
+from gateway.enums import PluginActionEnums as ActionEnums
+from toolbox import PluginIPCCommunicator
 from plugin_runtime.base import PluginWebRequest, PluginWebResponse
 from gateway.webservice import WebInterface, log_access
+from gateway.exceptions import PluginCommunicationTimeout, PluginException
+from gateway.updates.update_constants import UpdateConstants
+from logs import Logs
 
 if False:  # MYPY
     from typing import Any, Dict, Callable, List, Optional, AnyStr
 
-logger_ = logging.getLogger(__name__)
+global_logger = logging.getLogger(__name__)
 
 
 class Service(object):
@@ -78,6 +81,8 @@ class Service(object):
 
             # Perform the request with the set PluginWebRequest object
             contents = self.runner.request(method, args=args, kwargs=kwargs)
+            if contents is None:
+                return None
 
             # Deserialize the response contents to a PluginWebResponse object
             plugin_response = PluginWebResponse.deserialize(contents)
@@ -93,9 +98,9 @@ class Service(object):
             else:
                 return None
         except Exception as ex:
-            self.runner._logger('Exception when dispatching API call ({}): {}'.format(plugin_web_request.path, ex))
+            self.runner.logger.exception('Exception when dispatching API call ({0}): {1}'.format(plugin_web_request.path, ex))
             cherrypy.response.headers["Content-Type"] = "application/json"
-            cherrypy.response.status = 500
+            cherrypy.response.status = 400 if isinstance(ex, RuntimeError) else 500
             contents = json.dumps({"success": False, "msg": str(ex)})
             return contents.encode()
 
@@ -105,96 +110,107 @@ class PluginRunner(object):
         RUNNING = 'RUNNING'
         STOPPED = 'STOPPED'
 
-    def __init__(self, name, runtime_path, plugin_path, logger, command_timeout=5.0, state_callback=None):
+    def __init__(self, plugin_id, name, runtime_path, plugin_path, command_timeout=5.0, state_callback=None, action_callback=None):
+        self.plugin_id = plugin_id
+        self.name = name
         self.runtime_path = runtime_path
         self.plugin_path = plugin_path
         self.command_timeout = command_timeout
 
-        self._logger = logger
+        self.logs = []
+        self.logger = logging.getLogger('plugin.{0}'.format(name))
+        Logs.setup_log_function_logger(logger=self.logger, log_function=self._add_to_log_buffer)
+
         self._cid = 0
         self._proc = None  # type: Optional[subprocess.Popen[bytes]]
         self._running = False
         self._process_running = False
-        self._command_lock = Lock()
-        self._response_queue = Queue()  # type: Queue[Dict[str,Any]]
-        self._writer = None  # type: Optional[PluginIPCWriter]
-        self._reader = None  # type: Optional[PluginIPCReader]
-        self._state_callback = state_callback  # type: Optional[Callable[[str, str], None]]
+        self._state_callback = state_callback  # type: Optional[Callable[[int, str], None]]
+        self._action_callback = action_callback  # type: Optional[Callable[..., Any]]
 
-        self.name = name
         self.version = None
         self.interfaces = None
+        self.metric_definitions = None
 
-        self._decorators_in_use = {}
         self._exposes = []
-        self._metric_collectors = []
-        self._metric_receivers = []
 
-        self._async_command_thread = None
-        self._async_command_queue = None  # type: Optional[Queue[Optional[Dict[str, Any]]]]
+        self._ipc = None  # type: Optional[PluginIPCCommunicator]
 
         self._commands_executed = 0
         self._commands_failed = 0
 
         self.__collector_runs = {}  # type: Dict[str,float]
 
+    def _add_to_log_buffer(self, message, level):
+        self.logs.append('{0} - {1} - {2}'.format(datetime.now(), logging.getLevelName(level), message))
+        if len(self.logs) > 100:
+            self.logs.pop(0)
+
     def start(self):
         # type: () -> None
         if self._running:
             raise Exception('PluginRunner is already running')
 
-        self.logger('[Runner] Starting')
+        self.logger.info('[Runner] Starting')
 
-        python_executable = sys.executable
-        if python_executable is None or len(python_executable) == 0:
-            python_executable = '/usr/bin/python'
+        if not os.path.exists(UpdateConstants.VENV_CURRENT):
+            python_executable = sys.executable
+            pythonpaths = []
+        else:
+            requested_python_version = 2
+            try:
+                info_json_path = os.path.join(self.plugin_path, 'info.json')
+                if os.path.exists(info_json_path):
+                    with open(info_json_path, 'r') as fd:
+                        info_python_version = int(json.load(fd).get('python_version', 2))
+                    if info_python_version in [2, 3]:
+                        requested_python_version = info_python_version
+            except Exception as ex:
+                global_logger.error('Could not parse info.json: {0}'.format(ex))
+            if requested_python_version == 2:
+                required_venv = UpdateConstants.VENV_LEGACY
+                self.logger.info('[Runner] Running in legacy python2 environment')
+            else:
+                required_venv = UpdateConstants.VENV_CURRENT
+            python_executable = os.path.join(required_venv, 'venv/bin/python')
+            pythonpaths = [os.path.join(required_venv, 'python-dependencies')]
 
-        self._proc = subprocess.Popen([python_executable, 'runtime.py', 'start_plugin', self.plugin_path],
+        environment = os.environ.copy()
+        if ';' in environment.get('PYTHONPATH', ''):
+            pythonpaths += environment['PYTHONPATH'].split(';')
+        environment['PYTHONPATH'] = ';'.join(pythonpaths)
+
+        self._proc = subprocess.Popen([python_executable, '-u', 'runtime.py', 'start_plugin', self.plugin_path],
                                       stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=None,
-                                      cwd=self.runtime_path, close_fds=True)
+                                      env=environment, cwd=self.runtime_path, close_fds=True)
         assert self._proc.stdout, 'Plugin stdout not available'
-        self._process_running = True
+        assert self._proc.stdin, 'Plugin stdin not defined'
 
+        self._process_running = True
         self._commands_executed = 0
         self._commands_failed = 0
 
-        assert self._proc.stdin, 'Plugin stdin not defined'
-        self._writer = PluginIPCWriter(stream=self._proc.stdin)
-        self._reader = PluginIPCReader(stream=self._proc.stdout,
-                                       logger=lambda message, ex: self.logger('{0}: {1}'.format(message, ex)),
-                                       command_receiver=self._process_command,
-                                       name=self.name)
-        self._reader.start()
-
-        start_out = self._do_command('start', timeout=180)
+        self._ipc = PluginIPCCommunicator(input_stream=self._proc.stdout,
+                                          output_stream=self._proc.stdin,
+                                          name=self.name,
+                                          side=PluginIPCCommunicator.Side.GATEWAY,
+                                          request_processor=self._process_request)
+        self._ipc.start()
+        time.sleep(1)  # Wait for plugin's IPC to start
+
+        start_out = self._do_command(action_dto=ActionDTO(action=ActionEnums.Action.START),
+                                     timeout=180)
+
         self.name = start_out['name']
         self.version = start_out['version']
         self.interfaces = start_out['interfaces']
-
-        self._decorators_in_use = start_out['decorators']
+        self.metric_definitions = start_out['metric_definitions']
         self._exposes = start_out['exposes']
-        self._metric_collectors = start_out['metric_collectors']
-        self._metric_receivers = start_out['metric_receivers']
-
-        exception = start_out.get('exception')
-        if exception is not None:
-            raise RuntimeError(exception)
-
-        self._async_command_queue = Queue(1000)
-        self._async_command_thread = BaseThread(name='plugincmd{0}'.format(self.plugin_path),
-                                                target=self._perform_async_commands)
-        self._async_command_thread.daemon = True
-        self._async_command_thread.start()
 
         self._running = True
         if self._state_callback is not None:
-            self._state_callback(self.name, PluginRunner.State.RUNNING)
-        self.logger('[Runner] Started')
-
-    def logger(self, message):
-        # type: (str) -> None
-        self._logger(message)
-        logger_.info('Plugin {0} - {1}'.format(self.name, message))
+            self._state_callback(self.plugin_id, PluginRunner.State.RUNNING)
+        self.logger.info('[Runner] Started')
 
     def get_webservice(self, webinterface):
         # type: (WebInterface) -> Service
@@ -209,271 +225,104 @@ class PluginRunner(object):
         if self._process_running:
             self._running = False
 
-            self.logger('[Runner] Sending stop command')
+            self.logger.info('[Runner] Sending stop command')
             try:
-                self._do_command('stop')
-            except Exception as exception:
-                self.logger('[Runner] Exception during stopping plugin: {0}'.format(exception))
-            time.sleep(0.1)
+                self._do_command(action_dto=ActionDTO(action=ActionEnums.Action.STOP))
+            except PluginException as exc:
+                self.logger.error('[Runner] Exception during stopping plugin: {0}\n{1}'.format(exc, exc.stacktrace))
+            except Exception as exc:
+                self.logger.exception('[Runner] Exception during stopping plugin: {0}'.format(exc))
+            time.sleep(2)
 
-            if self._reader:
-                self._reader.stop()
-            self._process_running = False
-            if self._async_command_queue is not None:
-                self._async_command_queue.put(None)  # Triggers an abort on the read thread
+            if self._ipc:
+                self._ipc.stop()
 
+            self._process_running = False
             if self._proc and self._proc.poll() is None:
-                self.logger('[Runner] Terminating process')
+                self.logger.info('[Runner] Terminating process')
                 try:
                     self._proc.terminate()
                 except Exception as exception:
-                    self.logger('[Runner] Exception during terminating plugin: {0}'.format(exception))
+                    self.logger.exception('[Runner] Exception during terminating plugin: {0}'.format(exception))
                 time.sleep(0.5)
 
                 if self._proc.poll() is None:
-                    self.logger('[Runner] Killing process')
+                    self.logger.info('[Runner] Killing process')
                     try:
                         self._proc.kill()
                     except Exception as exception:
-                        self.logger('[Runner] Exception during killing plugin: {0}'.format(exception))
+                        self.logger.exception('[Runner] Exception during killing plugin: {0}'.format(exception))
 
             if self._state_callback is not None:
-                self._state_callback(self.name, PluginRunner.State.STOPPED)
-            self.logger('[Runner] Stopped')
+                self._state_callback(self.plugin_id, PluginRunner.State.STOPPED)
+            self.logger.info('[Runner] Stopped')
 
-    def process_input_status(self, data, action_version=1):
-        if action_version in [1, 2]:
-            if action_version == 1:
-                payload = {'status': data}
-            else:
-                event_json = data.serialize()
-                payload = {'event': event_json}
-            self._do_async(action='input_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Input status version {} not supported.'.format(action_version))
-
-    def process_output_status(self, data, action_version=1):
-        if action_version in [1, 2]:
-            if action_version == 1:
-                payload = {'status': data}
-            else:
-                event_json = data.serialize()
-                payload = {'event': event_json}
-            self._do_async(action='output_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Output status version {} not supported.'.format(action_version))
-
-    def process_shutter_status(self, data, action_version=1):
-        if action_version in [1, 2, 3]:
-            if action_version == 1:
-                payload = {'status': data}
-            elif action_version == 2:
-                status, detail = data
-                payload = {'status': {'status': status, 'detail': detail}}
-            else:
-                event_json = data.serialize()
-                payload = {'event': event_json}
-            self._do_async(action='shutter_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Shutter status version {} not supported.'.format(action_version))
+    def ping(self):
+        action_dto = ActionDTO(action=ActionEnums.Action.PING)
+        return self._do_command(action_dto=action_dto,
+                                timeout=1.0)
 
-    def process_ventilation_status(self, data, action_version=1):
-        if action_version in [1]:
-            event_json = data.serialize()
-            payload = {'event': event_json}
-            self._do_async(action='ventilation_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Ventilation status version {} not supported.'.format(action_version))
+    def remove(self):
+        # type: () -> None
+        action_dto = ActionDTO(action=ActionEnums.Action.REMOVE)
+        self._do_command(action_dto=action_dto)
 
-    def process_thermostat_status(self, data, action_version=1):
-        if action_version in [1]:
-            event_json = data.serialize()
-            payload = {'event': event_json}
-            self._do_async(action='thermostat_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Thermostat status version {} not supported.'.format(action_version))
+    # Action forwarding
 
-    def process_thermostat_group_status(self, data, action_version=1):
-        if action_version in [1]:
-            event_json = data.serialize()
-            payload = {'event': event_json}
-            self._do_async(action='thermostat_group_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Thermostat group status version {} not supported.'.format(action_version))
+    def forward_action(self, action, payload):  # type: (str, Any) -> Any
+        action_dto = ActionDTO(action=action,
+                               payload=payload)
+        return self._do_command(action_dto=action_dto)
 
-    def process_sensor_status(self, data, action_version=1):
-        if action_version in [1]:
-            event_json = data.serialize()
-            payload = {'event': event_json}
-            self._do_async(action='sensor_status', payload=payload, should_filter=True, action_version=action_version)
-        else:
-            self.logger('Sensor status version {} not supported.'.format(action_version))
+    # Events (master EV instruction)
 
     def process_event(self, code):
-        self._do_async('receive_events', {'code': code}, should_filter=True)
+        action_dto = ActionDTO(action=ActionEnums.Action.RECEIVE_EVENTS,
+                               payload={'code': code},
+                               action_version=1)
+        self._do_command(action_dto=action_dto)
 
-    def collect_metrics(self):
-        for mc in self._metric_collectors:
-            try:
-                now = time.time()
-                (name, interval) = (mc['name'], mc['interval'])
-
-                if self.__collector_runs.get(name, 0.0) < now - interval:
-                    self.__collector_runs[name] = now
-                    metrics = self._do_command('collect_metrics', {'name': name})['metrics']
-                    for metric in metrics:
-                        if metric is None:
-                            continue
-                        metric['source'] = self.name
-                        yield metric
-            except Exception as exception:
-                self.logger('[Runner] Exception while collecting metrics {0}: {1}'.format(exception, traceback.format_exc()))
-
-    def get_metric_receivers(self):
-        return self._metric_receivers
-
-    def distribute_metrics(self, method, metrics):
-        self._do_async('distribute_metrics', {'name': method,
-                                              'metrics': metrics})
-
-    def get_metric_definitions(self):
-        return self._do_command('get_metric_definitions')['metric_definitions']
+    # Plugin API request
 
     def request(self, method, args=None, kwargs=None):
-        if args is None:
-            args = []
-        if kwargs is None:
-            kwargs = {}
-        ret = self._do_command('request', {'method': method,
-                                           'args': args,
-                                           'kwargs': kwargs})
-        if ret['success']:
-            return ret['response']
-        elif 'stacktrace' in ret:
-            raise Exception('{0}: {1}'.format(ret['exception'], ret['stacktrace']))
-        raise Exception(ret['exception'])
-
-    def remove_callback(self):
-        # type: () -> None
-        self._do_command('remove_callback')
-
-    def _process_command(self, response):
-        # type: (Dict[str,Any]) -> None
-        if not self._process_running:
-            return
-        assert self._proc, 'Plugin process not defined'
-        exit_code = self._proc.poll()
-        if exit_code is not None:
-            self.logger('[Runner] Stopped with exit code {0}'.format(exit_code))
-            self._process_running = False
-            return
-
-        if response['cid'] == 0:
-            self._handle_async_response(response)
-        elif response['cid'] == self._cid:
-            self._response_queue.put(response)
-        else:
-            self.logger('[Runner] Received message with unknown cid: {0}'.format(response))
-
-    def _handle_async_response(self, response):
-        # type: (Dict[str,Any]) -> None
-        if response['action'] == 'logs':
-            self.logger(response['logs'])
-        else:
-            self.logger('[Runner] Unkown async message: {0}'.format(response))
-
-    def _do_async(self, action, payload, should_filter=False, action_version=1):
-        # type: (str, Dict[str,Any], bool, int) -> None
-        has_receiver = False
-        for decorator_name, decorator_versions in six.iteritems(self._decorators_in_use):
-            # the action version is linked to a specific decorator version
-            has_receiver |= (action == decorator_name and action_version in decorator_versions)
-        if not self._process_running or (should_filter and not has_receiver):
-            return
-        try:
-            assert self._async_command_queue, 'Command Queue not defined'
-            self._async_command_queue.put({'action': action, 'payload': payload, 'action_version': action_version}, block=False)
-        except Full:
-            self.logger('Async action cannot be queued, queue is full')
-
-    def _perform_async_commands(self):
-        # type: () -> None
-        while self._process_running:
-            try:
-                # Give it a timeout in order to check whether the plugin is not stopped.
-                assert self._async_command_queue, 'Command Queue not defined'
-                command = self._async_command_queue.get(block=True, timeout=10)
-                if command is None:
-                    continue  # Used to exit this thread
-                self._do_command(command['action'], payload=command['payload'], action_version=command['action_version'])
-            except Empty:
-                self._do_async('ping', {})
-            except Exception as exception:
-                self.logger('[Runner] Failed to perform async command: {0}'.format(exception))
-
-    def _do_command(self, action, payload=None, timeout=None, action_version=1):
-        # type: (str, Dict[str,Any], Optional[float], int) -> Dict[str,Any]
-        if payload is None:
-            payload = {}
+        payload = {'method': method,
+                   'args': args if args is not None else [],
+                   'kwargs': kwargs if kwargs is not None else {}}
+        action_dto = ActionDTO(action=ActionEnums.Action.REQUEST,
+                               payload=payload)
+        return self._do_command(action_dto=action_dto)
+
+    # IPC IO
+
+    def _process_request(self, action_dto):
+        if action_dto.action == ActionEnums.Action.LOGS:
+            self.logger.log(msg=action_dto.payload['message'],
+                            level=action_dto.payload['level'])
+            return None
+        # The rest of the unprocessed actions can be forwarded to the PluginController
+        if self._action_callback is None:
+            return None
+        return self._action_callback(runner=self,
+                                     action=action_dto.action,
+                                     payload=action_dto.payload)
+
+    def _do_command(self, action_dto, timeout=None):
+        # type: (ActionDTO, Optional[float]) -> Any
         self._commands_executed += 1
         if timeout is None:
             timeout = self.command_timeout
 
-        if not self._process_running:
-            raise Exception('Plugin was stopped')
-
-        with self._command_lock:
-            try:
-                command = self._create_command(action, payload, action_version)
-                assert self._writer, 'Plugin stdin not defined'
-                self._writer.write(command)
-            except Exception:
-                self._commands_failed += 1
-                raise
-
-            try:
-                response = self._response_queue.get(block=True, timeout=timeout)
-                while response['cid'] != self._cid:
-                    response = self._response_queue.get(block=False)
-                exception = response.get('_exception')
-                if exception is not None:
-                    raise RuntimeError(exception)
-                return response
-            except Empty:
-                metadata = ''
-                if action == 'request':
-                    metadata = ' {0}'.format(payload['method'])
-                if self._running:
-                    self.logger('[Runner] No response within {0}s ({1}{2})'.format(timeout, action, metadata))
-                self._commands_failed += 1
-                raise Exception('Plugin did not respond')
-
-    def _create_command(self, action, payload=None, action_version=1):
-        # type: (str, Dict[str,Any], int) -> Dict[str,Any]
-        if payload is None:
-            payload = {}
-        self._cid += 1
-        command = {'cid': self._cid,
-                   'action': action,
-                   'action_version': action_version}
-        command.update(payload)
-        return command
-
-    def error_score(self):
-        # type: () -> float
-        if self._commands_executed == 0:
-            return 0.0
-        else:
-            score = float(self._commands_failed) / self._commands_executed
-            self._commands_failed = 0
-            self._commands_executed = 0
-            return score
+        if not self._process_running or self._ipc is None:
+            raise RuntimeError('Cannot send command to non-running plugin')
 
-    def get_queue_length(self):
-        # type: () -> int
-        if self._async_command_queue is None:
-            return 0
-        return self._async_command_queue.qsize()
+        try:
+            return self._ipc.write(payload=action_dto,
+                                   timeout=timeout)
+        except Exception as ex:
+            self._commands_failed += 1
+            if not isinstance(ex, PluginCommunicationTimeout):
+                self.logger.exception('[Runner] Unexpected error: {0}'.format(ex))
+            raise
 
 
 class RunnerWatchdog(object):
@@ -495,13 +344,14 @@ class RunnerWatchdog(object):
         # type: () -> bool
         self._stopped = False
         success = self._run()  # Initial sync run
-        self._thread = BaseThread(name='watchdog{0}'.format(self._plugin_runner.name), target=self.run)
+        self._thread = BaseThread(name='watchdog{0}'.format(self._plugin_runner.name),
+                                  target=self.run)
         self._thread.daemon = True
         self._thread.start()
         return success
 
     def run(self):
-        self._plugin_runner.logger('[Watchdog] Started')
+        self._plugin_runner.logger.info('[Watchdog] Started')
         while not self._stopped:
             self._run()
             for _ in range(self._check_interval * 2):
@@ -509,28 +359,31 @@ class RunnerWatchdog(object):
                 time.sleep(0.5)
                 if self._stopped:
                     break
-        self._plugin_runner.logger('[Watchdog] Stopped')
+        self._plugin_runner.logger.info('[Watchdog] Stopped')
 
     def _run(self):
-        starting = False
+        action = None
         try:
-            score = self._plugin_runner.error_score()
-            if score > self._threshold:
-                starting = False
-                self._plugin_runner.logger('[Watchdog] Stopping unhealthy runner')
-                self._plugin_runner.stop()
+            action = 'checking initial running state'
+            if self._plugin_runner.is_running():
+                try:
+                    action = 'pinging'
+                    self._plugin_runner.ping()
+                except PluginCommunicationTimeout:
+                    action = 'stopping'
+                    self._plugin_runner.logger.warning('[Watchdog] Stopping unresponsive runner')
+                    self._plugin_runner.stop()
+            action = 'rechecking running state'
             if not self._plugin_runner.is_running():
-                starting = True
-                self._plugin_runner.logger('[Watchdog] Starting stopped runner')
+                action = 'starting'
+                self._plugin_runner.logger.info('[Watchdog] Starting stopped runner')
                 self._plugin_runner.start()
             return True
         except Exception as e:
-            self._plugin_runner.logger('[Watchdog] Exception while {0} runner: {1}'.format(
-                'starting' if starting else 'stopping', e
-            ))
+            self._plugin_runner.logger.exception('[Watchdog] Exception while {0} runner: {1}'.format(action, e))
             try:
-                self._plugin_runner.logger('[Watchdog] Stopping failed runner')
+                self._plugin_runner.logger.warning('[Watchdog] Stopping failed runner')
                 self._plugin_runner.stop()
             except Exception as se:
-                self._plugin_runner.logger('[Watchdog] Exception while stopping failed runner: {0}'.format(se))
+                self._plugin_runner.logger.exception('[Watchdog] Exception while stopping failed runner: {0}'.format(se))
             return False
diff --git a/src/post-update.sh b/src/post-update.sh
deleted file mode 100755
index c939c349..00000000
--- a/src/post-update.sh
+++ /dev/null
@@ -1,7 +0,0 @@
-#!/bin/sh
-set -e
-
-OS_DIST=`awk -F= '$1=="ID" { print $2 ;}' /etc/os-release`
-TEMP_DIR=$(mktemp -d -t pip-XXXXXXXX -p /opt/openmotics)
-env TMPDIR=$TEMP_DIR PYTHONUSERBASE=/opt/openmotics/python-deps python /opt/openmotics/python/libs/pip.whl/pip install --no-index --user /opt/openmotics/python/libs/$OS_DIST/*.whl
-rm -rf $TEMP_DIR
diff --git a/src/setup.cfg b/src/setup.cfg
new file mode 100644
index 00000000..1052692a
--- /dev/null
+++ b/src/setup.cfg
@@ -0,0 +1,27 @@
+[metadata]
+name = gateway
+version = attr:gateway.__version__
+description = OpenMotics Gateway (backend)
+url = https://github.com/openmotics/gateway
+license = AGPL3
+classifiers =
+    Development Status :: 5 - Production/Stable
+    License :: OSI Approved :: GNU Affero General Public License v3
+    Programming Language :: Python
+    Programming Language :: Python :: 2.7
+    Programming Language :: Python :: 3.8
+
+[options]
+zip_safe = False
+include_package_data = True
+packages = find:
+
+[options.entry_points]
+console_scripts =
+    gw-cli=openmotics_cli:main
+    gw-service=openmotics_service:main
+    gw-vpn-service=vpn_service:main
+    gw-watchdog=watchdog:main
+
+[bdist_wheel]
+universal = true
diff --git a/src/setup.py b/src/setup.py
new file mode 100644
index 00000000..8bf1ba93
--- /dev/null
+++ b/src/setup.py
@@ -0,0 +1,2 @@
+from setuptools import setup
+setup()
diff --git a/src/toolbox.py b/src/toolbox.py
index c32efce9..44d554b0 100644
--- a/src/toolbox.py
+++ b/src/toolbox.py
@@ -20,143 +20,213 @@ from __future__ import absolute_import
 
 import inspect
 import logging
+import hashlib
+import subprocess
 import time
 import traceback
-from collections import deque
-from threading import Thread
-
+from threading import Lock
+from six.moves.queue import Queue, Empty
+import requests
 import msgpack
 import six
+import shutil
 
+from platform_utils import System
 from gateway.daemon_thread import BaseThread
-
-logger = logging.getLogger('openmotics')
+from gateway.exceptions import PluginCommunicationTimeout, PluginException
 
 if False:  # MYPY
-    from typing import Any, Callable, Dict, IO, List, Optional
-
-
-class Full(Exception):
-    pass
-
-
-class Empty(Exception):
-    pass
-
-
-class Queue(object):
-    def __init__(self, size=None):
-        self._queue = deque()  # type: deque
-        self._size = size  # Not used
+    from typing import Any, Dict, List, Optional, Union
+    from logging import Logger
+
+global_logger = logging.getLogger(__name__)
+
+
+class PluginIPCCommunicator(object):
+    class IPCDTO(object):
+        def __init__(self, side, cid, payload=None, exception=None, stacktrace=None):
+            # type: (str, int, Optional[Any], Optional[Union[Exception, str]], Optional[str]) -> None
+            self.side = side
+            self.cid = cid
+            self.payload = payload
+            if exception is not None and isinstance(exception, Exception):
+                self.exception = '{0}("{1}")'.format(exception.__class__.__name__, str(exception))  # type: Optional[str]
+            else:
+                self.exception = exception
+            self.stacktrace = stacktrace
+
+        def __str__(self):
+            return str(self.serialize())
+
+        def serialize(self):  # type: () -> Dict[str, Any]
+            return {'side': self.side,
+                    'cid': self.cid,
+                    'payload': self.payload,
+                    'exception': self.exception,
+                    'stacktrace': self.stacktrace}
+
+        def check(self):  # type: () -> None
+            if self.exception is not None:
+                raise PluginException(self.exception,
+                                      self.stacktrace)
+
+        @classmethod
+        def deserialize(cls, data):  # type: (Dict[str, Any]) -> PluginIPCCommunicator.IPCDTO
+            return cls(side=data['side'],
+                       cid=data['cid'],
+                       payload=data['payload'],
+                       exception=data['exception'],
+                       stacktrace=data['stacktrace'])
+
+    class Side(object):
+        GATEWAY = 'G'
+        PLUGIN = 'P'
+
+    def __init__(self, input_stream, output_stream, name, side, request_processor):
+        self._input_stream = input_stream
+        self._output_stream = output_stream
+        self._name = name
+        self._side = side
+        self._request_processor = request_processor
+        self._pending_calls = {}  # type: Dict[int, Queue[Optional[PluginIPCCommunicator.IPCDTO]]]
+        self._write_lock = Lock()
+
+        self._cid_lock = Lock()
+        self._used_cids = []  # type: List[int]
+
+        self._unpacker = msgpack.Unpacker(file_like=input_stream,
+                                          read_size=1,
+                                          raw=False,
+                                          object_hook=PluginIPCCommunicator._deserialize)  # type: msgpack.Unpacker
+        self._packer = msgpack.Packer(default=PluginIPCCommunicator._serialize)  # type: msgpack.Packer
+        self._running = False
 
-    def put(self, value, block=False):
-        _ = block
-        self._queue.appendleft(value)
+    @staticmethod
+    def _serialize(instance):
+        from gateway.dto import PLUGIN_IPC_SERIALIZABLE
+        for klass in PLUGIN_IPC_SERIALIZABLE + [PluginIPCCommunicator.IPCDTO]:  # type: ignore
+            if isinstance(instance, klass):
+                data = {'__{0}__'.format(klass.__name__): True}  # type: ignore
+                data.update(instance.serialize())  # type: ignore
+                return data
+        return instance
 
-    def get(self, block=True, timeout=None):
-        if not block:
-            try:
-                return self._queue.pop()
-            except IndexError:
-                raise Empty()
-        start = time.time()
-        while timeout is None or time.time() - start < timeout:
-            try:
-                return self._queue.pop()
-            except IndexError:
-                sleep = 0.025
-                if timeout is None or timeout > 1:
-                    sleep = 0.1
-                time.sleep(sleep)
-        raise Empty()
-
-    def qsize(self):
-        return len(self._queue)
-
-    def clear(self):
-        return self._queue.clear()
-
-
-class PluginIPCReader(object):
-    """
-    This class handles IPC communications.
-
-    It uses a stream of msgpack encoded dict values.
-    """
-
-    def __init__(self, stream, logger, command_receiver=None, name=None):
-        # type: (IO[bytes], Callable[[str,Exception],None], Callable[[Dict[str,Any]],None],Optional[str]) -> None
-        self._command_queue = Queue()
-        self._unpacker = msgpack.Unpacker(stream, read_size=1, raw=False)  # type: msgpack.Unpacker[Dict[str,Any]]
-        self._read_thread = None  # type: Optional[Thread]
-        self._logger = logger
-        self._running = False
-        self._command_receiver = command_receiver
-        self._name = name
+    @staticmethod
+    def _deserialize(data):
+        if isinstance(data, dict):
+            from gateway.dto import PLUGIN_IPC_SERIALIZABLE
+            for klass in PLUGIN_IPC_SERIALIZABLE + [PluginIPCCommunicator.IPCDTO]:  # type: ignore
+                if data.get('__{0}__'.format(klass.__name__)):  # type: ignore
+                    return klass.deserialize(data)  # type: ignore
+        return data
 
     def start(self):
-        # type: () -> None
         self._running = True
-        self._read_thread = BaseThread(name='ipcread', target=self._read)
+        self._read_thread = BaseThread(name='{0}_ipc'.format(self._name), target=self._read)
         self._read_thread.daemon = True
         self._read_thread.start()
 
     def stop(self):
-        # type: () -> None
         self._running = False
+        for cid in list(self._pending_calls.keys()):
+            queue = self._pending_calls.pop(cid, None)
+            if queue is not None:
+                queue.put(None)
+            self._clear_cid(cid)
         if self._read_thread is not None:
             self._read_thread.join()
 
+    def _get_cid(self):
+        with self._cid_lock:
+            for cid in range(1024):
+                if cid not in self._used_cids:
+                    self._used_cids.append(cid)
+                    return cid
+            raise RuntimeError('Out of IPC CID options')
+
+    def _clear_cid(self, cid):
+        with self._cid_lock:
+            if cid in self._used_cids:
+                self._used_cids.remove(cid)
+
+    def write(self, payload, timeout=5.0):
+        queue = Queue()  # type: Queue[Optional[PluginIPCCommunicator.IPCDTO]]
+        cid = self._get_cid()
+        try:
+            self._pending_calls[cid] = queue
+            ipc_dto = PluginIPCCommunicator.IPCDTO(side=self._side,
+                                                   cid=cid,
+                                                   payload=payload)
+            self._write(data=ipc_dto)
+            if timeout > 0:
+                reply_ipc_dto = queue.get(timeout=timeout)
+                if reply_ipc_dto is None:
+                    return None  # Used to release all writeing threads when stopping
+                reply_ipc_dto.check()
+                return reply_ipc_dto.payload
+        except Empty:
+            self._clear_cid(cid)
+            raise PluginCommunicationTimeout('Received no answer in {0}s'.format(timeout))
+        except PluginException:
+            self._clear_cid(cid)
+            raise
+        except Exception as ex:
+            if self._side == PluginIPCCommunicator.Side.GATEWAY:
+                global_logger.error('Unexpected write error for {0}: {1}'.format(self._name, ex))
+            self._clear_cid(cid)
+            raise
+        return None
+
+    def _write(self, data):  # type: (PluginIPCCommunicator.IPCDTO) -> None
+        try:
+            with self._write_lock:
+                self._output_stream.write(self._packer.pack(data))
+                self._output_stream.flush()
+        except IOError:
+            pass  # Ignore exceptions if the stream is not available (nothing that can be done anyway)
+
     def _read(self):
-        # type: () -> None
         while self._running:
             try:
-                command = next(self._unpacker)
-                if not isinstance(command, dict):
-                    raise ValueError('invalid value %s' % command)
-                if self._command_receiver is not None:
-                    self._command_receiver(command)
+                ipc_dto = next(self._unpacker)
+                if not isinstance(ipc_dto, PluginIPCCommunicator.IPCDTO):
+                    continue  # Invalid data received
+                if ipc_dto.side == self._side:
+                    # This means this is an answer
+                    call = self._pending_calls.pop(ipc_dto.cid, None)
+                    self._clear_cid(ipc_dto.cid)
+                    if call is None:
+                        continue
+                    call.put(ipc_dto)
                 else:
-                    self._command_queue.put(command)
+                    # This means this is a new request
+                    thread = BaseThread(name='ipc_{0}_{1}'.format(self._name, self._side),
+                                        target=self._process_request,
+                                        args=(ipc_dto,))
+                    thread.start()  # TODO: Using a ThreadPool?
             except StopIteration as ex:
-                self._logger('PluginIPCReader %s stopped' % self._name, ex)
+                if 'No more data to unpack' not in str(ex):
+                    if self._side == PluginIPCCommunicator.Side.GATEWAY:
+                        global_logger.error('PluginIPCCommunicator {0} stopped: {1}'.format(self._name, ex))
                 self._running = False
             except Exception as ex:
-                self._logger('Unexpected read exception', ex)
-
-    def get(self, block=True, timeout=None):
-        return self._command_queue.get(block, timeout)
+                if self._side == PluginIPCCommunicator.Side.GATEWAY:
+                    global_logger.error('Unexpected read exception: {0}'.format(ex))
+                time.sleep(0.5)
 
-
-class PluginIPCWriter(object):
-    def __init__(self, stream):
-        # type: (IO[bytes]) -> None
-        self._packer = msgpack.Packer()  # type: msgpack.Packer[Dict[str,Any]]
-        self._stream = stream
-
-    def log(self, msg):
-        # type: (str) -> None
-        self.write({'cid': 0, 'action': 'logs', 'logs': str(msg)})
-
-    def log_exception(self, name, exception):
-        # type: (str, BaseException) -> None
-        self.log('Exception ({0}) in {1}: {2}'.format(exception, name, traceback.format_exc()))
-
-    def with_catch(self, name, target, args):
-        # type: (str, Callable[...,None], List[Any]) -> None
-        """ Logs Exceptions that happen in target(*args). """
+    def _process_request(self, ipc_dto):
         try:
-            return target(*args)
-        except Exception as exception:
-            self.log_exception(name, exception)
-
-    def write(self, response):
-        # type: (Dict[str,Any]) -> None
-        try:
-            self._stream.write(self._packer.pack(response))
-            self._stream.flush()
-        except IOError:
-            pass  # Ignore exceptions if the stream is not available (nothing that can be done anyway)
+            return_payload = self._request_processor(ipc_dto.payload)
+            ipc_dto = PluginIPCCommunicator.IPCDTO(side=ipc_dto.side,
+                                                   cid=ipc_dto.cid,
+                                                   payload=return_payload)
+            self._write(data=ipc_dto)
+        except Exception as ex:
+            ipc_dto = PluginIPCCommunicator.IPCDTO(side=ipc_dto.side,
+                                                   cid=ipc_dto.cid,
+                                                   exception=ex,
+                                                   stacktrace=traceback.format_exc())
+            self._write(data=ipc_dto)
 
 
 class Toolbox(object):
@@ -179,3 +249,90 @@ class Toolbox(object):
         if len(name) <= maxlength:
             return name
         return '{0}~{1}'.format(name[:maxlength - 2], name[-1:])
+
+    @staticmethod
+    def execute(command, logger=None, **kwargs):
+        # type: (Union[str, List[str]], Optional[Logger], Any) -> str
+        proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
+                                close_fds=True, **kwargs)
+        output = b''
+        if proc.stdout is not None:
+            for line in proc.stdout:
+                if line and logger is not None:
+                    logger.info(line.rstrip(b'\n'))
+                output += line
+        return_code = proc.wait()
+        if return_code != 0:
+            raise Exception('Command {} failed'.format(command))
+        return str(output)
+
+    @staticmethod
+    def extract_tgz(filename, output_dir, logger=None):
+        Toolbox.execute(command=['tar', '--no-same-owner', '-xzf', filename, '-C', output_dir],
+                        logger=logger)
+
+    @staticmethod
+    def _touch(filename):
+        with open(filename, 'w') as file_:
+            file_.write('{0}\n'.format(filename))
+
+    @staticmethod
+    def calculate_checksum(filename):
+        # type: (str) -> Optional[str]
+        try:
+            hasher = hashlib.sha256()
+            with open(filename, 'rb') as f:
+                hasher.update(f.read())
+            calculated_hash = hasher.hexdigest()
+            return calculated_hash
+        except Exception:
+            pass
+        return None
+
+    @staticmethod
+    def download_urls(urls, checksum, logger, target_filename):  # type: (List[str], str, Logger, str) -> None
+        downloaded = False
+        with open(target_filename, 'wb') as handle:
+            for url in urls:
+                try:
+                    logger.info('Downloading {0} from {1} ...'.format(target_filename, url))
+                    if url.startswith('/'):
+                        with open(url, 'rb') as fd:
+                            shutil.copyfileobj(fd, handle)  # type: ignore
+                    else:
+                        response = requests.get(url,
+                                                verify=System.verify_requests(),
+                                                stream=True,
+                                                timeout=30)
+                        shutil.copyfileobj(response.raw, handle)
+                    downloaded = True
+                    break
+                except Exception as ex:
+                    logger.error('Could not download {0} from {1}: {2}'.format(target_filename, url, ex))
+        if not downloaded:
+            raise RuntimeError('No file could be downloaded for {0}'.format(target_filename))
+        actual_checksum = Toolbox.calculate_checksum(filename=target_filename)
+        if actual_checksum != checksum:
+            raise RuntimeError('Downloaded {0} checksum {1} does not match expected {2}'.format(target_filename, actual_checksum, checksum))
+
+    @staticmethod
+    def rw_mounted_root(logger):
+        class Remounter(object):
+            def __init__(self, cm_logger):
+                self.logger = cm_logger
+
+            def __enter__(self):
+                Toolbox.execute(command=['mount', '-o', 'remount,rw', '/'],
+                                logger=self.logger)
+
+            def __exit__(self, exc_type, exc_val, exc_tb):
+                _ = exc_type, exc_val, exc_tb
+                try:
+                    Toolbox.execute(command=['sync'],
+                                    logger=self.logger)
+                    Toolbox.execute(command=['mount', '-o', 'remount,ro', '/'],
+                                    logger=self.logger)
+                except Exception as ex:
+                    self.logger.error('Failed to remount readonly: {0}'.format(ex))
+
+        return Remounter(cm_logger=logger)
diff --git a/src/vpn_service.py b/src/vpn_service.py
index dc33d2c8..81b04f68 100644
--- a/src/vpn_service.py
+++ b/src/vpn_service.py
@@ -28,6 +28,7 @@ import logging.handlers
 import os
 import signal
 import subprocess
+import sys
 import time
 import traceback
 import shutil
@@ -65,7 +66,7 @@ class Cloud(object):
     """ Connects to the cloud """
     request_kwargs = {
         'timeout': 10.0,
-        'verify': System.get_operating_system().get('ID') != System.OS.ANGSTROM
+        'verify': System.verify_requests()
     }
 
     def __init__(self, url=None, uuid=None):
@@ -91,7 +92,7 @@ class Cloud(object):
         return urlunparse((self._url.scheme, self._url.netloc, path, '', query, ''))
 
     def authenticate(self, key_path=None, raise_exception=False):
-        if System.get_operating_system().get('ID') == System.OS.ANGSTROM:
+        if System.legacy_authentication():
             return
         try:
             import jwt
@@ -105,7 +106,7 @@ class Cloud(object):
                 client_key = fd.read()
             token = jwt.encode(payload, client_key, algorithm='RS256')
             data = {'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
-                    'assertion': token.decode(),
+                    'assertion': token,
                     'scope': 'device'}  # type: Dict[str, Any]
             response = requests.post(self._build_url('/api/v1.1/authentication/oauth2/token'), data=data)
             response.raise_for_status()
@@ -837,7 +838,7 @@ class UpdateCertsTask(Task):
 
     @staticmethod
     def verify_client_certificates(path):
-        if System.get_operating_system().get('ID') == System.OS.ANGSTROM:
+        if System.legacy_authentication():
             subprocess.check_output(['openssl', 'rsa', '-check', '-noout', '-in', os.path.join(path, 'client.key')])
             subprocess.check_output(['openssl', 'verify', '-CAfile', os.path.join(path, 'ca.crt'), os.path.join(path, 'client.crt')])
 
diff --git a/testing/cicd/tests/api_test.py b/testing/cicd/tests/api_test.py
index 68e46fd4..850c77b4 100644
--- a/testing/cicd/tests/api_test.py
+++ b/testing/cicd/tests/api_test.py
@@ -44,14 +44,14 @@ def test_version(toolbox):
     assert 'gateway' in data
 
 
-@pytest.fixture
+@pytest.mark.skip
 def set_timezone(request, toolbox):
     toolbox.dut.get('/set_timezone', params={'timezone': 'UTC'})
     yield
     toolbox.dut.get('/set_timezone', params={'timezone': 'UTC'})
 
 
-@pytest.mark.smoke
+@pytest.mark.skip
 def test_status_timezone(toolbox, set_timezone):
     data = toolbox.dut.get('/get_timezone')
     assert 'timezone' in data
@@ -64,7 +64,7 @@ def test_status_timezone(toolbox, set_timezone):
     assert now - timedelta(minutes=1) <= time <= now + timedelta(minutes=1)
 
 
-@pytest.mark.smoke
+@pytest.mark.skip
 def test_timezone_change(toolbox, set_timezone):
     toolbox.dut.get('/set_timezone', params={'timezone': 'America/Bahia'})
 
diff --git a/testing/cicd/tests/conftest.py b/testing/cicd/tests/conftest.py
index 58eee058..adb0e51f 100644
--- a/testing/cicd/tests/conftest.py
+++ b/testing/cicd/tests/conftest.py
@@ -28,6 +28,14 @@ settings.register_profile('ci', deadline=None, max_examples=100, stateful_step_c
 settings.load_profile(os.getenv('HYPOTHESIS_PROFILE', 'default'))
 
 
+def pytest_configure(config):
+    config.addinivalue_line(
+        "markers", "slow: marks a test as a loing running running test case"
+    )
+    config.addinivalue_line(
+        "markers", "smoke: marks a test as a fast test case for quick validation"
+    )
+
 @fixture(scope='session')
 def toolbox_session():
     toolbox = Toolbox()
@@ -72,6 +80,7 @@ def toolbox(toolbox_session, update):
     toolbox = toolbox_session
     toolbox.tester.get('/plugins/syslog_receiver/reset', success=False)
     toolbox.health_check(timeout=360)
+    toolbox.dut.login()
     toolbox.module_error_check()
     try:
         yield toolbox
diff --git a/testing/cicd/tests/hvac_setpoint_test b/testing/cicd/tests/hvac_setpoint_test
new file mode 100644
index 00000000..5932f4ce
--- /dev/null
+++ b/testing/cicd/tests/hvac_setpoint_test
@@ -0,0 +1,45 @@
+# Copyright (C) 2021 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+from __future__ import absolute_import
+
+import time
+import logging
+import hypothesis
+import pytest
+from hypothesis.strategies import booleans
+
+from tests.hardware import shutters, skip_on_platforms
+from tests.hardware_layout import TestPlatform
+
+if False:  # MYPY
+    from typing import Any
+    from tests.toolbox import Toolbox
+    from tests.hardware_layout import Shutter
+
+logger = logging.getLogger(__name__)
+
+
+#TODO test set - load hvac setpoint.
+
+@pytest.mark.smoke
+def test_get_hvac_setpoint(setpoint, mode, roomId):
+    data = toolbox.dut.get('/get_hvac_setpoint')
+    assert 'setpoint' in data
+    assert 'mode' in data
+
+
+@pytest.fixture
+def test_set_hvac_setpoint(setpoint, mode, roomId):
+    ''' set hvac setpoint and get '''
diff --git a/testing/cicd/tests/inputs_test.py b/testing/cicd/tests/inputs_test.py
index 2ceaeee5..f3d0b73f 100644
--- a/testing/cicd/tests/inputs_test.py
+++ b/testing/cicd/tests/inputs_test.py
@@ -44,6 +44,8 @@ def test_actions(toolbox, _input, output, to_status):
     input_config.update(DEFAULT_INPUT_CONFIG)
     toolbox.dut.get('/set_input_configuration', {'config': json.dumps(input_config)})
 
+    time.sleep(1)
+
     # NOTE ensure output status _after_ input configuration, changing
     # inputs can impact the output status for some reason.
     toolbox.ensure_output(output, from_status, DEFAULT_OUTPUT_CONFIG)
diff --git a/testing/cicd/tests/master_test.py b/testing/cicd/tests/master_test.py
index 0221961c..e8771392 100644
--- a/testing/cicd/tests/master_test.py
+++ b/testing/cicd/tests/master_test.py
@@ -46,7 +46,7 @@ def test_communication_recovery(toolbox, master_communication):
     toolbox.dut.get('/get_status')
 
 
-@pytest.mark.slow
+@pytest.mark.unstable
 def test_offline_recovery(toolbox, master_communication):
     data = toolbox.dut.get('/get_status', success=False)
     assert data['success'], data
diff --git a/testing/cicd/tests/mode_test.py b/testing/cicd/tests/mode_test.py
index 0bc31da3..41525efb 100644
--- a/testing/cicd/tests/mode_test.py
+++ b/testing/cicd/tests/mode_test.py
@@ -13,6 +13,7 @@
 # You should have received a copy of the GNU Affero General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 from __future__ import absolute_import
+
 import logging
 import socket
 import ssl
@@ -20,6 +21,7 @@ import time
 
 import psutil
 import pytest
+from tests.hardware_layout import TEST_PLATFORM, TestPlatform
 
 logger = logging.getLogger(__name__)
 
@@ -145,20 +147,27 @@ def test_factory_reset(toolbox, authorized_mode, factory_reset):
     toolbox.dut.login()
 
     data = toolbox.dut.get('/get_modules')
-    assert 'inputs' in data
-    assert data['inputs'] == []
-    assert 'outputs' in data
-    assert data['outputs'] == []
+    if TEST_PLATFORM != TestPlatform.CORE_PLUS:  # autodiscovery
+        assert 'inputs' in data
+        assert data['inputs'] == []
+        assert 'outputs' in data
+        assert data['outputs'] == []
 
     toolbox.initialize()
 
     data = toolbox.dut.get('/get_modules')
     assert 'inputs' in data
-    assert ['I', 'T'] == data['inputs']
     assert 'outputs' in data
-    assert ['O', 'D', 'o'] == data['outputs']
-    assert 'shutters' in data
-    assert ['S'] == data['shutters']
+    if TEST_PLATFORM == TestPlatform.CORE_PLUS:
+        assert ['J', 'I'] == data['inputs']
+        assert ['P','P','l','F','O'] == data['outputs']
+        assert 'can_inputs' in data
+        assert ['T', 'E'] == data['can_inputs']
+    if TEST_PLATFORM == TestPlatform.DEBIAN:
+        assert ['I', 'T'] == data['inputs']
+        assert ['O', 'D', 'o'] == data['outputs']
+        assert 'shutters' in data
+        assert ['S'] == data['shutters']
 
     data = toolbox.dut.get('/get_modules_information')
     modules = list(data['modules'].get('master', {}).values())
diff --git a/testing/cicd/tests/outputs_test.py b/testing/cicd/tests/outputs_test.py
index 1c1aca88..7d1c0a03 100644
--- a/testing/cicd/tests/outputs_test.py
+++ b/testing/cicd/tests/outputs_test.py
@@ -54,7 +54,7 @@ def test_status(toolbox, output, status):
     toolbox.assert_output_status(output, status)
 
 
-@pytest.mark.smoke
+@pytest.mark.unstable
 @hypothesis.given(outputs(), just(True))
 def test_timers(toolbox, output, to_status):
     from_status = not to_status
diff --git a/testing/cicd/tests/shutters_test.py b/testing/cicd/tests/shutters_test.py
index dec76124..adae47b2 100644
--- a/testing/cicd/tests/shutters_test.py
+++ b/testing/cicd/tests/shutters_test.py
@@ -42,7 +42,7 @@ def clean_shutters(toolbox_session):
             toolbox.configure_shutter(shutter, {'timer_up': 0, 'timer_down': 0, 'up_down_config': 1})
 
 
-@pytest.mark.smoke
+@pytest.mark.unstable  # FIXME: resolve stability issues on gen3
 @hypothesis.given(shutters(), booleans(), booleans())
 def test_shutter_moving(toolbox, clean_shutters, shutter, primary_direction, inverted):
     # type: (Toolbox, Any, Shutter, bool, bool) -> None
diff --git a/testing/cicd/tests/toolbox.py b/testing/cicd/tests/toolbox.py
index af0871d2..328d0488 100644
--- a/testing/cicd/tests/toolbox.py
+++ b/testing/cicd/tests/toolbox.py
@@ -316,27 +316,6 @@ class Toolbox(object):
             if module.shutters:
                 self.ensure_shutter_exists(module.shutters[-1], timeout=300)
 
-        # Make sure the eeprom cache of the gateway is filled
-        def _call(call):
-            try:
-                self.dut.get(call)
-            except Exception:
-                time.sleep(3)
-                self.dut.get(call)
-
-        _call('/get_cooling_configurations')
-        _call('/get_input_configurations')
-        _call('/get_output_configurations')
-        _call('/get_shutter_configurations')
-        _call('/get_shutter_group_configurations')
-        _call('/get_ventilation_configurations')
-        _call('/get_scheduled_action_configurations')
-        _call('/get_group_action_configurations')
-        _call('/get_sensor_configurations')
-        _call('/get_thermostat_configurations')
-
-        time.sleep(20)  # Give the master some additional rest before testing begins
-
     def print_logs(self):
         # type: () -> None
         try:
diff --git a/testing/unittests/api_tests/V1/notifications_test.py b/testing/unittests/api_tests/V1/notifications_test.py
deleted file mode 100644
index 80ffad8d..00000000
--- a/testing/unittests/api_tests/V1/notifications_test.py
+++ /dev/null
@@ -1,88 +0,0 @@
-# Copyright (C) 2021 OpenMotics BV
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Affero General Public License as
-# published by the Free Software Foundation, either version 3 of the
-# License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Affero General Public License for more details.
-#
-# You should have received a copy of the GNU Affero General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-"""
-Authentication api tests
-"""
-from __future__ import absolute_import
-
-import time
-import unittest
-
-import cherrypy
-import requests
-import ujson as json
-from mock import Mock, patch
-
-from gateway.api.V1.notifications import PluginNotification
-from gateway.authentication_controller import AuthenticationController, \
-    AuthenticationToken, LoginMethod
-from gateway.events import GatewayEvent
-from gateway.exceptions import *
-from gateway.user_controller import UserController
-from ioc import SetTestMode, SetUpTestInjections
-from plugin_runtime.sdk import NotificationSDK
-
-from .base import BaseCherryPyUnitTester
-
-from cloud.events import EventSender
-
-
-class PluginNotificationTests(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        SetTestMode()
-
-    def setUp(self):
-        self.auth_controller = Mock(AuthenticationController)
-        SetUpTestInjections(authentication_controller=self.auth_controller)
-        self.user_controller = Mock(UserController)
-        self.user_controller.authentication_controller = self.auth_controller
-        self.event_sender = Mock(EventSender)
-        SetUpTestInjections(event_sender=self.event_sender,
-                            user_controller=self.user_controller)
-        self.web = PluginNotification()
-
-    def test_register(self):
-        response = self.web.create(request_body={
-            'source': 'plugin',
-            'plugin': 'DummyPlugin',
-            'topic': 'test',
-            'message': 'example notification message',
-        })
-        expected = {}
-        self.assertEqual(expected, json.loads(response))
-        self.event_sender.enqueue_event.assert_called_with(
-            GatewayEvent('NOTIFICATION',
-                         {'source': 'plugin',
-                          'plugin': 'DummyPlugin',
-                          'type': 'USER',
-                          'topic': 'test',
-                          'message': 'example notification message'})
-        )
-
-    def test_plugin_sdk(self):
-        with patch.object(requests, 'request') as req:
-            req.json.return_value = {}
-            notification = NotificationSDK('https://api.example.org', 'DummyPlugin')
-            notification.send('test', 'example notification message')
-            req.assert_called_with('POST',
-                                   'https://api.example.org/plugin/notification',
-                                   headers={'User-Agent': 'Plugin DummyPlugin'},
-                                   timeout=30.0,
-                                   json={'source': 'plugin',
-                                         'plugin': 'DummyPlugin',
-                                         'type': 'USER',
-                                         'topic': 'test',
-                                         'message': 'example notification message'})
diff --git a/testing/unittests/api_tests/V1/sensors_test.py b/testing/unittests/api_tests/V1/sensors_test.py
index 07479660..4c6abf46 100644
--- a/testing/unittests/api_tests/V1/sensors_test.py
+++ b/testing/unittests/api_tests/V1/sensors_test.py
@@ -25,15 +25,13 @@ import requests
 import ujson as json
 from mock import Mock, patch
 
-from gateway.api.V1.sensors import PluginSensor
 from gateway.authentication_controller import AuthenticationController, \
     AuthenticationToken, LoginMethod
-from gateway.dto.sensor import SensorDTO, SensorSourceDTO
+from gateway.dto import SensorDTO, SourceDTO
 from gateway.exceptions import *
 from gateway.sensor_controller import SensorController
 from gateway.user_controller import UserController
 from ioc import SetTestMode, SetUpTestInjections
-from plugin_runtime.sdk import SensorSDK
 
 from .base import BaseCherryPyUnitTester
 
@@ -52,38 +50,3 @@ class PluginSensorTests(unittest.TestCase):
         SetUpTestInjections(sensor_controller=self.sensor_controller,
                             user_controller=self.user_controller)
         self.web = PluginSensor()
-
-    def test_register(self):
-        self.sensor_controller.register_sensor.return_value = SensorDTO(id=10,
-                                                                        name='Example',
-                                                                        physical_quantity='temperature',
-                                                                        unit='celcius')
-        response = self.web.register(request_body={
-            'source': 'plugin',
-            'plugin': 'DummyPlugin',
-            'external_id': '1111',
-            'physical_quantity': 'temperature',
-            'unit': 'celcius',
-            'config': {'name': 'Example'}
-        })
-        expected = {'id': 10, 'name': 'Example', 'room': None, 'physical_quantity': 'temperature', 'in_use': True}
-        self.assertEqual(expected, json.loads(response))
-        self.sensor_controller.register_sensor.assert_called_with(
-            SensorSourceDTO('plugin', name='DummyPlugin'), '1111', 'temperature', 'celcius', {'name': 'Example'}
-        )
-
-    def test_plugin_sdk(self):
-        with patch.object(requests, 'request') as req:
-            req.json.return_value = {}
-            notification = SensorSDK('https://api.example.org', 'DummyPlugin')
-            notification.register_temperature_celcius('1111')
-            req.assert_called_with('POST',
-                                   'https://api.example.org/plugin/sensor/register',
-                                   headers={'User-Agent': 'Plugin DummyPlugin'},
-                                   timeout=30.0,
-                                   json={'source': 'plugin',
-                                         'plugin': 'DummyPlugin',
-                                         'external_id': '1111',
-                                         'physical_quantity': 'temperature',
-                                         'unit': 'celcius',
-                                         'config': {}})
diff --git a/testing/unittests/api_tests/V1/ventilation_units_test.py b/testing/unittests/api_tests/V1/ventilation_units_test.py
index c962b8aa..76514f15 100644
--- a/testing/unittests/api_tests/V1/ventilation_units_test.py
+++ b/testing/unittests/api_tests/V1/ventilation_units_test.py
@@ -17,26 +17,21 @@ Authentication api tests
 """
 from __future__ import absolute_import
 
-import time
 import unittest
 
-import cherrypy
-from mock import Mock, patch
-import requests
 import ujson as json
+from mock import Mock, patch
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.pool import StaticPool
 
-from gateway.api.V1.ventilation_units import PluginVentilation, \
-    VentilationUnits
-from gateway.authentication_controller import AuthenticationController, \
-    AuthenticationToken, LoginMethod
-from gateway.dto.ventilation import VentilationDTO, VentilationSourceDTO
-from gateway.exceptions import *
+from gateway.api.V1.ventilation_units import VentilationUnits
+from gateway.authentication_controller import AuthenticationController
+from gateway.dto import PluginDTO, SourceDTO, VentilationDTO
+from gateway.models import Base, Database, Plugin
 from gateway.user_controller import UserController
 from gateway.ventilation_controller import VentilationController
 from ioc import SetTestMode, SetUpTestInjections
-from plugin_runtime.sdk import VentilationSDK
-
-from .base import BaseCherryPyUnitTester
 
 
 class VentilationUnitsApiTests(unittest.TestCase):
@@ -53,12 +48,29 @@ class VentilationUnitsApiTests(unittest.TestCase):
                                               name='foo',
                                               device_vendor='OpenMotics',
                                               external_id='1111',
-                                              source=VentilationSourceDTO('plugin', name='DummyPlugin'))
+                                              plugin=PluginDTO(1, name='DummyPlugin'),
+                                              source=SourceDTO(source='plugin', source_id=1))
         self.ventilation_controller = Mock(VentilationController)
         self.ventilation_controller.load_ventilations.return_value = [self.ventilation_dto]
         SetUpTestInjections(ventilation_controller=self.ventilation_controller,
                             user_controller=self.user_controller)
         self.web = VentilationUnits()
+        engine = create_engine(
+            'sqlite://', connect_args={'check_same_thread': False}, poolclass=StaticPool
+        )
+        Base.metadata.create_all(engine)
+        session_factory = sessionmaker(autocommit=False, autoflush=True, bind=engine)
+
+        self.session = session_factory()
+        session_mock = patch.object(Database, 'get_session', return_value=self.session)
+        session_mock.start()
+        self.addCleanup(session_mock.stop)
+
+        with Database.get_session() as db:
+            db.add(Plugin(id=1,
+                          name='DummyPlugin',
+                          version='0.0.1'))
+            db.commit()
 
     def test_ventilation_units_list(self):
         response = self.web.list()
@@ -66,9 +78,10 @@ class VentilationUnitsApiTests(unittest.TestCase):
             {'id': 1,
              'name': 'foo',
              'room': None,
-             'amount_of_levels': 0,
              'source': 'plugin',
+             'plugin': 'DummyPlugin',
              'external_id': '1111',
+             'amount_of_levels': 0,
              'device': {'vendor': 'OpenMotics', 'type': '', 'serial': ''}},
         ]
         self.assertEqual(expected, json.loads(response))
@@ -86,52 +99,9 @@ class VentilationUnitsApiTests(unittest.TestCase):
         expected = {'id': 1,
                     'name': 'foo',
                     'room': 2,
-                    'amount_of_levels': 4,
-                    'source': None}
+                    'source': None,
+                    'amount_of_levels': 4}
         self.assertEqual(expected, json.loads(response))
         self.ventilation_controller.save_ventilation.assert_called_with(
             VentilationDTO(1, name='foo', room=2, amount_of_levels=4)
         )
-
-class PluginVentilationTests(unittest.TestCase):
-    @classmethod
-    def setUpClass(cls):
-        SetTestMode()
-
-    def setUp(self):
-        self.auth_controller = Mock(AuthenticationController)
-        SetUpTestInjections(authentication_controller=self.auth_controller)
-        self.user_controller = Mock(UserController)
-        self.user_controller.authentication_controller = self.auth_controller
-        self.ventilation_controller = Mock(VentilationController)
-        SetUpTestInjections(ventilation_controller=self.ventilation_controller,
-                            user_controller=self.user_controller)
-        self.web = PluginVentilation()
-
-    def test_register(self):
-        self.ventilation_controller.register_ventilation.return_value = VentilationDTO(id=10, amount_of_levels=4)
-        response = self.web.register(request_body={
-            'source': 'plugin',
-            'plugin': 'DummyPlugin',
-            'external_id': '1111',
-            'config': {'amount_of_levels': 4}
-        })
-        expected = {'id': 10, 'name': '', 'room': None}
-        self.assertEqual(expected, json.loads(response))
-        self.ventilation_controller.register_ventilation.assert_called_with(
-            VentilationSourceDTO('plugin', name='DummyPlugin'), '1111', {'amount_of_levels': 4}
-        )
-
-    def test_plugin_sdk(self):
-        with patch.object(requests, 'request') as req:
-            req.json.return_value = {}
-            notification = VentilationSDK('https://api.example.org', 'DummyPlugin')
-            notification.register('1111', {'amount_of_levels': 4})
-            req.assert_called_with('POST',
-                                   'https://api.example.org/plugin/ventilation/register',
-                                   headers={'User-Agent': 'Plugin DummyPlugin'},
-                                   timeout=30.0,
-                                   json={'source': 'plugin',
-                                         'plugin': 'DummyPlugin',
-                                         'external_id': '1111',
-                                         'config': {'amount_of_levels': 4}})
diff --git a/testing/unittests/api_tests/serializers/sensor_test.py b/testing/unittests/api_tests/serializers/sensor_test.py
index cd0ad892..3815599b 100644
--- a/testing/unittests/api_tests/serializers/sensor_test.py
+++ b/testing/unittests/api_tests/serializers/sensor_test.py
@@ -15,7 +15,7 @@
 from __future__ import absolute_import
 
 import unittest
-from gateway.dto import SensorDTO, SensorSourceDTO
+from gateway.dto import SensorDTO, SourceDTO
 from gateway.api.serializers import SensorSerializer
 
 
@@ -50,7 +50,7 @@ class SensorSerializerTest(unittest.TestCase):
                                             'room': 10})
         expected_dto = SensorDTO(id=5,
                                  external_id='0',
-                                 source=SensorSourceDTO('master', name=None),
+                                 source=SourceDTO('master'),
                                  physical_quantity='temperature',
                                  unit='celcius',
                                  name='bar',
@@ -82,3 +82,28 @@ class SensorSerializerTest(unittest.TestCase):
                                               'physical_quantity': 'temperature',
                                               'unit': 'unicorns',
                                               'name': 'bar'})
+
+    def test_sensors_energy(self):
+        for (physical_quantity, unit) in [('electric_potential', 'volt'),
+                                          ('electric_current', 'ampere'),
+                                          ('frequency', 'hertz'),
+                                          ('energy', 'kilo_watt_hour'),
+                                          ('energy', 'joule'),
+                                          ('power', 'watt')]:
+            dto = SensorSerializer.deserialize({'id': 5,
+                                                'external_id': '0',
+                                                'source': {'type': 'gateway'},
+                                                'physical_quantity': physical_quantity,
+                                                'unit': unit,
+                                                'name': 'foo',
+                                                'room': 10})
+            expected_dto = SensorDTO(id=5,
+                                     external_id='0',
+                                     source=SourceDTO('gateway'),
+                                     physical_quantity=physical_quantity,
+                                     unit=unit,
+                                     name='foo',
+                                     room=10)
+            assert expected_dto == dto
+            self.assertEqual(expected_dto, dto)
+            self.assertEqual(['external_id', 'id', 'name', 'physical_quantity', 'room', 'source', 'unit'], sorted(dto.loaded_fields))
diff --git a/testing/unittests/gateway_tests/hal/master_controller_core_test.py b/testing/unittests/gateway_tests/hal/master_controller_core_test.py
index 8eea74cd..f16e1552 100644
--- a/testing/unittests/gateway_tests/hal/master_controller_core_test.py
+++ b/testing/unittests/gateway_tests/hal/master_controller_core_test.py
@@ -12,10 +12,12 @@ from enums import HardwareType, OutputType
 import gateway.hal.master_controller_core
 from gateway.dto import InputDTO, OutputStatusDTO, OutputDTO, PulseCounterDTO
 from gateway.dto.input import InputStatusDTO
+from gateway.hal.mappers_core import GroupActionMapper
 from gateway.hal.master_controller_core import MasterCoreController
 from gateway.hal.master_event import MasterEvent
 from gateway.pubsub import PubSub
 from ioc import SetTestMode
+from master.core.basic_action import BasicAction
 from master.core.can_feedback import CANFeedbackController
 from master.core.core_api import CoreAPI
 from master.core.core_communicator import BackgroundConsumer
@@ -385,6 +387,10 @@ class MasterCoreControllerTest(unittest.TestCase):
         self.assertEqual(expected_pulse_counters, [pc for pc in self.controller.load_pulse_counters()
                                                    if pc.id in [0, 1, 20]])
 
+    def test_master_serial_number(self):
+        serial = self.controller.get_serial_number(update=True)
+        self.assertEqual(serial, '999999999999')
+
 
 class MasterInputState(unittest.TestCase):
     @classmethod
@@ -472,6 +478,26 @@ class MasterInputState(unittest.TestCase):
             new_percentage = Dimmer.system_value_to_dimmer(new_svt)
             self.assertEqual(recovered_percentage, new_percentage)
 
+    def test_dimmer_automation_stability(self):
+        # Validates correct implementation of gen2 to gen3 conversion of dimmer automations
+        gen2_actions = [x for x in range(176, 195, 1)]
+        gen3_actions = []
+        gen3_actions_expected = [BasicAction(action_type=0, action=2,  device_nr=0, extra_parameter=Dimmer.dimmer_to_system_value(x)) for x in range(10, 100, 10)] + \
+                                [BasicAction(action_type=0, action=17, device_nr=0, extra_parameter=Dimmer.dimmer_to_system_value(y)) for y in range(10, 110, 10)]
+        # validate turn dimmer on with value
+        for action in gen2_actions[0:9]:
+            value = GroupActionMapper._action_type_to_gen3_dimmer(action)
+            gen3_actions.append(BasicAction(action_type=0, action=2, device_nr=0, extra_parameter=value))
+
+        # validate toggle dimmer with value
+        for action in gen2_actions[9:19]:
+            value = GroupActionMapper._action_type_to_gen3_dimmer(action)
+            gen3_actions.append(BasicAction(action_type=0, action=17, device_nr=0, extra_parameter=value))
+
+        action_tests = zip(gen3_actions, gen3_actions_expected)
+        for (action, expected) in action_tests:
+            self.assertEqual(action, expected)
+
 
 def get_core_output_dummy(i):
     return OutputConfiguration.deserialize({
diff --git a/testing/unittests/gateway_tests/mappers/thermostat_test.py b/testing/unittests/gateway_tests/mappers/thermostat_test.py
index e92d23ff..5628ad5d 100644
--- a/testing/unittests/gateway_tests/mappers/thermostat_test.py
+++ b/testing/unittests/gateway_tests/mappers/thermostat_test.py
@@ -21,15 +21,16 @@ from sqlalchemy import create_engine
 from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.pool import StaticPool
 
-from gateway.dto import PumpGroupDTO, SensorStatusDTO, ThermostatDTO, \
+from gateway.dto import PumpGroupDTO, SensorStateDTO, ThermostatDTO, \
     ThermostatScheduleDTO
 from gateway.hal.mappers_classic import PumpGroupMapper
 from gateway.mappers.thermostat import ThermostatMapper, \
     ThermostatScheduleMapper
 from gateway.models import Base, Database, DaySchedule, Feature, Output, \
-    OutputToThermostatGroupAssociation, Preset, Pump, PumpToValveAssociation, \
+    HvacOutputLink, Preset, Pump, PumpToValveAssociation, \
     Room, Sensor, Thermostat, ThermostatGroup, Valve, \
-    ValveToThermostatAssociation
+    IndoorLinkValves
+    
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
 from master.classic.eeprom_models import PumpGroupConfiguration
@@ -90,21 +91,20 @@ class ThermostatMapperTests(unittest.TestCase):
                 ThermostatGroup(id=2, number=1, name='group'),
                 Thermostat(number=0, name='thermostat', start=0, thermostat_group_id=2),
                 Valve(name='Valve (output 8)', output_id=1),
-                ValveToThermostatAssociation(valve_id=1, thermostat_id=1, priority=3)
+                IndoorLinkValves(valve_id=1, thermostat_link_id=1)
             ])
             db.commit()
 
         thermostat_dto = ThermostatDTO(id=0, output0=8, output1=9)
         with self.session as db:
             update, _ = ThermostatMapper(db).get_valve_links(thermostat_dto, 'heating')
-            assert [x.valve.name for x in update] == ['Valve (output 8)', 'Valve (output 9)']
+            assert [x.valve.name for x in update] == ['Valve (output 9)']
             db.add_all(update)
             db.commit()
 
         with self.session as db:
             thermostat = db.get(Thermostat, 1)
             assert [x.name for x in thermostat.valves] == ['Valve (output 8)', 'Valve (output 9)']
-            assert [x.priority for x in thermostat.heating_valve_associations] == [0, 1]
 
         with self.session as db:
             update, remove = ThermostatMapper(db).get_valve_links(thermostat_dto, 'heating')
@@ -116,7 +116,6 @@ class ThermostatMapperTests(unittest.TestCase):
             update, remove = ThermostatMapper(db).get_valve_links(thermostat_dto, 'heating')
             assert [x.valve.name for x in update] == []
             assert len(remove) == 1
-            assert [x.priority for x in remove] == [1]
 
     def test_day_schedules(self):
         with self.session as db:
diff --git a/testing/unittests/gateway_tests/metrics_collector_test.py b/testing/unittests/gateway_tests/metrics_collector_test.py
index a350c6f3..b22a89ee 100644
--- a/testing/unittests/gateway_tests/metrics_collector_test.py
+++ b/testing/unittests/gateway_tests/metrics_collector_test.py
@@ -16,7 +16,7 @@ from __future__ import absolute_import
 
 import unittest
 import mock
-from gateway.dto import SensorDTO, SensorStatusDTO, RealtimeEnergyDTO, EnergyModuleDTO, TotalEnergyDTO
+from gateway.dto import SensorDTO, SensorStateDTO, RealtimeEnergyDTO, EnergyModuleDTO, TotalEnergyDTO
 from gateway.dto.shutter import ShutterStatusDTO, ShutterDTO
 from gateway.metrics_collector import MetricsCollector
 from gateway.sensor_controller import SensorController
@@ -80,7 +80,7 @@ class MetricsCollectorTest(unittest.TestCase):
     def test_sensor_metrics(self):
         sensor_dto = SensorDTO(id=42, source='master', external_id='0', physical_quantity='temperature', unit='celcius', name='foo')
         self.controller._environment_sensors = {42: sensor_dto}
-        self.sensor_controller.get_sensors_status.return_value = [SensorStatusDTO(id=42, value=21.0)]
+        self.sensor_controller.get_sensors_status.return_value = [SensorStateDTO(id=42, value=21.0)]
         with mock.patch.object(self.controller, '_enqueue_metrics') as enqueue:
             self.controller._process_sensors('sensor')
             expected_call = mock.call(timestamp=mock.ANY,
diff --git a/testing/unittests/gateway_tests/migrations/thermostats_test.py b/testing/unittests/gateway_tests/migrations/thermostats_test.py
index 5cc7bc49..25012676 100644
--- a/testing/unittests/gateway_tests/migrations/thermostats_test.py
+++ b/testing/unittests/gateway_tests/migrations/thermostats_test.py
@@ -17,16 +17,22 @@ from __future__ import absolute_import
 import unittest
 
 import mock
+import shutil
+from tempfile import mkdtemp
 from sqlalchemy import create_engine
 from sqlalchemy.orm import sessionmaker
 from sqlalchemy.pool import StaticPool
+
+from gateway.enums import SensorEnums, Source
 from platform_utils import Platform
+from gateway.enums import SensorEnums
 from gateway.models import Base, Database, ThermostatGroup, Sensor, Output, \
-    Thermostat, Valve, ValveToThermostatAssociation, NoResultFound, \
+    Thermostat, Valve, IndoorLinkValves, NoResultFound, \
     Preset, DaySchedule, Pump
 from gateway.migrations.thermostats import ThermostatsMigrator, \
     GlobalThermostatConfiguration, ThermostatConfiguration, CoolingConfiguration, PumpGroupConfiguration
 from ioc import SetTestMode
+from logs import Logs
 
 
 class ThermostatMigratorTest(unittest.TestCase):
@@ -45,6 +51,11 @@ class ThermostatMigratorTest(unittest.TestCase):
         session_mock = mock.patch.object(Database, 'get_session', return_value=self.session)
         session_mock.start()
         self.addCleanup(session_mock.stop)
+        self.temp_log_dir = mkdtemp()
+        Logs.UPDATE_LOGS_FOLDER = self.temp_log_dir
+
+    def tearDown(self):
+        shutil.rmtree(self.temp_log_dir)
 
     @mock.patch.object(Platform, 'get_platform', return_value=Platform.Type.CLASSIC)
     @mock.patch.object(ThermostatsMigrator, '_read_global_configuration')
@@ -104,7 +115,7 @@ class ThermostatMigratorTest(unittest.TestCase):
             CoolingConfiguration.from_dict({'id': 0,
                                             'name': 'Cooling 0',
                                             'setp0': 24.0, 'setp1': 25.0, 'setp2': 26.0, 'setp3': 27.0, 'setp4': 28.0, 'setp5': 29.0,
-                                            'sensor': 4,  # This sensor will be ignored due to architecture
+                                            'sensor': 4,  # Will cause a migration failure
                                             'output0': 6, 'output1': 255,
                                             'pid_p': 10, 'pid_i': 20, 'pid_d': 30, 'pid_int': 40,
                                             'permanent_manual': 255,
@@ -124,20 +135,20 @@ class ThermostatMigratorTest(unittest.TestCase):
 
         with self.session as db:
             sensor_1 = Sensor(external_id='1',
-                              physical_quantity=Sensor.PhysicalQuantities.TEMPERATURE,
-                              source=Sensor.Sources.MASTER,
+                              physical_quantity=SensorEnums.PhysicalQuantities.TEMPERATURE,
+                              source=Source.MASTER,
                               name='Sensor 1')
             sensor_2 = Sensor(external_id='2',
-                              physical_quantity=Sensor.PhysicalQuantities.TEMPERATURE,
-                              source=Sensor.Sources.MASTER,
+                              physical_quantity=SensorEnums.PhysicalQuantities.TEMPERATURE,
+                              source=Source.MASTER,
                               name='Sensor 2')
             sensor_3 = Sensor(external_id='3',
-                              physical_quantity=Sensor.PhysicalQuantities.TEMPERATURE,
-                              source=Sensor.Sources.MASTER,
+                              physical_quantity=SensorEnums.PhysicalQuantities.TEMPERATURE,
+                              source=Source.MASTER,
                               name='Sensor 3')
             sensor_4 = Sensor(external_id='4',
-                              physical_quantity=Sensor.PhysicalQuantities.TEMPERATURE,
-                              source=Sensor.Sources.MASTER,
+                              physical_quantity=SensorEnums.PhysicalQuantities.TEMPERATURE,
+                              source=Source.MASTER,
                               name='Sensor 4')
             output_5 = Output(number=5)
             output_6 = Output(number=6)
@@ -159,6 +170,12 @@ class ThermostatMigratorTest(unittest.TestCase):
                                    name='Default group'))
             db.commit()
 
+            with self.assertRaises(ValueError):
+                # here we expect a ValueError, but why?
+                ThermostatsMigrator._migrate()
+
+            rcc.return_value[0].sensor = 2
+
             ThermostatsMigrator._migrate()
 
             dmt.assert_called_once()
@@ -182,14 +199,14 @@ class ThermostatMigratorTest(unittest.TestCase):
             self.assertEqual(expected_thermostat_0,
                              ThermostatMigratorTest._extract_dict(thermostat_0,
                                                                   expected_thermostat_0.keys()))
-            heating_valve = db.query(Valve).join(ValveToThermostatAssociation).where((ValveToThermostatAssociation.thermostat == thermostat_0) &
-                                                                                     (ValveToThermostatAssociation.mode == 'heating')).one()  # type: Valve
-            self.assertEqual([{'priority': 0, 'thermostat_id': thermostat_0.id, 'mode': 'heating', 'valve_id': heating_valve.id}],
+            heating_valve = db.query(Valve).join(IndoorLinkValves).where((IndoorLinkValves.thermostat_link_id == thermostat_0.id) &
+                                                                    (IndoorLinkValves.mode == 'heating')).one()  # type: Valve
+            self.assertEqual([{'id': 4, 'thermostat_link_id': thermostat_0.id, 'mode': 'heating', 'valve_id': heating_valve.id}],
                              [ThermostatMigratorTest._extract_dict(x) for x in thermostat_0.heating_valve_associations])
             self.assertEqual(output_5.id, heating_valve.output_id)
-            cooling_valve = db.query(Valve).join(ValveToThermostatAssociation).where((ValveToThermostatAssociation.thermostat == thermostat_0) &
-                                                                                     (ValveToThermostatAssociation.mode == 'cooling')).one()  # type: Valve
-            self.assertEqual([{'priority': 0, 'thermostat_id': thermostat_0.id, 'mode': 'cooling', 'valve_id': cooling_valve.id}],
+            cooling_valve = db.query(Valve).join(IndoorLinkValves).where((IndoorLinkValves.thermostat_link_id == thermostat_0.id) &
+                                                                    (IndoorLinkValves.mode == 'cooling')).one()  # type: Valve
+            self.assertEqual([{'id': 7, 'thermostat_link_id': thermostat_0.id, 'mode': 'cooling', 'valve_id': cooling_valve.id}],
                              [ThermostatMigratorTest._extract_dict(x) for x in thermostat_0.cooling_valve_associations])
             self.assertEqual(output_6.id, cooling_valve.output_id)
             self.assertEqual(sensor_2.id, thermostat_0.sensor.id)
@@ -207,15 +224,18 @@ class ThermostatMigratorTest(unittest.TestCase):
             self.assertEqual(expected_thermostat_1,
                              ThermostatMigratorTest._extract_dict(thermostat_1,
                                                                   expected_thermostat_1.keys()))
-            heating_valves = db.query(Valve).join(ValveToThermostatAssociation).where((ValveToThermostatAssociation.thermostat == thermostat_1) &
-                                                                                      (ValveToThermostatAssociation.mode == 'heating'))
-            self.assertEqual([{'priority': heating_valve.thermostat_associations[0].priority, 'thermostat_id': thermostat_1.id,
-                               'mode': 'heating', 'valve_id': heating_valve.id}
-                              for heating_valve in heating_valves],
-                             [ThermostatMigratorTest._extract_dict(x) for x in thermostat_1.heating_valve_associations])
+            heating_valves = db.query(Valve).join(IndoorLinkValves).where((IndoorLinkValves.thermostat_link_id == thermostat_1.id) &
+                                                                    (IndoorLinkValves.mode == 'heating'))  # type: list[Valve]
+
+            v1 = [{'thermostat_link_id': thermostat_1.id, 'mode': 'heating', 'valve_id': heating_valve.id} for heating_valve in heating_valves]
+            v2 = [ThermostatMigratorTest._extract_dict(x) for x in thermostat_1.heating_valve_associations]
+            for v in v2:
+                del v['id']
+            self.assertEqual(v1, v2)
+            
             self.assertEqual(sorted([output_6.id, output_7.id]), sorted(v.output_id for v in heating_valves))
-            cooling_valve = db.query(Valve).join(ValveToThermostatAssociation).where((ValveToThermostatAssociation.thermostat == thermostat_1) &
-                                                                                     (ValveToThermostatAssociation.mode == 'cooling')).first()
+            cooling_valve = db.query(Valve).join(IndoorLinkValves).where((IndoorLinkValves.thermostat_link_id == thermostat_1.id) &
+                                                                        (IndoorLinkValves.mode == 'cooling')).first()
             self.assertIsNone(cooling_valve)
             self.assertEqual(sensor_3.id, thermostat_1.sensor.id)
 
diff --git a/testing/unittests/gateway_tests/notification_controller_test.py b/testing/unittests/gateway_tests/notification_controller_test.py
new file mode 100644
index 00000000..9c79608f
--- /dev/null
+++ b/testing/unittests/gateway_tests/notification_controller_test.py
@@ -0,0 +1,76 @@
+# Copyright (C) 2022 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Notification controller test
+"""
+from __future__ import absolute_import
+
+import unittest
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.pool import StaticPool
+from mock import Mock, patch
+
+from gateway.dto import SourceDTO
+from gateway.enums import Source, NotificationEnums
+from gateway.events import GatewayEvent
+from gateway.models import Base, Database, Plugin
+from gateway.notification_controller import NotificationController
+from ioc import SetTestMode, SetUpTestInjections
+
+from cloud.events import EventSender
+
+
+class NotificationControllerTests(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        SetTestMode()
+
+    def setUp(self):
+        engine = create_engine(
+            'sqlite://', connect_args={'check_same_thread': False}, poolclass=StaticPool
+        )
+        Base.metadata.create_all(engine)
+        session_factory = sessionmaker(autocommit=False, autoflush=True, bind=engine)
+
+        self.session = session_factory()
+        session_mock = patch.object(Database, 'get_session', return_value=self.session)
+        session_mock.start()
+        self.addCleanup(session_mock.stop)
+
+        self.event_sender = Mock(EventSender)
+        SetUpTestInjections(event_sender=self.event_sender,
+                            plugin_controller=Mock())
+        self.controller = NotificationController()
+
+    def test_process_plugin_callback(self):
+        with Database.get_session() as db:
+            db.add(Plugin(name='Dummy', version='0.0.1'))
+            db.commit()
+            plugin_id = db.query(Plugin).filter_by(name='Dummy').one().id
+        self.controller._plugin_notification_callback_action(source=SourceDTO(source=Source.PLUGIN,
+                                                                              source_id=plugin_id),
+                                                             action=NotificationEnums.CallbackAction.SEND,
+                                                             action_payload={'type': NotificationEnums.Type.USER,
+                                                                             'topic': 'foo',
+                                                                             'message': 'bar'})
+        self.event_sender.enqueue_event.assert_called_with(
+            GatewayEvent('NOTIFICATION',
+                         {'source': 'plugin',
+                          'plugin': 'Dummy',
+                          'type': 'USER',
+                          'topic': 'foo',
+                          'message': 'bar'})
+        )
diff --git a/testing/unittests/gateway_tests/scheduling_controller_test.py b/testing/unittests/gateway_tests/scheduling_controller_test.py
index 181a078a..ca3278af 100644
--- a/testing/unittests/gateway_tests/scheduling_controller_test.py
+++ b/testing/unittests/gateway_tests/scheduling_controller_test.py
@@ -32,6 +32,7 @@ from gateway.hal.master_controller import MasterController
 from gateway.models import Base, Database, DaySchedule, Schedule
 from gateway.pubsub import PubSub
 from gateway.scheduling_controller import SchedulingController
+from gateway.thermostat.gateway.setpoint_controller import SetpointController
 from gateway.system_controller import SystemController
 from gateway.webservice import WebInterface
 from ioc import SetTestMode, SetUpTestInjections
@@ -62,6 +63,7 @@ class SchedulingControllerTest(unittest.TestCase):
 
         self.group_action_controller = mock.Mock(GroupActionController)
         self.master_controller = mock.Mock(MasterController)
+
         SetUpTestInjections(master_controller=self.master_controller,
                             message_client=None,
                             module_controller=None,
@@ -83,98 +85,80 @@ class SchedulingControllerTest(unittest.TestCase):
                             update_controller=None,
                             event_sender=None,
                             user_controller=None,
-                            ventilation_controller=None)
-        self.controller = SchedulingController()
-        SetUpTestInjections(scheduling_controller=self.controller)
+                            ventilation_controller=None,
+                            hvac_controller=None)
+
+        self.scheduling_controller = SchedulingController()
+        SetUpTestInjections(scheduling_controller=self.scheduling_controller)
+        self.setpoint_controller = SetpointController()
+
         self.web_interface = WebInterface()
-        self.controller.set_webinterface(self.web_interface)
+        self.scheduling_controller.set_webinterface(self.web_interface)
         self.scheduler = mock.Mock(BackgroundScheduler)
         self.scheduler.get_job.return_value = None
-        self.controller._scheduler = self.scheduler
+        self.scheduling_controller._scheduler = self.scheduler
         # patch: do not wait to async sync_configuration using a new thread, but directly sync inline for testing
-        mock_refresh = mock.patch.object(self.controller, 'refresh_schedules',
-                                         side_effect=self.controller._sync_configuration)
+        mock_refresh = mock.patch.object(self.scheduling_controller, 'refresh_schedules',
+                                         side_effect=self.scheduling_controller._sync_configuration)
         mock_refresh.start()
-        self.controller._scheduler.start()
+        self.scheduling_controller._scheduler.start()
 
     def tearDown(self):
-        self.controller.stop()
+        self.scheduling_controller.stop()
 
     def test_save_load(self):
         dto = ScheduleDTO(id=None, name='schedule', start=0, action='GROUP_ACTION', arguments=0)
-        self.controller.save_schedules([dto])
-        loaded_dto = self.controller.load_schedule(schedule_id=1)
+        self.scheduling_controller.save_schedules([dto])
+        loaded_dto = self.scheduling_controller.load_schedule(schedule_id=1)
         for field in ['name', 'start', 'action', 'repeat', 'duration', 'end', 'arguments']:
             self.assertEqual(getattr(dto, field), getattr(loaded_dto, field))
         self.assertEqual('ACTIVE', loaded_dto.status)
-        self.controller._schedules = {}  # Clear internal cache
-        self.controller._sync_configuration()
-        loaded_dto = self.controller.load_schedule(schedule_id=1)
+        self.scheduling_controller._schedules = {}  # Clear internal cache
+        self.scheduling_controller._sync_configuration()
+        loaded_dto = self.scheduling_controller.load_schedule(schedule_id=1)
         for field in ['name', 'start', 'action', 'repeat', 'duration', 'end', 'arguments']:
             self.assertEqual(getattr(dto, field), getattr(loaded_dto, field))
         self.assertEqual('ACTIVE', loaded_dto.status)
 
     def test_pause_resume(self):
         schedule_dto = ScheduleDTO(id=1, name='schedule', start=0, action='GROUP_ACTION', arguments=0)
-        self.controller.save_schedules([schedule_dto])
+        self.scheduling_controller.save_schedules([schedule_dto])
 
-        with mock.patch.object(self.controller, '_abort') as abort:
-            self.controller.set_schedule_status(schedule_dto.id, 'PAUSED')
-            self.assertNotIn(schedule_dto.id, self.controller._schedules)  # disable schedule
+        with mock.patch.object(self.scheduling_controller, '_abort') as abort:
+            self.scheduling_controller.set_schedule_status(schedule_dto.id, 'PAUSED')
+            self.assertNotIn(schedule_dto.id, self.scheduling_controller._schedules)  # disable schedule
             abort.assert_called()
 
-        with mock.patch.object(self.controller, '_submit_schedule') as submit:
-            self.controller.set_schedule_status(schedule_dto.id, 'ACTIVE')
-            self.assertIn(schedule_dto.id, self.controller._schedules)  # enable schedule
+        with mock.patch.object(self.scheduling_controller, '_submit_schedule') as submit:
+            self.scheduling_controller.set_schedule_status(schedule_dto.id, 'ACTIVE')
+            self.assertIn(schedule_dto.id, self.scheduling_controller._schedules)  # enable schedule
             submit.assert_called()
 
-    def test_update_thermostat_setpoints(self):
-        self.controller.update_thermostat_setpoints(0, 'heating', [
-            DaySchedule(id=10, index=0, content='{"21600": 21.5}')
-        ])
-        jobs = self.controller._scheduler.get_jobs()
-        assert len(self.scheduler.add_job.call_args_list) == 1
-        job_id = self.scheduler.add_job.call_args_list[0][1]['id']
-        assert job_id == 'thermostat.heating.0.mon.06h00m'
-        setpoint_dto = self.scheduler.add_job.call_args_list[0][1]['args'][0]
-        assert setpoint_dto.thermostat == 0
-        assert setpoint_dto.temperature == 21.5
-
-        self.controller.update_thermostat_setpoints(0, 'heating', [
-            DaySchedule(id=10, index=0, content='{"28800": 22.0}')
-        ])
-        assert len(self.scheduler.add_job.call_args_list) == 2
-        job_id = self.scheduler.add_job.call_args_list[1][1]['id']
-        assert job_id == 'thermostat.heating.0.mon.08h00m'
-        setpoint_dto = self.scheduler.add_job.call_args_list[1][1]['args'][0]
-        assert setpoint_dto.thermostat == 0
-        assert setpoint_dto.temperature == 22.0
-
     def test_base_validation(self):
         with self.assertRaises(RuntimeError):
             # Must have a name
             schedule = Schedule(name=None)
-            self.controller._validate(schedule)
+            self.scheduling_controller._validate(schedule)
         with self.assertRaises(RuntimeError):
             # Unaccepted action
             schedule = Schedule(name='test', start=time.time(), action='FOO')
-            self.controller._validate(schedule)
+            self.scheduling_controller._validate(schedule)
         with self.assertRaises(RuntimeError):
             # Duration too short
             schedule = Schedule(name='test', start=time.time(), action='GROUP_ACTION', duration=10)
-            self.controller._validate(schedule)
+            self.scheduling_controller._validate(schedule)
         with self.assertRaises(RuntimeError):
             # End when not repeating
             schedule = Schedule(name='test', start=time.time(), action='GROUP_ACTION', end=time.time() + 1)
-            self.controller._validate(schedule)
+            self.scheduling_controller._validate(schedule)
         with self.assertRaises(RuntimeError):
             # Invalid repeat string
             schedule = Schedule(name='test', start=time.time(), action='GROUP_ACTION', repeat='foo')
-            self.controller._validate(schedule)
+            self.scheduling_controller._validate(schedule)
 
     def test_validate_group_action(self):
-        # New self.controller is empty
-        self.assertEqual(0, len(self.controller.load_schedules()))
+        # New self.scheduling_controller is empty
+        self.assertEqual(0, len(self.scheduling_controller.load_schedules()))
 
         # Doesn't support duration
         with self.assertRaises(RuntimeError) as ctx:
@@ -198,14 +182,14 @@ class SchedulingControllerTest(unittest.TestCase):
                                    start=time.time() + 0.5,
                                    action='GROUP_ACTION',
                                    arguments=1)
-        self.controller._execute_schedule(schedule_dto)
+        self.scheduling_controller._execute_schedule(schedule_dto)
         assert schedule_dto.last_executed is not None
         assert schedule_dto.status == 'COMPLETED'
         self.group_action_controller.do_group_action.assert_called_with(1)
 
     def test_validate_basic_action(self):
-        # New self.controller is empty
-        assert len(self.controller.load_schedules()) == 0
+        # New self.scheduling_controller is empty
+        assert len(self.scheduling_controller.load_schedules()) == 0
 
         # Doesn't support duration
         duration_error = 'A schedule of type BASIC_ACTION does not have a duration. It is a one-time trigger'
@@ -231,14 +215,14 @@ class SchedulingControllerTest(unittest.TestCase):
                                    start=time.time() + 0.5,
                                    action='BASIC_ACTION',
                                    arguments={'action_type': 1, 'action_number': 2})
-        self.controller._execute_schedule(schedule_dto)
+        self.scheduling_controller._execute_schedule(schedule_dto)
         assert schedule_dto.last_executed is not None
         assert schedule_dto.status == 'COMPLETED'
         self.group_action_controller.do_basic_action.assert_called_with(action_number=2, action_type=1)
 
     def test_validate_local_api(self):
-        # New self.controller is empty
-        self.assertEqual(0, len(self.controller.load_schedules()))
+        # New self.scheduling_controller is empty
+        self.assertEqual(0, len(self.scheduling_controller.load_schedules()))
 
         # Doesn't support duration
         with self.assertRaises(RuntimeError) as ctx:
@@ -275,7 +259,7 @@ class SchedulingControllerTest(unittest.TestCase):
                                    arguments={'name': 'do_basic_action',
                                               'parameters': {'action_type': 3,
                                                              'action_number': 4}})
-        self.controller._execute_schedule(schedule_dto)
+        self.scheduling_controller._execute_schedule(schedule_dto)
         assert schedule_dto.last_executed is not None
         assert schedule_dto.status == 'COMPLETED'
         self.group_action_controller.do_basic_action.assert_called_with(3, 4)
@@ -285,13 +269,13 @@ class SchedulingControllerTest(unittest.TestCase):
                            arguments={'action_type': 1, 'action_number': 2})
         self._add_schedule(name='group_action', start=0, action='GROUP_ACTION',
                            arguments=1)
-        schedules = self.controller.load_schedules()
+        schedules = self.scheduling_controller.load_schedules()
         self.assertEqual(2, len(schedules))
         self.assertEqual(['basic_action', 'group_action'], sorted(s.name for s in schedules))
         for s in schedules:
             if s.name == 'group_action':
-                self.controller.remove_schedules([s])
-        schedules = self.controller.load_schedules()
+                self.scheduling_controller.remove_schedules([s])
+        schedules = self.scheduling_controller.load_schedules()
         self.assertEqual(1, len(schedules))
         self.assertEqual('basic_action', schedules[0].name)
 
@@ -301,7 +285,7 @@ class SchedulingControllerTest(unittest.TestCase):
                            action='GROUP_ACTION',
                            arguments=1,
                            status='ACTIVE')
-        schedule = self.controller.load_schedules()[0]
+        schedule = self.scheduling_controller.load_schedules()[0]
         self.assertEqual(schedule.status, 'ACTIVE')
         self.assertIsNone(schedule.last_executed)
 
@@ -313,10 +297,10 @@ class SchedulingControllerTest(unittest.TestCase):
                            action='GROUP_ACTION',
                            arguments=1,
                            status='ACTIVE')
-        schedule = self.controller.load_schedules()[0]
+        schedule = self.scheduling_controller.load_schedules()[0]
         self.assertEqual(schedule.status, 'COMPLETED')
         self.assertIsNone(schedule.last_executed)
 
     def _add_schedule(self, **kwargs):
         dto = ScheduleDTO(id=None, **kwargs)
-        self.controller.save_schedules([dto])
+        self.scheduling_controller.save_schedules([dto])
diff --git a/testing/unittests/gateway_tests/sensor_controller_test.py b/testing/unittests/gateway_tests/sensor_controller_test.py
index c262b10d..86e7bb32 100644
--- a/testing/unittests/gateway_tests/sensor_controller_test.py
+++ b/testing/unittests/gateway_tests/sensor_controller_test.py
@@ -21,9 +21,10 @@ import mock
 from sqlalchemy import create_engine, select
 from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.pool import StaticPool
+
 from bus.om_bus_client import MessageClient
-from gateway.dto import MasterSensorDTO, SensorDTO, SensorSourceDTO, \
-    SensorStatusDTO
+from gateway.dto import MasterSensorDTO, PluginSensorDTO, SensorDTO, \
+    SensorStateDTO, SourceDTO
 from gateway.events import GatewayEvent
 from gateway.hal.master_controller import MasterController
 from gateway.hal.master_event import MasterEvent
@@ -33,6 +34,7 @@ from gateway.pubsub import PubSub
 from gateway.sensor_controller import SensorController
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
+from plugins.base import PluginController
 
 
 class SensorControllerTest(unittest.TestCase):
@@ -59,6 +61,7 @@ class SensorControllerTest(unittest.TestCase):
         SetUpTestInjections(maintenance_controller=mock.Mock(MaintenanceController),
                             master_controller=self.master_controller,
                             message_client=mock.Mock(MessageClient),
+                            plugin_controller=mock.Mock(PluginController),
                             pubsub=self.pubsub)
         self.controller = SensorController()
 
@@ -245,7 +248,7 @@ class SensorControllerTest(unittest.TestCase):
              mock.patch.object(self.master_controller, 'load_sensors', return_value=[]):
             sensor_dto = self.controller.load_sensor(42)
         assert sensor_dto.id == 42
-        assert sensor_dto.source == SensorSourceDTO('master')
+        assert sensor_dto.source == SourceDTO('master')
         assert sensor_dto.external_id == '0'
         assert sensor_dto.physical_quantity == 'temperature'
         assert sensor_dto.name == 'foo'
@@ -267,7 +270,7 @@ class SensorControllerTest(unittest.TestCase):
         assert len(sensor_dtos) == 1
         sensor_dto = sensor_dtos[0]
         assert sensor_dto.id == 42
-        assert sensor_dto.source == SensorSourceDTO('master')
+        assert sensor_dto.source == SourceDTO('master')
         assert sensor_dto.external_id == '0'
         assert sensor_dto.physical_quantity == 'temperature'
         assert sensor_dto.name == 'foo'
@@ -329,13 +332,17 @@ class SensorControllerTest(unittest.TestCase):
             events.append(gateway_event)
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.CONFIG, handle_event)
 
-        source_dto = SensorSourceDTO('plugin', name='dummy')
+        source_dto = SourceDTO('plugin', source_id=10)
         with mock.patch.object(self.master_controller, 'save_sensors') as save:
-            sensor_dto = self.controller.register_sensor(source_dto, 'foo', 'temperature', 'celcius', {'name': 'initial'})
-            sensor_id = sensor_dto.id
-            assert sensor_id > 500
+            sensor_dto = self.controller._plugin_callback_action(source_dto, 'register',
+                                                                 PluginSensorDTO(external_id='foo',
+                                                                                 physical_quantity='temperature',
+                                                                                 unit='celcius',
+                                                                                 name='initial'))
+            with self.session as db:
+                sensor = db.query(Sensor).filter_by(external_id='foo').one()
+                assert sensor.id > 500
             save.assert_not_called()
-            assert sensor_id is not None
             self.pubsub._publish_all_events(blocking=False)
 
         assert GatewayEvent('CONFIG_CHANGE', {'type': 'sensor'}) in events
@@ -343,7 +350,7 @@ class SensorControllerTest(unittest.TestCase):
 
         with self.session as db:
             plugin = db.query(Plugin).filter_by(name='dummy').one()
-            sensor = db.query(Sensor).filter_by(id=sensor_id).one()
+            sensor = db.query(Sensor).filter_by(external_id='foo').one()
             assert sensor.source == 'plugin'
             assert sensor.plugin == plugin
             assert sensor.external_id == 'foo'
@@ -352,8 +359,12 @@ class SensorControllerTest(unittest.TestCase):
             assert sensor.name == 'initial'
 
         with mock.patch.object(self.master_controller, 'save_sensors') as save:
-            sensor_dto = self.controller.register_sensor(source_dto, 'foo', 'temperature', 'celcius', {'name': 'updated'})
-            assert sensor_dto.id == sensor_id
+            sensor_dto = self.controller._plugin_callback_action(source_dto, 'register',
+                                                                 PluginSensorDTO(external_id='foo',
+                                                                                 physical_quantity='temperature',
+                                                                                 unit='celcius',
+                                                                                 name='initial'))
+            assert sensor_dto.external_id == 'foo'
             assert sensor_dto.physical_quantity == 'temperature'
             assert sensor_dto.unit == 'celcius'
             assert sensor_dto.name == 'initial'
@@ -365,7 +376,7 @@ class SensorControllerTest(unittest.TestCase):
         with self.session as db:
             db.add_all([
                 Sensor(id=512, source='plugin', external_id='foo', physical_quantity='temperature', name='',
-                       plugin=Plugin(name='dummy', version='0.0.1'))
+                       plugin=Plugin(id=10, name='dummy', version='0.0.1'))
             ])
             db.commit()
 
@@ -376,7 +387,7 @@ class SensorControllerTest(unittest.TestCase):
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.CONFIG, handle_event)
 
         sensor_dto = SensorDTO(id=512,
-                               source=SensorSourceDTO('plugin', name='dummy'),
+                               source=SourceDTO('plugin', source_id=10),
                                external_id='foo',
                                physical_quantity='temperature',
                                unit='celcius',
@@ -413,7 +424,7 @@ class SensorControllerTest(unittest.TestCase):
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.CONFIG, handle_event)
 
         sensor_dto = SensorDTO(id=1,
-                               source=SensorSourceDTO('master'),
+                               source=SourceDTO('master'),
                                external_id='31',
                                physical_quantity='temperature',
                                unit='celcius',
@@ -479,7 +490,7 @@ class SensorControllerTest(unittest.TestCase):
              mock.patch.object(self.master_controller, 'get_sensors_brightness', return_value=[]), \
              mock.patch.object(self.master_controller, 'get_sensors_humidity', return_value=[]), \
              mock.patch.object(self.master_controller, 'get_sensors_temperature', return_value=[]):
-            self.controller.set_sensor_status(SensorStatusDTO(sensor_id, value=21))
+            self.controller.set_sensor_status(SensorStateDTO(sensor_id, value=21))
             values = {s.id: s for s in self.controller.get_sensors_status()}
         assert values[sensor_id].value == 21.0
 
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/setpoint_controller_test.py b/testing/unittests/gateway_tests/thermostat/gateway/setpoint_controller_test.py
new file mode 100644
index 00000000..480cd4c9
--- /dev/null
+++ b/testing/unittests/gateway_tests/thermostat/gateway/setpoint_controller_test.py
@@ -0,0 +1,127 @@
+# Copyright (C) 2017 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Tests for the scheduling module.
+"""
+from __future__ import absolute_import
+
+import logging
+import time
+import unittest
+import mock
+from apscheduler.schedulers.background import BackgroundScheduler
+from sqlalchemy import create_engine, select
+from sqlalchemy.orm import scoped_session, sessionmaker
+from sqlalchemy.pool import StaticPool
+
+from gateway.dto import ScheduleDTO
+from gateway.group_action_controller import GroupActionController
+from gateway.hal.master_controller import MasterController
+from gateway.models import Base, Database, DaySchedule, Schedule
+from gateway.pubsub import PubSub
+from gateway.scheduling_controller import SchedulingController
+from gateway.thermostat.gateway.setpoint_controller import SetpointController
+from gateway.system_controller import SystemController
+from gateway.webservice import WebInterface
+from ioc import SetTestMode, SetUpTestInjections
+from logs import Logs
+
+MODELS = [DaySchedule, Schedule]
+
+class SetpointControllerTest(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        super(SetpointControllerTest, cls).setUpClass()
+        SetTestMode()
+        Logs.set_loglevel(logging.DEBUG, namespace='gateway.setpoint_controller')
+        # Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
+
+
+    def setUp(self):
+        engine = create_engine(
+            'sqlite://', connect_args={'check_same_thread': False}, poolclass=StaticPool
+        )
+        Base.metadata.create_all(engine)
+        session_factory = sessionmaker(autocommit=False, autoflush=True, bind=engine)
+
+        self.db = session_factory()
+        session_mock = mock.patch.object(Database, 'get_session', return_value=self.db)
+        session_mock.start()
+        self.addCleanup(session_mock.stop)
+
+        self.group_action_controller = mock.Mock(GroupActionController)
+        self.master_controller = mock.Mock(MasterController)
+
+        SetUpTestInjections(master_controller=self.master_controller,
+                            message_client=None,
+                            module_controller=None,
+                            pubsub=mock.Mock(PubSub))
+        SetUpTestInjections(system_controller=SystemController())
+        SetUpTestInjections(configuration_controller=None,
+                            energy_module_controller=None,
+                            frontpanel_controller=None,
+                            group_action_controller=self.group_action_controller,
+                            input_controller=None,
+                            maintenance_controller=None,
+                            output_controller=None,
+                            pulse_counter_controller=None,
+                            room_controller=None,
+                            sensor_controller=None,
+                            shutter_controller=None,
+                            thermostat_controller=None,
+                            uart_controller=None,
+                            update_controller=None,
+                            event_sender=None,
+                            user_controller=None,
+                            ventilation_controller=None,
+                            hvac_controller=None)
+
+        self.scheduling_controller = SchedulingController()
+        SetUpTestInjections(scheduling_controller=self.scheduling_controller)
+        self.setpoint_controller = SetpointController()
+
+        self.web_interface = WebInterface()
+        self.scheduling_controller.set_webinterface(self.web_interface)
+        self.scheduler = mock.Mock(BackgroundScheduler)
+        self.scheduler.get_job.return_value = None
+        self.scheduling_controller._scheduler = self.scheduler
+        # patch: do not wait to async sync_configuration using a new thread, but directly sync inline for testing
+        mock_refresh = mock.patch.object(self.scheduling_controller, 'refresh_schedules',
+                                         side_effect=self.scheduling_controller._sync_configuration)
+        mock_refresh.start()
+        self.scheduling_controller._scheduler.start()
+
+
+    def test_update_thermostat_setpoints(self):
+        self.setpoint_controller.update_thermostat_setpoints(0, 'heating', [
+            DaySchedule(id=10, index=0, content='{"21600": 21.5}')
+        ])
+        jobs = self.scheduling_controller._scheduler.get_jobs()
+        assert len(self.scheduler.add_job.call_args_list) == 1
+        job_id = self.scheduler.add_job.call_args_list[0][1]['id']
+        assert job_id == 'thermostat.heating.0.mon.06h00m'
+        setpoint_dto = self.scheduler.add_job.call_args_list[0][1]['args'][0]
+        assert setpoint_dto.thermostat == 0
+        assert setpoint_dto.temperature == 21.5
+
+        self.setpoint_controller.update_thermostat_setpoints(0, 'heating', [
+            DaySchedule(id=10, index=0, content='{"28800": 22.0}')
+        ])
+        assert len(self.scheduler.add_job.call_args_list) == 2
+        job_id = self.scheduler.add_job.call_args_list[1][1]['id']
+        assert job_id == 'thermostat.heating.0.mon.08h00m'
+        setpoint_dto = self.scheduler.add_job.call_args_list[1][1]['args'][0]
+        assert setpoint_dto.thermostat == 0
+        assert setpoint_dto.temperature == 22.0
\ No newline at end of file
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/thermostat_controller_test.py b/testing/unittests/gateway_tests/thermostat/gateway/thermostat_controller_test.py
index d153f661..07699858 100644
--- a/testing/unittests/gateway_tests/thermostat/gateway/thermostat_controller_test.py
+++ b/testing/unittests/gateway_tests/thermostat/gateway/thermostat_controller_test.py
@@ -26,26 +26,29 @@ from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.pool import StaticPool
 
 from gateway.dto import OutputStatusDTO, PumpGroupDTO, ScheduleDTO, \
-    SensorStatusDTO, ThermostatDTO, ThermostatGroupDTO, \
+    SensorStateDTO, ThermostatDTO, ThermostatGroupDTO, \
     ThermostatGroupStatusDTO, ThermostatScheduleDTO, ThermostatStatusDTO
 from gateway.events import GatewayEvent
 from gateway.hal.master_event import MasterEvent
 from gateway.models import Base, Database, DaySchedule, Output, \
-    OutputToThermostatGroupAssociation, Preset, Pump, PumpToValveAssociation, \
+    HvacOutputLink, Preset, Pump, PumpToValveAssociation, \
     Room, Sensor, Thermostat, ThermostatGroup, Valve, \
-    ValveToThermostatAssociation
+    IndoorLinkValves
 from gateway.output_controller import OutputController
 from gateway.pubsub import PubSub
 from gateway.scheduling_controller import SchedulingController
+from gateway.valve_pump.valve_pump_controller import ValvePumpController
 from gateway.sensor_controller import SensorController
 from gateway.thermostat.gateway.thermostat_controller_gateway import \
     ThermostatControllerGateway
+from gateway.thermostat.gateway.setpoint_controller import SetpointController
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
 
 MODELS = [Pump, Output, Valve, PumpToValveAssociation, Thermostat,
-          ThermostatGroup, ValveToThermostatAssociation, Room, Sensor, Preset,
-          OutputToThermostatGroupAssociation, DaySchedule]
+          ThermostatGroup, IndoorLinkValves, Room, Sensor, Preset,
+          HvacOutputLink, DaySchedule]
+
 
 
 class ThermostatControllerTest(unittest.TestCase):
@@ -72,15 +75,21 @@ class ThermostatControllerTest(unittest.TestCase):
         self.output_controller = mock.Mock(OutputController)
         self.output_controller.get_output_status.return_value = OutputStatusDTO(id=0, status=False)
         sensor_controller = mock.Mock(SensorController)
-        sensor_controller.get_sensor_status.side_effect = lambda x: SensorStatusDTO(id=x, value=10.0)
+        sensor_controller.get_sensor_status.side_effect = lambda x: SensorStateDTO(id=x, value=10.0)
         self.scheduling_controller = mock.Mock(SchedulingController)
+        valve_pump_controller = ValvePumpController()
+        SetUpTestInjections(scheduling_controller=self.scheduling_controller)
+        self.setpoint_controller = SetpointController()
+        # self.setpoint_controller = mock.Mock(SetpointController)
+
         SetUpTestInjections(pubsub=self.pubsub,
-                            scheduling_controller=self.scheduling_controller,
                             output_controller=self.output_controller,
-                            sensor_controller=sensor_controller)
-        self.controller = ThermostatControllerGateway()
-        self.controller._sync_auto_setpoints = False
-        SetUpTestInjections(thermostat_controller=self.controller)
+                            sensor_controller=sensor_controller,
+                            setpoint_controller=self.setpoint_controller,
+                            valve_pump_controller=valve_pump_controller)
+        self.thermostat_controller = ThermostatControllerGateway()
+        self.thermostat_controller._sync_auto_setpoints = False
+        SetUpTestInjections(thermostat_controller=self.thermostat_controller)
 
         # sensor = Sensor.create(source='master', external_id='1', physical_quantity='temperature', name='')
         # self._thermostat_group = ThermostatGroup.create(number=0,
@@ -115,17 +124,17 @@ class ThermostatControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
             ])
             db.commit()
 
-        self.controller.save_heating_thermostats([
+        self.thermostat_controller.save_heating_thermostats([
             ThermostatDTO(id=0, sensor=None, output0=None)
         ])
-        thermostats = self.controller.load_heating_thermostats()
+        thermostats = self.thermostat_controller.load_heating_thermostats()
         self.assertEqual(len(thermostats), 0)
 
     def test_update_schedules(self):
@@ -153,14 +162,14 @@ class ThermostatControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
             ])
             db.commit()
 
-        self.controller._sync_thread = mock.Mock()
+        self.thermostat_controller._sync_thread = mock.Mock()
         schedule_dto = ThermostatScheduleDTO(temp_day_1=22.0,
                                              start_day_1='06:30',
                                              end_day_1='10:00',
@@ -168,7 +177,7 @@ class ThermostatControllerTest(unittest.TestCase):
                                              start_day_2='16:00',
                                              end_day_2='23:00',
                                              temp_night=16.5)
-        self.controller.save_heating_thermostats([
+        self.thermostat_controller.save_heating_thermostats([
             ThermostatDTO(id=0,
                           auto_mon=schedule_dto,
                           auto_tue=schedule_dto,
@@ -178,15 +187,12 @@ class ThermostatControllerTest(unittest.TestCase):
                           auto_sat=schedule_dto,
                           auto_sun=schedule_dto)
         ])
-        self.controller._sync_thread.request_single_run.assert_called_with()
-        self.controller.refresh_thermostats_from_db()
+        self.thermostat_controller._sync_thread.request_single_run.assert_called_with()
+        self.thermostat_controller.refresh_thermostats_from_db()
 
         with self.session as db:
             thermostat = db.query(Thermostat).filter_by(number=0).one()
             assert len(thermostat.heating_schedules) == 7
-            # FIXME
-            # assert mock.call(0, 'heating', thermostat.heating_schedules) in self.scheduling_controller.update_thermostat_setpoints.call_args_list
-            # assert mock.call(0, 'cooling', []) in self.scheduling_controller.update_thermostat_setpoints.call_args_list
 
     def test_save_pumpgroups(self):
         with self.session as db:
@@ -213,39 +219,39 @@ class ThermostatControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
-                ValveToThermostatAssociation(mode='cooling',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 9)',
-                                                         output=Output(number=9))),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 10)',
-                                                         output=Output(number=10))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
+                IndoorLinkValves(mode='cooling',
+                                 thermostat_link_id=1,
+                                 valve=Valve(name='Valve (output 9)',
+                                             output=Output(number=9))),
+                IndoorLinkValves(mode='heating',
+                                 thermostat_link_id=1,
+                                 valve=Valve(name='Valve (output 10)',
+                                             output=Output(number=10))),
             ])
             db.commit()
 
-        heating_pump_groups = self.controller.load_heating_pump_groups()
+        heating_pump_groups = self.thermostat_controller.load_heating_pump_groups()
         self.assertEqual([], heating_pump_groups)
 
         with self.session as db:
             db.add(Output(number=1))
             db.commit()
-        self.controller.save_heating_pump_groups([PumpGroupDTO(id=0,
+        self.thermostat_controller.save_heating_pump_groups([PumpGroupDTO(id=0,
                                                                pump_output_id=1,
                                                                valve_output_ids=[8])])
-        self.controller.save_cooling_pump_groups([PumpGroupDTO(id=0,
+        self.thermostat_controller.save_cooling_pump_groups([PumpGroupDTO(id=0,
                                                                pump_output_id=1,
                                                                valve_output_ids=[9])])
 
-        pump_groups = self.controller.load_heating_pump_groups()
+        pump_groups = self.thermostat_controller.load_heating_pump_groups()
         self.assertEqual([PumpGroupDTO(id=0,
                                        pump_output_id=1,
                                        valve_output_ids=[8])], pump_groups)
-        pump_groups = self.controller.load_cooling_pump_groups()
+        pump_groups = self.thermostat_controller.load_cooling_pump_groups()
         self.assertEqual([PumpGroupDTO(id=0,
                                        pump_output_id=1,
                                        valve_output_ids=[9])], pump_groups)
@@ -253,26 +259,26 @@ class ThermostatControllerTest(unittest.TestCase):
         with self.session as db:
             db.add(Output(number=2))
             db.commit()
-        self.controller.save_heating_pump_groups([
+        self.thermostat_controller.save_heating_pump_groups([
             PumpGroupDTO(id=0,
                          pump_output_id=2,
                          valve_output_ids=[8, 10])
         ])
-        pump_groups = self.controller.load_heating_pump_groups()
+        pump_groups = self.thermostat_controller.load_heating_pump_groups()
         self.assertEqual([PumpGroupDTO(id=0,
                                        pump_output_id=2,
                                        valve_output_ids=[8, 10])], pump_groups)
-        pump_groups = self.controller.load_cooling_pump_groups()
+        pump_groups = self.thermostat_controller.load_cooling_pump_groups()
         self.assertEqual([PumpGroupDTO(id=0,
                                        pump_output_id=2,
                                        valve_output_ids=[9])], pump_groups)
 
-        self.controller.save_heating_pump_groups([
+        self.thermostat_controller.save_heating_pump_groups([
             PumpGroupDTO(id=0,
                          pump_output_id=None,
                          valve_output_ids=[])
         ])
-        pump_groups = self.controller.load_heating_pump_groups()
+        pump_groups = self.thermostat_controller.load_heating_pump_groups()
         self.assertEqual([], pump_groups)
 
     def test_save_thermostat_groups(self):
@@ -300,10 +306,10 @@ class ThermostatControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
                 Sensor(source='master', external_id='11', physical_quantity='temperature', name=''),
                 Output(number=0),
                 Output(number=1),
@@ -323,7 +329,7 @@ class ThermostatControllerTest(unittest.TestCase):
             self.assertEqual(10.0, group.threshold_temperature)
             self.assertEqual(0, len(group.outputs))
 
-        self.controller.save_thermostat_groups([
+        self.thermostat_controller.save_thermostat_groups([
             ThermostatGroupDTO(id=0,
                                outside_sensor_id=1,
                                pump_delay=30,
@@ -337,15 +343,15 @@ class ThermostatControllerTest(unittest.TestCase):
         with self.session as db:
             group = db.query(ThermostatGroup).filter_by(number=0).one()
             self.assertEqual(15.0, group.threshold_temperature)
-            associations = [{'index': x.index, 'value': x.value, 'mode': x.mode, 'output': x.output.number}
+            associations = [{'value': x.value, 'mode': x.mode, 'output': x.output.number}
                             for x in group.heating_output_associations]
             self.assertEqual(2, len(associations), associations)
-            self.assertIn({'index': 0, 'value': 0, 'mode': 'heating', 'output': 0}, associations)
-            self.assertIn({'index': 1, 'value': 100, 'mode': 'heating', 'output': 1}, associations)
-            associations = [{'index': x.index, 'value': x.value, 'mode': x.mode, 'output': x.output.number}
+            self.assertIn({'value': 0, 'mode': 'heating', 'output': 0}, associations)
+            self.assertIn({'value': 100, 'mode': 'heating', 'output': 1}, associations)
+            associations = [{'value': x.value, 'mode': x.mode, 'output': x.output.number}
                             for x in group.cooling_output_associations]
             self.assertEqual(1, len(associations), associations)
-            self.assertIn({'index': 0, 'value': 100, 'mode': 'cooling', 'output': 2}, associations)
+            self.assertIn({'value': 100, 'mode': 'cooling', 'output': 2}, associations)
 
         new_thermostat_group_dto = ThermostatGroupDTO(id=0,
                                                       name='Default',
@@ -356,7 +362,7 @@ class ThermostatControllerTest(unittest.TestCase):
                                                       switch_to_heating_1=None,
                                                       switch_to_cooling_0=(2, 0),
                                                       switch_to_cooling_1=None)
-        self.controller.save_thermostat_groups([new_thermostat_group_dto])
+        self.thermostat_controller.save_thermostat_groups([new_thermostat_group_dto])
 
         self.pubsub._publish_all_events(blocking=False)
         self.assertIn(GatewayEvent('THERMOSTAT_GROUP_CHANGE', {'id': 0, 'status': {'mode': 'HEATING'}}), events)
@@ -364,16 +370,16 @@ class ThermostatControllerTest(unittest.TestCase):
             group = db.query(ThermostatGroup).filter_by(number=0).one()
             self.assertIsNone(group.sensor)
             self.assertIsNone(group.threshold_temperature)
-            associations = [{'index': x.index, 'value': x.value, 'mode': x.mode, 'output': x.output.number}
+            associations = [{'value': x.value, 'mode': x.mode, 'output': x.output.number}
                             for x in group.heating_output_associations]
             self.assertEqual(1, len(associations), associations)
-            self.assertIn({'index': 0, 'value': 50, 'mode': 'heating', 'output': 0}, associations)
-            associations = [{'index': x.index, 'value': x.value, 'mode': x.mode, 'output': x.output.number}
+            self.assertIn({'value': 50, 'mode': 'heating', 'output': 0}, associations)
+            associations = [{'value': x.value, 'mode': x.mode, 'output': x.output.number}
                             for x in group.cooling_output_associations]
             self.assertEqual(1, len(associations), associations)
-            self.assertIn({'index': 0, 'value': 0, 'mode': 'cooling', 'output': 2}, associations)
+            self.assertIn({'value': 0, 'mode': 'cooling', 'output': 2}, associations)
 
-        self.assertEqual(new_thermostat_group_dto, self.controller.load_thermostat_group(0))
+        self.assertEqual(new_thermostat_group_dto, self.thermostat_controller.load_thermostat_group(0))
 
     def test_thermostat_control(self):
         with self.session as db:
@@ -401,20 +407,18 @@ class ThermostatControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
-                OutputToThermostatGroupAssociation(thermostat_group_id=1,
-                                                   mode='heating',
-                                                   value=100,
-                                                   index=0,
-                                                   output=Output(number=0)),
-                OutputToThermostatGroupAssociation(thermostat_group_id=1,
-                                                   mode='cooling',
-                                                   value=0,
-                                                   index=0,
-                                                   output=Output(number=1)),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
+                HvacOutputLink(hvac_id=1,
+                               mode='heating',
+                               value=100,
+                               output=Output(number=0)),
+                HvacOutputLink(hvac_id=1,
+                               mode='cooling',
+                               value=0,
+                               output=Output(number=1)),
             ])
             db.commit()
 
@@ -426,85 +430,92 @@ class ThermostatControllerTest(unittest.TestCase):
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, handle_event)
 
         now = datetime.now()
-        self.scheduling_controller.last_thermostat_setpoint.return_value = (datetime(now.year, now.month, now.day, 0), 21.5)
-        self.controller.refresh_config_from_db()
-
-        # Apply last auto scheduled setpoints
-        self.controller._sync_auto_setpoints = True
-        self.controller.refresh_config_from_db()
-        expected = ThermostatGroupStatusDTO(id=0,
-                                            setpoint=0,
-                                            cooling=False,
-                                            automatic=True,
-                                            mode='heating',
-                                            statusses=[ThermostatStatusDTO(id=0,
-                                                                           automatic=True,
-                                                                           setpoint=0,
-                                                                           state='on',
-                                                                           preset='auto',
-                                                                           actual_temperature=10.0,
-                                                                           setpoint_temperature=21.5,
-                                                                           outside_temperature=10.0,
-                                                                           output_0_level=0,  # Valve drivers are not active
-                                                                           output_1_level=0,
-                                                                           steering_power=100,  # PID active
-                                                                           mode='heating')])
-        assert expected.statusses[0] == self.controller.get_thermostat_group_status()[0].statusses[0]
-        assert expected == self.controller.get_thermostat_group_status()[0]
-
-        self.controller.set_current_setpoint(0, heating_temperature=15.0)
-        expected.statusses[0].setpoint_temperature = 15.0
-        assert expected == self.controller.get_thermostat_group_status()[0]
-
-        self.scheduling_controller.last_thermostat_setpoint.return_value = (datetime(now.year, now.month, now.day, 0), 19.0)
-        # Restore auto scheduled setpoints
-        self.controller.set_thermostat(0, preset='auto')
-        expected.statusses[0].setpoint_temperature = 19.0
-        assert expected == self.controller.get_thermostat_group_status()[0]
-
-        self.controller.set_per_thermostat_mode(0,
-                                                automatic=False,
-                                                setpoint=3)
-        self.pubsub._publish_all_events(blocking=False)
-        event_data = {'id': 0,
-                      'status': {'state': 'ON',
-                                 'preset': 'AWAY',
-                                 'mode': 'HEATING',
-                                 'current_setpoint': 16.0,
-                                 'actual_temperature': 10.0,
-                                 'output_0': 100,
-                                 'output_1': None,
-                                 'steering_power': 100}}
-        self.assertIn(GatewayEvent('THERMOSTAT_CHANGE', event_data), events)
-        expected.statusses[0].setpoint_temperature = 16.0
-        expected.statusses[0].setpoint = 3
-        expected.statusses[0].automatic = False
-        expected.statusses[0].preset = 'away'
-        expected.automatic = False
-        expected.setpoint = 3
-        self.assertEqual([expected], self.controller.get_thermostat_group_status())
-
-        self.controller.set_per_thermostat_mode(0,
+        with mock.patch.object(self.setpoint_controller, 'last_thermostat_setpoint', return_value=(datetime(now.year, now.month, now.day, 0), 21.5)):
+            self.thermostat_controller.refresh_config_from_db()
+
+            # Apply last auto scheduled setpoints
+            self.thermostat_controller._sync_auto_setpoints = True
+            self.thermostat_controller.refresh_config_from_db()
+            expected = ThermostatGroupStatusDTO(id=0,
+                                                setpoint=0,
+                                                cooling=False,
                                                 automatic=True,
-                                                setpoint=3)  # This is conflicting with automatic = True above
-        self.pubsub._publish_all_events(blocking=False)
-        event_data = {'id': 0,
-                      'status': {'state': 'ON',
-                                 'preset': 'AUTO',
-                                 'mode': 'HEATING',
-                                 'current_setpoint': 15.0,
-                                 'actual_temperature': 10.0,
-                                 'output_0': 100,
-                                 'output_1': None,
-                                 'steering_power': 100}}
-        self.assertIn(GatewayEvent('THERMOSTAT_CHANGE', event_data), events)
-        expected.statusses[0].setpoint_temperature = 19.0
-        expected.statusses[0].setpoint = 0
-        expected.statusses[0].automatic = True
-        expected.statusses[0].preset = 'auto'
-        expected.automatic = True
-        expected.setpoint = 0
-        self.assertEqual([expected], self.controller.get_thermostat_group_status())
+                                                mode='heating',
+                                                statusses=[ThermostatStatusDTO(id=0,
+                                                                               automatic=True,
+                                                                               setpoint=0,
+                                                                               state='on',
+                                                                               preset='auto',
+                                                                               actual_temperature=10.0,
+                                                                               setpoint_temperature=21.5,
+                                                                               outside_temperature=10.0,
+                                                                               output_0_level=0,  # Valve drivers are not active
+                                                                               output_1_level=0,
+                                                                               steering_power=100,  # PID active
+                                                                               mode='heating')])
+
+            response = self.thermostat_controller.get_thermostat_group_status()[0].statusses[0]
+            print('------------------------------')
+            print(expected)
+            print(response)
+
+            
+            assert expected.statusses[0] == self.thermostat_controller.get_thermostat_group_status()[0].statusses[0]
+            assert expected == self.thermostat_controller.get_thermostat_group_status()[0]
+
+            self.thermostat_controller.set_current_setpoint(0, heating_temperature=15.0)
+            expected.statusses[0].setpoint_temperature = 15.0
+            assert expected == self.thermostat_controller.get_thermostat_group_status()[0]
+
+        with mock.patch.object(self.setpoint_controller, 'last_thermostat_setpoint', return_value=(datetime(now.year, now.month, now.day, 0), 19.0)):
+            # Restore auto scheduled setpoints
+            self.thermostat_controller.set_thermostat(0, preset='auto')
+            expected.statusses[0].setpoint_temperature = 19.0
+            assert expected == self.thermostat_controller.get_thermostat_group_status()[0]
+
+            self.thermostat_controller.set_per_thermostat_mode(0,
+                                                    automatic=False,
+                                                    setpoint=3)
+            self.pubsub._publish_all_events(blocking=False)
+            event_data = {'id': 0,
+                          'status': {'state': 'ON',
+                                     'preset': 'AWAY',
+                                     'mode': 'HEATING',
+                                     'current_setpoint': 16.0,
+                                     'actual_temperature': 10.0,
+                                     'output_0': 100,
+                                     'output_1': None,
+                                     'steering_power': 100}}
+            self.assertIn(GatewayEvent('THERMOSTAT_CHANGE', event_data), events)
+            expected.statusses[0].setpoint_temperature = 16.0
+            expected.statusses[0].setpoint = 3
+            expected.statusses[0].automatic = False
+            expected.statusses[0].preset = 'away'
+            expected.automatic = False
+            expected.setpoint = 3
+            self.assertEqual([expected], self.thermostat_controller.get_thermostat_group_status())
+
+            self.thermostat_controller.set_per_thermostat_mode(0,
+                                                    automatic=True,
+                                                    setpoint=3)  # This is conflicting with automatic = True above
+            self.pubsub._publish_all_events(blocking=False)
+            event_data = {'id': 0,
+                          'status': {'state': 'ON',
+                                     'preset': 'AUTO',
+                                     'mode': 'HEATING',
+                                     'current_setpoint': 15.0,
+                                     'actual_temperature': 10.0,
+                                     'output_0': 100,
+                                     'output_1': None,
+                                     'steering_power': 100}}
+            self.assertIn(GatewayEvent('THERMOSTAT_CHANGE', event_data), events)
+            expected.statusses[0].setpoint_temperature = 19.0
+            expected.statusses[0].setpoint = 0
+            expected.statusses[0].automatic = True
+            expected.statusses[0].preset = 'auto'
+            expected.automatic = True
+            expected.setpoint = 0
+            self.assertEqual([expected], self.thermostat_controller.get_thermostat_group_status())
 
     def test_copy_schedule(self):
         with self.session as db:
@@ -523,15 +534,15 @@ class ThermostatControllerTest(unittest.TestCase):
                            valve_config='equal',
                            sensor=Sensor(source='master', external_id='10', physical_quantity='temperature', name=''),
                            group=ThermostatGroup(number=0, name='thermostat group', threshold_temperature=10.0, mode='heating')),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
             ])
             db.commit()
 
-        thermostat_dto = self.controller.load_heating_thermostat(thermostat_id=0)
-        self.controller.save_heating_thermostats([thermostat_dto])  # Make sure all defaults are populated
+        thermostat_dto = self.thermostat_controller.load_heating_thermostat(thermostat_id=0)
+        self.thermostat_controller.save_heating_thermostats([thermostat_dto])  # Make sure all defaults are populated
 
         with self.session as db:
             thermostat = db.query(Thermostat).filter_by(number=0).one()
@@ -550,7 +561,7 @@ class ThermostatControllerTest(unittest.TestCase):
         source_dto.setp3 = 8.0
         source_dto.setp4 = 9.0
         source_dto.setp5 = 10.0
-        self.controller.copy_heating_schedule(source_dto, thermostat_dto)
+        self.thermostat_controller.copy_heating_schedule(source_dto, thermostat_dto)
 
         with self.session as db:
             thermostat = db.get(Thermostat, 1)
@@ -579,49 +590,55 @@ class ThermostatControllerTest(unittest.TestCase):
                            valve_config='equal',
                            sensor=Sensor(source='master', external_id='10', physical_quantity='temperature', name=''),
                            group=ThermostatGroup(number=0, name='thermostat group', threshold_temperature=10.0, mode='heating')),
-                ValveToThermostatAssociation(mode='heating',
-                                             thermostat_id=1,
-                                             valve=Valve(name='Valve (output 8)',
-                                                         output=Output(number=8))),
+                IndoorLinkValves(mode='heating',
+                                thermostat_link_id=1,
+                                valve=Valve(name='Valve (output 8)',
+                                            output=Output(number=8))),
             ])
             db.commit()
 
-        thermostat_dto = self.controller.load_heating_thermostat(thermostat_id=0)
-        self.controller.save_heating_thermostats([thermostat_dto])  # Make sure all defaults are populated
+        thermostat_dto = self.thermostat_controller.load_heating_thermostat(thermostat_id=0)
+        self.thermostat_controller.save_heating_thermostats([thermostat_dto])  # Make sure all defaults are populated
 
         now = datetime.now()
-        self.scheduling_controller.last_thermostat_setpoint.return_value = (datetime(now.year, now.month, now.day, 0), 21.5)
+        with mock.patch.object(self.setpoint_controller, 'last_thermostat_setpoint', return_value=(datetime(now.year, now.month, now.day, 0), 21.5)):
+
+            self.thermostat_controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
+                                                             data={'type': MasterEvent.APITypes.SET_THERMOSTAT_MODE,
+                                                                   'data': {'state': 'on',
+                                                                            'mode': 'cooling'}}))
+            with self.session as db:
+                thermostat = db.query(Thermostat).filter_by(number=0).one()
+                self.assertEqual('on', thermostat.state)
+                self.assertEqual('cooling', thermostat.group.mode)
 
-        self.controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
-                                                         data={'type': MasterEvent.APITypes.SET_THERMOSTAT_MODE,
-                                                               'data': {'state': 'on',
-                                                                        'mode': 'cooling'}}))
-        with self.session as db:
-            thermostat = db.query(Thermostat).filter_by(number=0).one()
-            self.assertEqual('on', thermostat.state)
-            self.assertEqual('cooling', thermostat.group.mode)
 
-        self.controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
-                                                         data={'type': MasterEvent.APITypes.SET_THERMOSTAT_MODE,
-                                                               'data': {'state': 'off',
-                                                                        'mode': 'heating'}}))
-        with self.session as db:
-            thermostat = db.query(Thermostat).filter_by(number=0).one()
-            self.assertEqual('off', thermostat.state)
-            self.assertEqual('heating', thermostat.group.mode)
 
-            self.controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
+            self.thermostat_controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
+                                                             data={'type': MasterEvent.APITypes.SET_THERMOSTAT_MODE,
+                                                                   'data': {'state': 'off',
+                                                                            'mode': 'heating'}}))
+            with self.session as db:
+                thermostat = db.query(Thermostat).filter_by(number=0).one()
+                self.assertEqual('off', thermostat.state)
+                self.assertEqual('heating', thermostat.group.mode)
+
+
+
+            self.thermostat_controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
                                                              data={'type': MasterEvent.APITypes.SET_THERMOSTAT_PRESET,
                                                                    'data': {'preset': 'away'}}))
 
-        with self.session as db:
-            thermostat = db.query(Thermostat).filter_by(number=0).one()
-            self.assertEqual('away', thermostat.active_preset.type)
+            with self.session as db:
+                thermostat = db.query(Thermostat).filter_by(number=0).one()
+                self.assertEqual('away', thermostat.active_preset.type)
 
-            self.controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
+
+
+            self.thermostat_controller._handle_master_event(MasterEvent(event_type=MasterEvent.Types.EXECUTE_GATEWAY_API,
                                                              data={'type': MasterEvent.APITypes.SET_THERMOSTAT_PRESET,
                                                                    'data': {'preset': 'party'}}))
 
-        with self.session as db:
-            thermostat = db.query(Thermostat).filter_by(number=0).one()
-            self.assertEqual('party', thermostat.active_preset.type)
+            with self.session as db:
+                thermostat = db.query(Thermostat).filter_by(number=0).one()
+                self.assertEqual('party', thermostat.active_preset.type)
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/thermostat_pid_test.py b/testing/unittests/gateway_tests/thermostat/gateway/thermostat_pid_test.py
index 877cdf3f..714725b3 100644
--- a/testing/unittests/gateway_tests/thermostat/gateway/thermostat_pid_test.py
+++ b/testing/unittests/gateway_tests/thermostat/gateway/thermostat_pid_test.py
@@ -19,18 +19,17 @@ import unittest
 
 import mock
 from peewee import SqliteDatabase
-
-import fakesleep
-from gateway.dto import SensorStatusDTO
-from gateway.enums import ThermostatState
 from sqlalchemy import create_engine
 from sqlalchemy.orm import scoped_session, sessionmaker
 from sqlalchemy.pool import StaticPool
-from gateway.models import Base, Database, DaySchedule, Output, Preset, Sensor, Thermostat, \
-    ThermostatGroup, Valve, ValveToThermostatAssociation
+
+import fakesleep
+from gateway.dto import SensorStateDTO
+from gateway.enums import ThermostatState
+from gateway.models import Base, Database, DaySchedule, Output, Preset, \
+    Sensor, Thermostat, ThermostatGroup, Valve, IndoorLinkValves
 from gateway.sensor_controller import SensorController
-from gateway.thermostat.gateway.pump_valve_controller import \
-    PumpValveController
+from gateway.valve_pump.valve_pump_controller import ValvePumpController
 from gateway.thermostat.gateway.thermostat_pid import PID, ThermostatPid
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
@@ -60,9 +59,10 @@ class PumpValveControllerTest(unittest.TestCase):
         self.addCleanup(session_mock.stop)
 
         sensor_controller = mock.Mock(SensorController)
-        sensor_controller.get_sensor_status.side_effect = lambda x: SensorStatusDTO(id=x, value=10.0)
-        self._pump_valve_controller = mock.Mock(PumpValveController)
-        SetUpTestInjections(sensor_controller=sensor_controller)
+        sensor_controller.get_sensor_status.side_effect = lambda x: SensorStateDTO(id=x, value=10.0)
+        self.valve_pump_controller = mock.Mock(ValvePumpController)
+        SetUpTestInjections(sensor_controller=sensor_controller,
+                            valve_pump_controller=self.valve_pump_controller)
 
     def _get_thermostat_pid(self):
         with self.session as db:
@@ -88,20 +88,18 @@ class PumpValveControllerTest(unittest.TestCase):
                                cooling_setpoint=25.0)
                     ]
                 ),
-                ValveToThermostatAssociation(thermostat_id=1,
-                                             priority=0,
-                                             mode=ThermostatGroup.Modes.HEATING,
-                                             valve=Valve(name='valve 1',
-                                                         output=Output(number=1))),
-                ValveToThermostatAssociation(thermostat_id=1,
-                                             priority=0,
-                                             mode=ThermostatGroup.Modes.COOLING,
-                                             valve=Valve(name='valve 2',
-                                                         output=Output(number=2)))
+                IndoorLinkValves(thermostat_link_id=1,
+                                 mode=ThermostatGroup.Modes.HEATING,
+                                 valve=Valve(name='valve 1',
+                                             output=Output(number=1))),
+                IndoorLinkValves(thermostat_link_id=1,
+                                 mode=ThermostatGroup.Modes.COOLING,
+                                 valve=Valve(name='valve 2',
+                                             output=Output(number=2)))
             ])
             db.commit()
             thermostat = db.query(Thermostat).filter_by(number=0).one()
-            pid = ThermostatPid(thermostat, pump_valve_controller=self._pump_valve_controller)
+            pid = ThermostatPid(thermostat)
             pid.update_thermostat()
             return pid
 
@@ -172,36 +170,32 @@ class PumpValveControllerTest(unittest.TestCase):
             thermostat.state = ThermostatState.OFF
             db.commit()
         thermostat_pid.update_thermostat()
-        self._pump_valve_controller.set_valves.call_count = 0
-        self._pump_valve_controller.set_valves.mock_calls = []
+        self.valve_pump_controller._set_valves.call_count = 0
         self.assertFalse(thermostat_pid.tick())
-        self._pump_valve_controller.steer.assert_called_once()
-        self.assertEqual(sorted([mock.call(0, [1], mode='equal'),
-                                 mock.call(0, [2], mode='equal')]),
-                         sorted(self._pump_valve_controller.set_valves.mock_calls))
-        self.assertEqual(2, self._pump_valve_controller.set_valves.call_count)
+        self.valve_pump_controller.steer.assert_called()
+        self.assertEqual(2, self.valve_pump_controller.steer.call_count)
 
         with self.session as db:
             thermostat = db.query(Thermostat).filter_by(number=0).one()
             thermostat.state = ThermostatState.ON
             db.commit()
         thermostat_pid.update_thermostat()
+        # values below must be in random order, if sorted the same power is expected twice, no driver steering will be executed (expected behaviour)
         for mode, output_power, heating_power, cooling_power in [(ThermostatGroup.Modes.HEATING, 100, 100, 0),
+                                                                 (ThermostatGroup.Modes.HEATING, -50, 0, 0),
                                                                  (ThermostatGroup.Modes.HEATING, 50, 50, 0),
                                                                  (ThermostatGroup.Modes.HEATING, 0, 0, 0),
-                                                                 (ThermostatGroup.Modes.HEATING, -50, 0, 0),
                                                                  (ThermostatGroup.Modes.COOLING, -100, 0, 100),
+                                                                 (ThermostatGroup.Modes.COOLING, 50, 0, 0),
                                                                  (ThermostatGroup.Modes.COOLING, -50, 0, 50),
-                                                                 (ThermostatGroup.Modes.COOLING, 0, 0, 0),
-                                                                 (ThermostatGroup.Modes.COOLING, 50, 0, 0)]:
+                                                                 (ThermostatGroup.Modes.COOLING, 0, 0, 0)]:
             thermostat_pid._mode = mode
             thermostat_pid._pid.return_value = output_power
-            self._pump_valve_controller.steer.call_count = 0
-            self._pump_valve_controller.set_valves.call_count = 0
-            self._pump_valve_controller.set_valves.mock_calls = []
+            self.valve_pump_controller.steer.call_count = 0
+            self.valve_pump_controller.steer.mock_calls = []
             self.assertTrue(thermostat_pid.tick())
-            self._pump_valve_controller.steer.assert_called_once()
-            self.assertEqual(sorted([mock.call(heating_power, [1], mode='equal'),
-                                     mock.call(cooling_power, [2], mode='equal')]),
-                             sorted(self._pump_valve_controller.set_valves.mock_calls))
-            self.assertEqual(2, self._pump_valve_controller.set_valves.call_count)
+            self.valve_pump_controller.steer.assert_called()
+            self.assertEqual([mock.call(percentage=heating_power, valve_ids=[1]),
+                                     mock.call(percentage=cooling_power, valve_ids=[2])],
+                             self.valve_pump_controller.steer.mock_calls)
+            self.assertEqual(2, self.valve_pump_controller.steer.call_count)
diff --git a/testing/unittests/gateway_tests/valve_pump/__init__.py b/testing/unittests/gateway_tests/valve_pump/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/pump_driver_test.py b/testing/unittests/gateway_tests/valve_pump/pump_driver_test.py
similarity index 98%
rename from testing/unittests/gateway_tests/thermostat/gateway/pump_driver_test.py
rename to testing/unittests/gateway_tests/valve_pump/pump_driver_test.py
index 47f7da19..5e864e24 100644
--- a/testing/unittests/gateway_tests/thermostat/gateway/pump_driver_test.py
+++ b/testing/unittests/gateway_tests/valve_pump/pump_driver_test.py
@@ -23,7 +23,7 @@ from sqlalchemy.pool import StaticPool
 
 from gateway.models import Base, Database, Output, Pump
 from gateway.output_controller import OutputController
-from gateway.thermostat.gateway.pump_driver import PumpDriver
+from gateway.valve_pump.pump_driver import PumpDriver
 from ioc import SetTestMode, SetUpTestInjections
 
 
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/valve_driver_test.py b/testing/unittests/gateway_tests/valve_pump/valve_driver_test.py
similarity index 91%
rename from testing/unittests/gateway_tests/thermostat/gateway/valve_driver_test.py
rename to testing/unittests/gateway_tests/valve_pump/valve_driver_test.py
index e9cecbf4..422fb368 100644
--- a/testing/unittests/gateway_tests/thermostat/gateway/valve_driver_test.py
+++ b/testing/unittests/gateway_tests/valve_pump/valve_driver_test.py
@@ -26,7 +26,7 @@ import fakesleep
 from gateway.models import Base, Database, Output, Pump, \
     PumpToValveAssociation, Valve
 from gateway.output_controller import OutputController
-from gateway.thermostat.gateway.valve_driver import ValveDriver
+from gateway.valve_pump.valve_driver import ValveDriver
 from ioc import SetTestMode, SetUpTestInjections
 
 
@@ -69,7 +69,8 @@ class ValveDriverTest(unittest.TestCase):
 
         self.assertEqual(0, driver.percentage)
         self.assertEqual(0, driver._desired_percentage)
-        self.assertFalse(driver.is_open)
+        self.assertEqual(0, driver._current_percentage)
+        self.assertFalse(driver.is_open())
         self.assertFalse(driver.in_transition)
 
         driver.set(50)
@@ -83,13 +84,13 @@ class ValveDriverTest(unittest.TestCase):
         driver._output_controller.set_output_status.assert_called_once()
         self.assertFalse(driver.will_open)
         self.assertEqual(100, driver.percentage)
-        self.assertFalse(driver.is_open)
+        self.assertFalse(driver.is_open())
         self.assertTrue(driver.in_transition)
 
         time.sleep(20)
-        self.assertFalse(driver.is_open)
+        self.assertFalse(driver.is_open())
         self.assertTrue(driver.in_transition)
 
         time.sleep(15)
-        self.assertTrue(driver.is_open)
+        self.assertTrue(driver.is_open())
         self.assertFalse(driver.in_transition)
diff --git a/testing/unittests/gateway_tests/thermostat/gateway/pump_valve_controller_test.py b/testing/unittests/gateway_tests/valve_pump/valve_pump_controller_test.py
similarity index 91%
rename from testing/unittests/gateway_tests/thermostat/gateway/pump_valve_controller_test.py
rename to testing/unittests/gateway_tests/valve_pump/valve_pump_controller_test.py
index 19b68b67..2a8bf95c 100644
--- a/testing/unittests/gateway_tests/thermostat/gateway/pump_valve_controller_test.py
+++ b/testing/unittests/gateway_tests/valve_pump/valve_pump_controller_test.py
@@ -27,8 +27,7 @@ import fakesleep
 from gateway.models import Base, Database, Output, Pump, \
     PumpToValveAssociation, Valve
 from gateway.output_controller import OutputController
-from gateway.thermostat.gateway.pump_valve_controller import \
-    PumpValveController
+from gateway.valve_pump.valve_pump_controller import ValvePumpController
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
 
@@ -68,8 +67,10 @@ class PumpValveControllerTest(unittest.TestCase):
             db.commit()
 
         SetUpTestInjections(output_controller=mock.Mock(OutputController))
-        controller = PumpValveController()
-        controller.refresh_from_db()
+        controller = ValvePumpController()
+        controller.update_from_db()
+
+        self.assertEqual(3, len(controller._valve_drivers))
 
         self.assertIn(1, controller._valve_drivers)
         valve_driver_1 = controller.get_valve_driver(1)
@@ -85,7 +86,7 @@ class PumpValveControllerTest(unittest.TestCase):
                                           (75, 'cascade', [100, 50]),
                                           (50, 'cascade', [100, 0]),
                                           (0, 'cascade', [0, 0])]:
-            controller.set_valves(percentage, [1, 2], mode)
+            controller._set_valves(percentage, [1, 2], mode)
             self.assertEqual(results[0], valve_driver_1._desired_percentage)
             self.assertEqual(results[1], valve_driver_2._desired_percentage)
             self.assertEqual(0, valve_driver_3._desired_percentage)
@@ -108,8 +109,8 @@ class PumpValveControllerTest(unittest.TestCase):
             db.commit()
 
         SetUpTestInjections(output_controller=mock.Mock(OutputController))
-        controller = PumpValveController()
-        controller.refresh_from_db()
+        controller = ValvePumpController()
+        controller.update_from_db()
 
         valve_driver_1 = controller.get_valve_driver(1)
         valve_driver_2 = controller.get_valve_driver(2)
@@ -126,8 +127,7 @@ class PumpValveControllerTest(unittest.TestCase):
 
         # Set the second valve to 50%
         # The pump should only be turned on after 15s
-        valve_driver_2.set(50)
-        controller.steer()
+        controller.steer(50, [2])
         self.assertFalse(pump_driver_1.state)
         self.assertEqual(0, valve_driver_1.percentage)
         self.assertEqual(50, valve_driver_2.percentage)
@@ -136,7 +136,7 @@ class PumpValveControllerTest(unittest.TestCase):
 
         # Pump still off after 10s
         time.sleep(10)
-        controller.steer()
+        controller.update_system()
         self.assertFalse(pump_driver_1.state)
         self.assertEqual(0, valve_driver_1.percentage)
         self.assertEqual(50, valve_driver_2.percentage)
@@ -145,7 +145,7 @@ class PumpValveControllerTest(unittest.TestCase):
 
         # Pump is on after 10s
         time.sleep(10)
-        controller.steer()
+        controller.update_system()
         self.assertTrue(pump_driver_1.state)
         self.assertEqual(0, valve_driver_1.percentage)
         self.assertEqual(50, valve_driver_2.percentage)
@@ -153,9 +153,7 @@ class PumpValveControllerTest(unittest.TestCase):
         self.assertEqual(0, valve_driver_3.percentage)
 
         # Other valves are also opened
-        valve_driver_1.set(100)
-        valve_driver_3.set(100)
-        controller.steer()
+        controller.steer(100, [1, 3])
         self.assertTrue(pump_driver_1.state)
         self.assertEqual(100, valve_driver_1.percentage)
         self.assertEqual(50, valve_driver_2.percentage)
@@ -164,7 +162,7 @@ class PumpValveControllerTest(unittest.TestCase):
 
         # After a time, both valves are fully open
         time.sleep(40)
-        controller.steer()
+        controller.update_system()
         self.assertTrue(pump_driver_1.state)
         self.assertEqual(100, valve_driver_1.percentage)
         self.assertEqual(50, valve_driver_2.percentage)
@@ -173,10 +171,7 @@ class PumpValveControllerTest(unittest.TestCase):
 
         # Two valves are closed again
         # When valves are closed, the pumps are stopped immediately
-        valve_driver_2.set(0)
-        valve_driver_3.set(0)
-        time.sleep(10)
-        controller.steer()
+        controller.steer(0, [2,3])
         self.assertTrue(pump_driver_1.state)
         self.assertEqual(100, valve_driver_1.percentage)
         self.assertEqual(0, valve_driver_2.percentage)
diff --git a/testing/unittests/gateway_tests/ventilation_controller_test.py b/testing/unittests/gateway_tests/ventilation_controller_test.py
index 304c9d78..153c8c7d 100644
--- a/testing/unittests/gateway_tests/ventilation_controller_test.py
+++ b/testing/unittests/gateway_tests/ventilation_controller_test.py
@@ -14,30 +14,54 @@
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 from __future__ import absolute_import
 
-import logging
 import time
 import unittest
 
 import mock
 from sqlalchemy import create_engine
-from sqlalchemy.orm import scoped_session, sessionmaker
+from sqlalchemy.orm import sessionmaker
 
-from bus.om_bus_client import MessageClient
-from gateway.dto import VentilationDTO, VentilationSourceDTO, \
-    VentilationStatusDTO
+from gateway.dto import PluginDTO, PluginVentilationDTO, SourceDTO, \
+    VentilationDTO, VentilationStatusDTO
+from gateway.enums import Source, VentilationEnums
 from gateway.events import GatewayEvent
-from gateway.models import Base, Database, Plugin, Ventilation
+from gateway.models import Base, Database, Plugin, Room, Ventilation
 from gateway.pubsub import PubSub
 from gateway.ventilation_controller import VentilationController
 from ioc import SetTestMode, SetUpTestInjections
 
 
 class VentilationControllerTest(unittest.TestCase):
+
+    class _MockPluginController(object):
+        def __init__(self):
+            self.ventilation_callback_action = None
+
+        def execute_ventilation_action(self, action, action_payload, destination):
+            if action == VentilationEnums.Action.SET_AUTO:
+                self.ventilation_callback_action(action=VentilationEnums.CallbackAction.REPORT_STATUS,
+                                                 action_payload={'external_id': action_payload['external_id'],
+                                                                 'mode': 'auto',
+                                                                 'level': None,
+                                                                 'remaining_time': None,
+                                                                 'last_seen': None},
+                                                 source=destination)
+            if action == VentilationEnums.Action.SET_MANUAL:
+                self.ventilation_callback_action(action=VentilationEnums.CallbackAction.REPORT_STATUS,
+                                                 action_payload={'external_id': action_payload['external_id'],
+                                                                 'mode': 'manual',
+                                                                 'level': action_payload['level'],
+                                                                 'remaining_time': action_payload['timer'],
+                                                                 'last_seen': None},
+                                                 source=destination)
+
     @classmethod
     def setUpClass(cls):
         SetTestMode()
 
     def setUp(self):
+        self.maxDiff = None
+
         engine = create_engine(
             'sqlite://', connect_args={'check_same_thread': False}
         )
@@ -50,12 +74,13 @@ class VentilationControllerTest(unittest.TestCase):
         self.addCleanup(session_mock.stop)
 
         self.pubsub = PubSub()
-        SetUpTestInjections(pubsub=self.pubsub)
+        SetUpTestInjections(pubsub=self.pubsub,
+                            plugin_controller=VentilationControllerTest._MockPluginController())
         self.controller = VentilationController()
 
-    def test_set_status(self):
+    def test_report_status(self):
         with self.session as db:
-            fields = {'source': 'plugin',
+            fields = {'source': Source.PLUGIN,
                       'plugin_id': 2,
                       'device_serial': '',
                       'device_type': '',
@@ -66,17 +91,17 @@ class VentilationControllerTest(unittest.TestCase):
                 Ventilation(id=43, name='Bar', external_id='bar', amount_of_levels=4, **fields),
             ])
             db.commit()
-        self.controller.set_status(VentilationStatusDTO(42, 'manual', level=0))
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0))
+        self.controller._report_status(VentilationStatusDTO(42, 'manual', level=0))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=60.0))
         status = self.controller.get_status()
-        assert {'manual'} == set(x.mode for x in status)
-        assert {42, 43} == set(x.id for x in status)
-        assert {0, 2} == set(x.level for x in status)
-        assert {None, 60.0} == set(x.timer for x in status)
+        assert set(x.mode for x in status) == {'manual'}
+        assert set(x.id for x in status) == {42, 43}
+        assert set(x.level for x in status) == {0, 2}
+        assert set(x.remaining_time for x in status) == {None, 60.0}
 
     def test_set_level(self):
         with self.session as db:
-            fields = {'source': 'plugin',
+            fields = {'source': Source.PLUGIN,
                       'plugin_id': 2,
                       'device_serial': '',
                       'device_type': '',
@@ -90,14 +115,14 @@ class VentilationControllerTest(unittest.TestCase):
         self.controller.set_level(42, 0)
         self.controller.set_level(43, 2, timer=60.0)
         status = self.controller.get_status()
-        assert {'manual'} == set(x.mode for x in status)
-        assert {42, 43} == set(x.id for x in status)
-        assert {0, 2} == set(x.level for x in status)
-        assert {None, 60.0} == set(x.timer for x in status)
+        assert set(x.mode for x in status) == {'manual'}
+        assert set(x.id for x in status) == {42, 43}
+        assert set(x.level for x in status) == {0, 2}
+        assert set(x.remaining_time for x in status) == {None, 60.0}
 
     def test_mode_auto(self):
         with self.session as db:
-            fields = {'source': 'plugin',
+            fields = {'source': Source.PLUGIN,
                       'plugin_id': 2,
                       'device_serial': '',
                       'device_type': '',
@@ -119,11 +144,11 @@ class VentilationControllerTest(unittest.TestCase):
         assert {'auto'} == set(x.mode for x in status)
         assert {42, 43} == set(x.id for x in status)
         assert {None} == set(x.level for x in status)
-        assert {None} == set(x.timer for x in status)
+        assert {None} == set(x.remaining_time for x in status)
 
     def test_set_invalid_level(self):
         with self.session as db:
-            fields = {'source': 'plugin',
+            fields = {'source': Source.PLUGIN,
                       'plugin_id': 2,
                       'device_serial': '',
                       'device_type': '',
@@ -143,23 +168,23 @@ class VentilationControllerTest(unittest.TestCase):
                        name='dummy',
                        version='0.0.1'),
                 Ventilation(id=42,
-                               source='plugin',
-                               external_id='device-000001',
-                               name='foo',
-                               amount_of_levels=4,
-                               device_vendor='example',
-                               device_type='model-0',
-                               device_serial='device-000001',
-                               plugin_id=2)
+                            source='plugin',
+                            external_id='device-000001',
+                            name='foo',
+                            amount_of_levels=4,
+                            device_vendor='example',
+                            device_type='model-0',
+                            device_serial='device-000001',
+                            plugin_id=2)
             ])
             db.commit()
 
         ventilation_dto = self.controller.load_ventilation(42)
         assert ventilation_dto == VentilationDTO(id=42,
                                                  external_id='device-000001',
-                                                 source=VentilationSourceDTO(id=2,
-                                                                             name='dummy',
-                                                                             type='plugin'),
+                                                 source=SourceDTO(source=Source.PLUGIN,
+                                                                  source_id=2),
+                                                 plugin=PluginDTO(2, name='dummy'),
                                                  name='foo',
                                                  amount_of_levels=4,
                                                  device_vendor='example',
@@ -171,13 +196,16 @@ class VentilationControllerTest(unittest.TestCase):
             db.add(Plugin(id=2, name='dummy', version='0.0.1'))
             db.commit()
 
-        source_dto = VentilationSourceDTO('plugin', name='dummy')
-        self.controller.register_ventilation(source_dto, 'device-000001', {
-            'amount_of_levels': 4,
-            'device_vendor': 'example',
-            'device_type': 'model-0',
-            'device_serial': 'device-000001'
-        })
+        source_dto = SourceDTO(source=Source.PLUGIN,
+                               source_id=2)
+        self.controller._plugin_ventilation_callback_action(source=source_dto,
+                                                            action=VentilationEnums.CallbackAction.REGISTER,
+                                                            action_payload=PluginVentilationDTO(external_id='device-000001',
+                                                                                                name='device-000001',
+                                                                                                amount_of_levels=4,
+                                                                                                device_vendor='example',
+                                                                                                device_type='model-0',
+                                                                                                device_serial='device-000001'))
 
         with self.session as db:
             query = db.query(Ventilation).filter_by(external_id='device-000001')
@@ -199,14 +227,17 @@ class VentilationControllerTest(unittest.TestCase):
                             device_serial='',
                             source='plugin',
                             plugin=Plugin(id=2, name='dummy', version='0.0.1')),
+                Room(id=1,
+                     number=10,
+                     name='Bathroom')
             ])
             db.commit()
         ventilation_dto = VentilationDTO(id=42,
                                          external_id='device-000001',
-                                         source=VentilationSourceDTO(id=2,
-                                                                     name='dummy',
-                                                                     type='plugin'),
+                                         source=SourceDTO(source=Source.PLUGIN,
+                                                          source_id=2),
                                          name='foo',
+                                         room=10,
                                          amount_of_levels=4,
                                          device_vendor='example',
                                          device_type='model-0',
@@ -217,11 +248,26 @@ class VentilationControllerTest(unittest.TestCase):
             assert query.count() == 1, query.all()
             ventilation = query.one()
             assert ventilation.name == 'foo'
+            assert ventilation.room.name == 'Bathroom'
             assert ventilation.amount_of_levels == 4
             assert ventilation.device_vendor == 'example'
             assert ventilation.device_type == 'model-0'
             assert ventilation.device_serial == 'device-000001'
 
+        ventilation_dto = VentilationDTO(id=42,
+                                         external_id='device-000001',
+                                         source=SourceDTO(source=Source.PLUGIN,
+                                                          source_id=2),
+                                         name='bar',
+                                         room=None)
+        self.controller.save_ventilation(ventilation_dto)
+        with self.session as db:
+            query = db.query(Ventilation).filter_by(external_id='device-000001')
+            assert query.count() == 1, query.all()
+            ventilation = query.one()
+            assert ventilation.name == 'bar'
+            assert ventilation.room == None
+
     def test_ventilation_config_events(self):
         with self.session as db:
             db.add_all([
@@ -268,21 +314,21 @@ class VentilationControllerTest(unittest.TestCase):
             ])
             db.commit()
 
-        self.controller.set_status(VentilationStatusDTO(42, 'manual', level=0))
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0))
+        self.controller._report_status(VentilationStatusDTO(42, 'manual', level=0))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=60.0))
         self.pubsub._publish_all_events(blocking=False)
 
         events = []
+
         def callback(event):
             events.append(event)
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
 
-        self.controller.set_status(VentilationStatusDTO(42, 'manual', level=0))
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0))
+        self.controller._report_status(VentilationStatusDTO(42, 'manual', level=0))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=59.0))
         self.pubsub._publish_all_events(blocking=False)
         assert GatewayEvent(GatewayEvent.Types.VENTILATION_CHANGE,
-                            {'id': 43, 'mode': 'manual', 'level': 2, 'timer': 60.0,
-                             'remaining_time': None,'is_connected': True}) in events
+                            {'id': 43, 'mode': 'manual', 'level': 2, 'remaining_time': 59.0, 'is_connected': True}) in events
         assert len(events) == 1, events
 
     def test_ventilation_status_timeout(self):
@@ -304,13 +350,13 @@ class VentilationControllerTest(unittest.TestCase):
             events.append(event)
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
 
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0,
-                                                        last_seen=(time.time() - 600)))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=60.0,
+                                                            last_seen=(time.time() - 600)))
         self.pubsub._publish_all_events(blocking=False)
 
         assert GatewayEvent(GatewayEvent.Types.VENTILATION_CHANGE,
-                            {'id': 43, 'mode': 'manual', 'level': 2, 'timer': 60.0,
-                             'remaining_time': None, 'is_connected': False}) in events
+                            {'id': 43, 'mode': 'manual', 'level': 2, 'remaining_time': 60.0,
+                             'is_connected': False}) in events
         assert len(events) == 1, events
 
     def test_ventilation_controller_inactive_status(self):
@@ -332,8 +378,8 @@ class VentilationControllerTest(unittest.TestCase):
             events.append(event)
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
 
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0,
-                                                        last_seen=(time.time() - 600)))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=60.0,
+                                                            last_seen=(time.time() - 600)))
         self.pubsub._publish_all_events(blocking=False)
 
         self.assertEqual(1, len(events))
@@ -349,7 +395,7 @@ class VentilationControllerTest(unittest.TestCase):
         self.assertEqual(None, last_event.data['mode'])
         self.assertEqual(None, last_event.data['level'])
 
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=2, remaining_time=60.0))
         self.pubsub._publish_all_events(blocking=False)
 
         self.assertEqual(3, len(events))
@@ -361,7 +407,7 @@ class VentilationControllerTest(unittest.TestCase):
         self.assertEqual(3, len(events))
         self.assertEqual(1, len(self.controller._status))
 
-    def test_ventilation_timer_expire_manual(self):
+    def test_ventilation_timer_expiry(self):
         with self.session as db:
             fields = {'source': 'plugin',
                       'plugin_id': 2,
@@ -376,246 +422,60 @@ class VentilationControllerTest(unittest.TestCase):
             db.commit()
 
         events = []
-        def callback(event):
-            events.append(event)
-        self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
-
-        # first timer is running
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=2, timer=60.0, remaining_time=5.0,
-                                                        last_seen=(time.time() - 10)))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-
-        # This should not trigger an event
-        self.controller._check_connected_timeout()
-        # This should trigger an update event.
-        self.controller._periodic_event_update()
-        self.pubsub._publish_all_events(blocking=False)
-        self.assertEqual(2, len(events))
-        self.assertEqual(1, len(self.controller._status))
-
-        events = []
-        # event that timer has been done
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(None, events[-1].data['remaining_time'])
-        self.assertEqual(None, events[-1].data['timer'])
-
-        events = []
-        # event that timer has been started
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=30, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(None, events[-1].data['remaining_time'])
-        self.assertEqual(30, events[-1].data['timer'])
-
-        events = []
-        # event from ventilation plugin
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=1, timer=None, remaining_time=29,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(29, events[-1].data['remaining_time'])
-        self.assertEqual(30, events[-1].data['timer'])  # this value should be kept in cache
-
-        events = []
-        # event from ventilation plugin
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=15,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(15, events[-1].data['remaining_time'])  # this value should update from the event
-        self.assertEqual(30, events[-1].data['timer'])  # this value should be kept in cache
-
-        events = []
-        # event from ventilation plugin (same value)
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=15,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(0, len(events))
-        self.assertEqual(1, len(self.controller._status))
-
-        # event from ventilation plugin
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=14,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(14, events[-1].data['remaining_time'])  # this value should update from the event
-        self.assertEqual(30, events[-1].data['timer'])  # this value should be kept in cache
-
-        events = []
-        # event from ventilation plugin -> Timer has expired, but is still in manual mode
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-        self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(None, events[-1].data['remaining_time'])
-        self.assertEqual(None, events[-1].data['timer'])  # this value should now be cleared when timer has done
-
-    def test_ventilation_timer_expire_automatic(self):
-        with self.session as db:
-            fields = {'source': 'plugin',
-                      'plugin_id': 2,
-                      'device_serial': '',
-                      'device_type': '',
-                      'device_vendor': ''}
-            db.add_all([
-                Plugin(id=2, name='dummy', version='0.0.1'),
-                Ventilation(id=42, name='Foo', external_id='foo', amount_of_levels=2, **fields),
-                Ventilation(id=43, name='Bar', external_id='bar', amount_of_levels=4, **fields),
-            ])
-            db.commit()
 
-        events = []
         def callback(event):
             events.append(event)
         self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
 
         # event that ventilation box is running in automatic mode
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
+        self.controller._report_status(VentilationStatusDTO(43, 'automatic', level=1, remaining_time=None, last_seen=time.time()))
         self.pubsub._publish_all_events(blocking=False)
 
         self.assertEqual(1, len(events))
         self.assertEqual(1, len(self.controller._status))
         self.assertEqual(None, events[-1].data['remaining_time'])  # no timers running
-        self.assertEqual(None, events[-1].data['timer'])  # no timers running
 
         events = []
         # event that timer has been started
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=30, remaining_time=None,
-                                                        last_seen=time.time()))
+        self.controller._report_status(VentilationStatusDTO(43, 'manual', level=1, remaining_time=30, last_seen=time.time()))
         self.pubsub._publish_all_events(blocking=False)
 
         self.assertEqual(1, len(events))
         self.assertEqual(1, len(self.controller._status))
-        self.assertEqual(None, events[-1].data['remaining_time'])  # There has not been an update from the ventilation box or plugin
-        self.assertEqual(30, events[-1].data['timer'])
+        self.assertEqual(30, events[-1].data['remaining_time'])
 
         for i in range(30, 0, -1):
             events = []
             # event from ventilation plugin
             mode = 'automatic' if i % 2 == 0 else 'manual'
-            self.controller.set_status(VentilationStatusDTO(43, mode, level=1, timer=None, remaining_time=i,
-                                                            last_seen=time.time()))
+            self.controller._report_status(VentilationStatusDTO(43, mode, level=1, remaining_time=i, last_seen=time.time()))
             self.pubsub._publish_all_events(blocking=False)
 
             self.assertEqual(1, len(events))
             self.assertEqual(1, len(self.controller._status))
             self.assertEqual(i, events[-1].data['remaining_time'])
-            self.assertEqual(30, events[-1].data['timer'])  # this value should be kept in cache
 
         events = []
         # event from ventilation plugin -> Timer has expired, and has switched to automatic mode
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
+        self.controller._report_status(VentilationStatusDTO(43, 'automatic', level=1, remaining_time=None, last_seen=time.time()))
         self.pubsub._publish_all_events(blocking=False)
 
         self.assertEqual(1, len(events))
         self.assertEqual(1, len(self.controller._status))
         self.assertEqual(None, events[-1].data['remaining_time'])
-        self.assertEqual(None, events[-1].data['timer'])  # this value should now be cleared when timer has done
 
     def test_ventilation_status_equal_evaluation(self):
-        status_dto_1 = VentilationStatusDTO(1, 'automatic', level=1, timer=None, remaining_time=None,
-                                            last_seen=time.time())
-        status_dto_2 = VentilationStatusDTO(1, 'manual', level=1, timer=30, remaining_time=None,
-                                            last_seen=time.time())
-        status_dto_3 = VentilationStatusDTO(1, 'manual', level=1, timer=None, remaining_time=15,
-                                            last_seen=time.time())
-        status_dto_4 = VentilationStatusDTO(1, 'manual', level=1, timer=None, remaining_time=None,
-                                            last_seen=time.time())
-        status_dto_5 = VentilationStatusDTO(1, 'automatic', level=1, timer=None, remaining_time=None,
-                                            last_seen=time.time())
-
-        self.assertEqual(True, (status_dto_1 == status_dto_5))
-        self.assertEqual(False, (status_dto_1 == status_dto_2))
-        self.assertNotEqual(status_dto_1, status_dto_2)  # Difference between no timer and setup timer
-        self.assertNotEqual(status_dto_1, status_dto_3)  # difference between no timer and running timer
-        self.assertNotEqual(status_dto_2, status_dto_3)  # Difference between status and start timer status
-        self.assertNotEqual(status_dto_1, status_dto_4)  # difference in mode
-        self.assertEqual(status_dto_1, status_dto_5)     # Equal values, but different objects
-
-
-
-
-    def test_ventilation_plugin_anti_ping_pong(self):
-        # This test will see if the gateway will not keep sending events back and forth when an event change happens
-        # This can be caused by ping-ponging back and forth between the plugin and gateway when sending updates
-        with self.session as db:
-            fields = {'source': 'plugin',
-                      'plugin_id': 2,
-                      'device_serial': '',
-                      'device_type': '',
-                      'device_vendor': ''}
-            db.add_all([
-                Plugin(id=2, name='dummy', version='0.0.1'),
-                Ventilation(id=42, name='Foo', external_id='foo', amount_of_levels=2, **fields),
-                Ventilation(id=43, name='Bar', external_id='bar', amount_of_levels=4, **fields),
-            ])
-            db.commit()
-
-        events = []
-        def callback(event, self=self):
-            events.append(event)
-            if len(events) > 20:
-                self.fail('There should never be more than 20 events due to ventilation in this test')
-            # resend the same event to mock the plugin who will send an event back with the same status
-            # id, mode, level=None, timer=None, remaining_time=None, last_seen=None
-            status_dto = VentilationStatusDTO(
-                id=event.data['id'],
-                mode=event.data['mode'],
-                level=event.data['level'],
-                remaining_time=event.data['timer'],
-            )
-            self.controller.set_status(status_dto)
-            self.pubsub._publish_all_events(blocking=False)
-
-        self.pubsub.subscribe_gateway_events(PubSub.GatewayTopics.STATE, callback)
-
-        # event that ventilation box is running in automatic mode
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertEqual(1, len(events))
-
-        events = []
-        # event that timer has been started
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=1, timer=30, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertGreaterEqual(10, len(events))
-
-        # event that timer is running
-        self.controller.set_status(VentilationStatusDTO(43, 'manual', level=1, timer=None, remaining_time=15,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertGreaterEqual(10, len(events))
-
-        # event that timer is done
-        self.controller.set_status(VentilationStatusDTO(43, 'automatic', level=1, timer=None, remaining_time=None,
-                                                        last_seen=time.time()))
-        self.pubsub._publish_all_events(blocking=False)
-
-        self.assertGreaterEqual(10, len(events))
+        status_dto_1 = VentilationStatusDTO(1, 'automatic', level=1, remaining_time=None, last_seen=time.time())
+        status_dto_2 = VentilationStatusDTO(1, 'manual', level=1, remaining_time=30, last_seen=time.time())
+        status_dto_3 = VentilationStatusDTO(1, 'manual', level=1, remaining_time=None, last_seen=time.time())
+        status_dto_4 = VentilationStatusDTO(1, 'manual', level=1, remaining_time=30, last_seen=time.time())
+
+        for one, two, equal in [(status_dto_1, status_dto_2, False),
+                                (status_dto_1, status_dto_3, False),
+                                (status_dto_1, status_dto_4, False),
+                                (status_dto_2, status_dto_3, False),
+                                (status_dto_2, status_dto_4, True),
+                                (status_dto_3, status_dto_4, False)]:
+            self.assertEqual(one == two, equal, '{0} vs {1} expected to be {2}equal'.format(
+                one, two, '' if equal else 'not '
+            ))
diff --git a/testing/unittests/gateway_tests/webservice_test.py b/testing/unittests/gateway_tests/webservice_test.py
index b91e8c36..25d08ba4 100644
--- a/testing/unittests/gateway_tests/webservice_test.py
+++ b/testing/unittests/gateway_tests/webservice_test.py
@@ -16,23 +16,24 @@ from __future__ import absolute_import
 
 import json
 import unittest
-
 import mock
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
 
 from bus.om_bus_client import MessageClient
-from cloud.events import EventSender
 from enums import HardwareType
 from gateway.api.serializers import SensorSerializer
 from gateway.dto import DimmerConfigurationDTO, EnergyModuleDTO, ModuleDTO, \
-    OutputStatusDTO, PumpGroupDTO, ScheduleDTO, SensorDTO, SensorSourceDTO, \
-    SensorStatusDTO, ThermostatDTO, ThermostatGroupDTO, ThermostatStatusDTO, \
-    UserDTO, VentilationDTO, VentilationSourceDTO, VentilationStatusDTO
+    OutputStatusDTO, PumpGroupDTO, ScheduleDTO, SensorDTO, SourceDTO, \
+    SensorStateDTO, ThermostatGroupDTO, \
+    UserDTO, VentilationDTO
 from gateway.energy_module_controller import EnergyModuleController
-from gateway.enums import ModuleType
+from gateway.enums import ModuleType, Source
 from gateway.group_action_controller import GroupActionController
 from gateway.hal.frontpanel_controller import FrontpanelController
 from gateway.input_controller import InputController
 from gateway.maintenance_controller import MaintenanceController
+from gateway.models import Base, Database, Ventilation, Plugin
 from gateway.module_controller import ModuleController
 from gateway.output_controller import OutputController
 from gateway.pulse_counter_controller import PulseCounterController
@@ -46,6 +47,8 @@ from gateway.ventilation_controller import VentilationController
 from gateway.webservice import WebInterface
 from ioc import SetTestMode, SetUpTestInjections
 
+from cloud.events import EventSender
+
 
 class WebInterfaceTest(unittest.TestCase):
     @classmethod
@@ -53,6 +56,17 @@ class WebInterfaceTest(unittest.TestCase):
         SetTestMode()
 
     def setUp(self):
+        engine = create_engine(
+            'sqlite://', connect_args={'check_same_thread': False}
+        )
+        Base.metadata.create_all(engine)
+        session_factory = sessionmaker(autocommit=False, autoflush=True, bind=engine)
+
+        self.session = session_factory()
+        session_mock = mock.patch.object(Database, 'get_session', return_value=self.session)
+        session_mock.start()
+        self.addCleanup(session_mock.stop)
+
         self.maxDiff = None
         self.user_controller = mock.Mock(UserController)
         self.output_controller = mock.Mock(OutputController)
@@ -82,7 +96,8 @@ class WebInterfaceTest(unittest.TestCase):
                             energy_module_controller=self.energy_module_controller,
                             event_sender=self.event_sender,
                             uart_controller=mock.Mock(),
-                            update_controller=mock.Mock())
+                            update_controller=mock.Mock(),
+                            hvac_controller=mock.Mock())
         self.web = WebInterface()
 
     def test_get_usernames(self):
@@ -161,7 +176,7 @@ class WebInterfaceTest(unittest.TestCase):
 
     def test_sensor_configurations(self):
         sensor_dto = SensorDTO(id=2,
-                               source=SensorSourceDTO('master'),
+                               source=SourceDTO('master'),
                                external_id='0',
                                physical_quantity='temperature',
                                unit='celcius',
@@ -210,7 +225,7 @@ class WebInterfaceTest(unittest.TestCase):
             save.assert_called()
 
     def test_sensor_status(self):
-        status_dto = SensorStatusDTO(id=2, value=21.0)
+        status_dto = SensorStateDTO(id=2, value=21.0)
         with mock.patch.object(self.sensor_controller, 'get_sensors_status',
                                return_value=[status_dto]):
             response = self.web.get_sensor_status()
@@ -321,13 +336,17 @@ class WebInterfaceTest(unittest.TestCase):
             ])
 
     def test_ventilation_configurations(self):
+        with Database.get_session() as db:
+            db.add(Plugin(name='dummy', version='0.0.1'))
+            db.commit()
         with mock.patch.object(self.ventilation_controller, 'load_ventilations',
                                return_value=[VentilationDTO(id=1, name='test', amount_of_levels=4,
                                                             device_vendor='example',
                                                             device_type='0A',
                                                             device_serial='device-00001',
                                                             external_id='device-00001',
-                                                            source=VentilationSourceDTO(id=2, type='plugin', name='dummy'))]):
+                                                            source=SourceDTO(source=Source.PLUGIN,
+                                                                             source_id=1))]):
             response = self.web.get_ventilation_configurations()
             self.assertEqual([{
                 'id': 1,
@@ -339,12 +358,20 @@ class WebInterfaceTest(unittest.TestCase):
                 'device': {'vendor': 'example',
                            'type': '0A',
                            'serial': 'device-00001'}
-            }], json.loads(response)['config'])
+            }], json.loads(response).get('config'), response)
 
     def test_set_ventilation_configuration(self):
+        with Database.get_session() as db:
+            db.add(Ventilation(source='plugin',
+                               plugin=Plugin(name='dummy', version='0.0.1'),
+                               external_id='empty',
+                               name='',
+                               amount_of_levels=1))
+            db.commit()
+            ventilation_id = db.query(Ventilation).first().id
         with mock.patch.object(self.ventilation_controller, 'save_ventilation',
                                return_value=None) as save:
-            config = {'id': 1,
+            config = {'id': ventilation_id,
                       'source': {'type': 'plugin', 'name': 'dummy'},
                       'external_id': 'device-00001',
                       'name': 'test',
@@ -353,7 +380,7 @@ class WebInterfaceTest(unittest.TestCase):
                                  'serial': 'device-00001'}}
             response = self.web.set_ventilation_configuration(config=config)
             self.assertEqual({
-                'id': 1,
+                'id': ventilation_id,
                 'amount_of_levels': 0,
                 'source': {'type': 'plugin', 'name': 'dummy'},
                 'external_id': 'device-00001',
@@ -362,27 +389,9 @@ class WebInterfaceTest(unittest.TestCase):
                 'device': {'vendor': 'example',
                            'type': '0A',
                            'serial': 'device-00001'},
-            }, json.loads(response)['config'])
+            }, json.loads(response).get('config'), response)
             save.assert_called()
 
-    def test_set_ventilation_status(self):
-        with mock.patch.object(self.ventilation_controller, 'set_status',
-                               return_value=VentilationStatusDTO(id=1,
-                                                                 mode='manual',
-                                                                 level=2,
-                                                                 remaining_time=60.0)) as set_status:
-            status = {'id': 1, 'mode': 'manual', 'level': 2, 'remaining_time': 60.0}
-            response = self.web.set_ventilation_status(status=status)
-            self.assertEqual({
-                'id': 1,
-                'connected': True,
-                'mode': 'manual',
-                'level': 2,
-                'remaining_time': 60.0,
-                'timer': None
-            }, json.loads(response)['status'])
-            set_status.assert_called()
-
     def test_set_all_lights_off(self):
         with mock.patch.object(self.output_controller, 'set_all_lights',
                                return_value={}) as set_status:
diff --git a/testing/unittests/mocked_core_helper.py b/testing/unittests/mocked_core_helper.py
index 7415be04..ab91c013 100644
--- a/testing/unittests/mocked_core_helper.py
+++ b/testing/unittests/mocked_core_helper.py
@@ -56,7 +56,9 @@ class MockedCore(object):
     def _do_command(self, command, fields, timeout=None, bypass_blockers=None):
         _ = timeout
         instruction = ''.join(str(chr(c)) for c in command.instruction)
-        if instruction == 'MR':
+        if instruction in self.return_data:
+            return self.return_data[instruction]
+        elif instruction == 'MR':
             mtype = fields['type']
             page = fields['page']
             start = fields['start']
@@ -74,7 +76,7 @@ class MockedCore(object):
             if fields['type'] == 200 and fields['action'] == 1:
                 # Send EEPROM_ACTIVATE event
                 self.memory_file._handle_event({'type': 248, 'action': 0, 'device_nr': 0, 'data': bytearray([1, 0])})
-        elif instruction in self.return_data:
-            return self.return_data[instruction]
+        elif instruction == 'DL':
+            return {"serial_number": [99, 99, 99, 9, 9, 99, 99], "production_test_result": 0xff}
         else:
             raise AssertionError('unexpected instruction: {0}'.format(instruction))
diff --git a/testing/unittests/plugins_tests/base_test.py b/testing/unittests/plugins_tests/base_test.py
index a43e357c..732aba89 100644
--- a/testing/unittests/plugins_tests/base_test.py
+++ b/testing/unittests/plugins_tests/base_test.py
@@ -30,19 +30,13 @@ from subprocess import call
 
 import mock
 import ujson as json
-from peewee import SqliteDatabase
 from pytest import mark
-from sqlalchemy import create_engine, select
-from sqlalchemy.orm import scoped_session, sessionmaker
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
 from sqlalchemy.pool import StaticPool
 
 import plugin_runtime
-from gateway.dto import OutputStatusDTO
-from gateway.enums import ShutterEnums
-from gateway.events import GatewayEvent
 from gateway.models import Base, Database, Plugin
-from gateway.output_controller import OutputController
-from gateway.shutter_controller import ShutterController
 from ioc import SetTestMode, SetUpTestInjections
 from logs import Logs
 from plugin_runtime.base import PluginConfigChecker, PluginException, \
@@ -63,8 +57,9 @@ class PluginControllerTest(unittest.TestCase):
         SetTestMode()
         cls.PLUGINS_PATH = tempfile.mkdtemp()
         cls.PLUGIN_CONFIG_PATH = tempfile.mkdtemp()
-        Logs.set_loglevel(logging.DEBUG, namespace='gateway.plugin_controller')
-        # Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
+        logger = logging.getLogger('')
+        logger.setLevel(logging.DEBUG)
+        Logs.set_loglevel(logging.ERROR, namespace='sqlalchemy')
 
     @classmethod
     def tearDownClass(cls):
@@ -110,18 +105,29 @@ class PluginControllerTest(unittest.TestCase):
             shutil.rmtree(path)
 
     @staticmethod
-    def _get_controller(output_controller=None, shutter_controller=None):
+    def _get_controller(output_controller=None, shutter_controller=None, screen_controller=None):
         SetUpTestInjections(shutter_controller=shutter_controller,
                             web_interface=None,
                             configuration_controller=None,
-                            output_controller=output_controller)
+                            output_controller=output_controller,
+                            screen_controller=screen_controller)
         from plugins.base import PluginController
         PluginController.DEPENDENCIES_TIMER = 0.25
         controller = PluginController(runtime_path=PluginControllerTest.RUNTIME_PATH,
-                                      plugins_path=PluginControllerTest.PLUGINS_PATH,
-                                      plugin_config_path=PluginControllerTest.PLUGIN_CONFIG_PATH)
-        metric_controller = type('MetricController', (), {'get_filter': lambda *args, **kwargs: ['test'],
-                                                          'set_plugin_definitions': lambda _self, *args, **kwargs: None})()
+                                      plugins_path=PluginControllerTest.PLUGINS_PATH)
+        from gateway.metrics_caching import MetricsCacheController
+        from gateway.metrics_collector import MetricsCollector
+        metrics_cache_controller = mock.Mock(MetricsCacheController)
+        metrics_cache_controller.load_buffer.return_value = []
+        metrics_collector = mock.Mock(MetricsCollector)
+        metrics_collector.get_definitions.return_value = []
+        metrics_collector.set_plugin_intervals.return_value = None
+        SetUpTestInjections(plugin_controller=controller,
+                            metrics_collector=metrics_collector,
+                            metrics_cache_controller=metrics_cache_controller,
+                            cloud_api_client=None)
+        from gateway.metrics_controller import MetricsController
+        metric_controller = MetricsController()
         controller.set_metrics_controller(metric_controller)
         return controller
 
@@ -203,11 +209,11 @@ class P2(OMPluginBase):
             PluginControllerTest._destroy_plugin('P2')
 
     @mark.slow
-    def test_dependencies_callback(self):
+    def test_state_callback(self):
         """ Test getting one plugin in the plugins package. """
         called = {'called': 0}
 
-        def _call():
+        def _call(plugin_id, state):
             called['called'] += 1
 
         def _wait_for_called(amount, timeout=1):
@@ -228,10 +234,9 @@ class P1(OMPluginBase):
     interfaces = []
 """)
             controller = PluginControllerTest._get_controller()
-            controller._update_dependencies = _call
-            controller.start()
-            self.assertIsNotNone(controller._dependencies_timer)
+            controller._runner_state_changed = _call
             self.assertEqual(0, called['called'])
+            controller.start()
             _wait_for_called(1)
             controller.stop_plugin('P1')
             _wait_for_called(2)
@@ -241,254 +246,11 @@ class P1(OMPluginBase):
             PluginControllerTest._destroy_plugin('P1')
 
     @mark.slow
-    def test_get_special_methods(self):
-        """ Test getting special methods on a plugin. """
-        controller = None
-        try:
-            PluginControllerTest._create_plugin('P1', """
-import time
-from plugins.base import *
-
-class P1(OMPluginBase):
-    name = 'P1'
-    version = '0.1.0'
-    interfaces = [('webui', '1.0')]
-
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-        self._bg_running = False
-        self._input_data = None
-        self._input_data_version_2 = None
-        self._output_data = None
-        self._output_data_version_2 = None
-        self._sensor_data = None
-        self._event_data = None
-
-    @om_expose(auth=True)
-    def html_index(self):
-        return 'HTML'
-
-    @om_expose(auth=False)
-    def get_log(self):
-        return {'bg_running': self._bg_running,
-                'input_data': self._input_data,
-                'input_data_version_2': self._input_data_version_2,
-                'output_data': self._output_data,
-                'output_data_version_2': self._output_data_version_2,
-                'sensor_data': self._sensor_data,
-                'event_data': self._event_data}
-
-    @input_status
-    def input(self, input_status_inst):
-        self._input_data = input_status_inst
-        
-    @input_status(version=2)
-    def input_version_2(self, input_status_inst):
-        self._input_data_version_2 = input_status_inst
-        
-    @output_status
-    def output(self, output_status_inst):
-        self._output_data = output_status_inst
-        
-    @output_status(version=2)
-    def output_version_2(self, output_status_inst):
-        self._output_data_version_2 = output_status_inst
-        
-    @sensor_status(version=1)
-    def sensor(self, sensor_status_inst):
-        self._sensor_data = sensor_status_inst
-        
-    @receive_events
-    def recv_events(self, code):
-        self._event_data = code
-
-    @background_task
-    def run(self):
-        while True:
-            self._bg_running = True
-            time.sleep(1)
-""")
-
-            output_controller = mock.Mock(OutputController)
-            output_controller.get_output_statuses = lambda: [OutputStatusDTO(id=1, status=True, dimmer=5)]
-            controller = PluginControllerTest._get_controller(output_controller=output_controller)
-            controller.start()
-
-            kwargs = {'plugin_web_request': PluginWebRequest(method='html_index', version=1).serialize()}
-            response = controller._request('P1', 'html_index', kwargs=kwargs)
-            response = PluginWebResponse.deserialize(response).body
-            self.assertEqual(response, 'HTML')
-
-            rising_input_event = {'id': 1,
-                                  'status': True,
-                                  'location': {'room_id': 1}}
-            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.INPUT_CHANGE, data=rising_input_event))
-            falling_input_event = {'id': 2,
-                                   'status': False,
-                                   'location': {'room_id': 5}}
-            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.INPUT_CHANGE, data=falling_input_event))
-            output_event = {'id': 1,
-                            'status': {'on': True,
-                                       'value': 5,
-                                       'locked': True},
-                            'location': {'room_id': 5}}
-            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.OUTPUT_CHANGE, data=output_event))
-            sensor_event = {'id': 1,
-                            'value': 21.5,
-                            'timestamp': 164434668.79582}
-            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.SENSOR_CHANGE, data=sensor_event))
-            controller.process_event(1)
-
-            keys = ['input_data', 'input_data_version_2', 'output_data', 'output_data_version_2', 'sensor_data', 'event_data']
-            start = time.time()
-            while time.time() - start < 2:
-                kwargs = {'plugin_web_request': PluginWebRequest(method='html_index', version=1).serialize()}
-                response = controller._request('P1', 'get_log', kwargs=kwargs)
-                response = PluginWebResponse.deserialize(response).body
-                if all(response[key] is not None for key in keys):
-                    break
-                time.sleep(0.1)
-            self.assertEqual(response['bg_running'], True)
-            self.assertEqual(response['input_data'], [1, None])  # only rising edges should be triggered
-            self.assertEqual(response['input_data_version_2'], {'input_id': 2, 'status': False})
-            self.assertEqual(response['output_data'],  [[1, 5]])
-            self.assertEqual(response['output_data_version_2'], output_event)
-            self.assertEqual(response['sensor_data'], sensor_event)
-            self.assertEqual(response['event_data'], 1)
-        finally:
-            if controller is not None:
-                controller.stop()
-            PluginControllerTest._destroy_plugin('P1')
-
-    @mark.slow
-    def test_get_unsupported_decorators(self):
-        """ Test getting special methods on a plugin. """
-        controller = None
-        try:
-            PluginControllerTest._create_plugin('UnsupportedPlugin', """
-import time
-from plugins.base import *
-
-class UnsupportedPlugin(OMPluginBase):
-    name = 'UnsupportedPlugin'
-    version = '0.1.0'
-    interfaces = [('webui', '1.0')]
-        
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-
-    @om_expose(auth=True)
-    def html_index(self):
-        return 'HTML'
-
-    @input_status(version=3)
-    def input_with_unsupported_decorator(self, test_data):
-        pass
-
-    @output_status(version=3)
-    def output_with_unsupported_decorator(self, test_data):
-        pass
-""")
-            output_controller = mock.Mock(OutputController)
-            controller = PluginControllerTest._get_controller(output_controller=output_controller)
-            # the plugin will fail to load, but only log this
-            controller.start()
-            # get the logs and check if we see the output in the logs
-            plugin_logs = controller.get_logs()['UnsupportedPlugin']
-            matches = ['Decorator', 'version', 'is not supported']
-            self.assertTrue(all(match in plugin_logs for match in matches), plugin_logs)
-        finally:
-            if controller is not None:
-                controller.stop()
-            PluginControllerTest._destroy_plugin('UnsupportedPlugin')
-
-    @mark.slow
-    def test_get_shutter_decorators(self):
-        """ Test getting shutter decorators on a plugin. """
+    def test_update_plugin(self):
         controller = None
         try:
-            PluginControllerTest._create_plugin('ShutterPlugin', """
-from plugins.base import *
-
-class ShutterPlugin(OMPluginBase):
-    name = 'ShutterPlugin'
-    version = '0.1.0'
-    interfaces = [('webui', '1.0')]
-        
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-        self._shutter_data_v1 = None
-        self._shutter_data_v1_detail = None
-        self._shutter_data_v2 = None
-        self._shutter_data_v3 = None
-        
-    @om_expose(auth=True)
-    def html_index(self):
-        return 'HTML'
-
-    @om_expose(auth=False)
-    def get_log(self):
-        return {'shutter_data_v1': self._shutter_data_v1,
-                'shutter_data_v1_detail': self._shutter_data_v1_detail,
-                'shutter_data_v2': self._shutter_data_v2,
-                'shutter_data_v3': self._shutter_data_v3}
-                
-    @shutter_status
-    def shutter_v1(self, test_data):
-        self._shutter_data_v1 = test_data
-        
-    @shutter_status
-    def shutter_v1_detail(self, test_data, detail):
-        self._shutter_data_v1_detail = (test_data, detail)
-        
-    @shutter_status(version=2)
-    def shutter_v2(self, test_data, detail):
-        self._shutter_data_v2 = (test_data, detail)
-        
-    @shutter_status(version=3)
-    def shutter_v3(self, shutter_event):
-        self._shutter_data_v3 = shutter_event
-""")
-            shutter_controller = mock.Mock(ShutterController)
-            shutter_status = [ShutterEnums.State.STOPPED]
-            detail_for_shutter = {'1': {'state': ShutterEnums.State.STOPPED,
-                                      'actual_position': None,
-                                      'desired_position': None,
-                                      'last_change': 1596787761.147892}}
-            shutter_controller.get_states = lambda: {'status': shutter_status,
-                                                     'detail': detail_for_shutter}
-            controller = PluginControllerTest._get_controller(shutter_controller=shutter_controller)
-            controller.start()
-
-            shutter_event = GatewayEvent(event_type=GatewayEvent.Types.SHUTTER_CHANGE, data={'some_random_key': 'some_random_value'})
-            controller.process_gateway_event(shutter_event)
-
-            keys = ['shutter_data_v1', 'shutter_data_v1_detail', 'shutter_data_v2', 'shutter_data_v3']
-            start = time.time()
-            dict_response = None
-            while time.time() - start < 2:
-                kwargs = {'plugin_web_request': PluginWebRequest(method='get_log', version=1).serialize()}
-                response = controller._request('ShutterPlugin', 'get_log', kwargs=kwargs)
-                # Expect a plugin web response string
-                plugin_response = PluginWebResponse.deserialize(response)
-                dict_response = plugin_response.body
-                if all(dict_response[key] is not None for key in keys):
-                    break
-                time.sleep(0.1)
-            self.maxDiff = None
-            self.assertEqual(dict_response['shutter_data_v1'], shutter_status)
-            self.assertEqual(dict_response['shutter_data_v1_detail'], [shutter_status, detail_for_shutter])
-            self.assertEqual(dict_response['shutter_data_v2'], [shutter_status, detail_for_shutter])
-            self.assertEqual(dict_response['shutter_data_v3'], shutter_event.data)
-        finally:
-            if controller is not None:
-                controller.stop()
-            PluginControllerTest._destroy_plugin('ShutterPlugin')
-
-    @mark.slow
-    def test_update_plugin(self):
-        """ Validates whether a plugin can be updated """
-        test_1_md5, test_1_data = PluginControllerTest._create_plugin_package('Test', """
+            """ Validates whether a plugin can be updated """
+            test_1_md5, test_1_data = PluginControllerTest._create_plugin_package('Test', """
 from plugins.base import *
 
 class Test(OMPluginBase):
@@ -496,7 +258,7 @@ class Test(OMPluginBase):
     version = '0.0.1'
     interfaces = []
 """)
-        test_2_md5, test_2_data = PluginControllerTest._create_plugin_package('Test', """
+            test_2_md5, test_2_data = PluginControllerTest._create_plugin_package('Test', """
 from plugins.base import *
 
 class Test(OMPluginBase):
@@ -505,115 +267,28 @@ class Test(OMPluginBase):
     interfaces = []
 """)
 
-        controller = PluginControllerTest._get_controller()
-        controller.start()
-
-        # Install first version
-        result = controller.install_plugin(test_1_md5, test_1_data)
-        self.assertEqual(result, 'Plugin successfully installed')
-        controller.start_plugin('Test')
-        self.assertEqual([r.name for r in controller.get_plugins()], ['Test'])
-        with Database.get_session() as db:
-            plugin = db.query(Plugin).filter_by(name='Test').one()
-            self.assertEqual('0.0.1', plugin.version)
-
-        # Update to version 2
-        result = controller.install_plugin(test_2_md5, test_2_data)
-        self.assertEqual(result, 'Plugin successfully installed')
-        self.assertEqual([r.name for r in controller.get_plugins()], ['Test'])
-        with Database.get_session() as db:
-            plugin = db.query(Plugin).filter_by(name='Test').one()
-            self.assertEqual('0.0.2', plugin.version)
-
-    @mark.slow
-    def test_plugin_metric_reference(self):
-        """ Validates whether two plugins won't get the same metric instance """
-        controller = None
-        try:
-            p1_md5, p1_data = PluginControllerTest._create_plugin_package('P1', """
-from plugins.base import *
-
-class P1(OMPluginBase):
-    name = 'P1'
-    version = '0.0.1'
-    interfaces = []
-    
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-        self._metric = None
-        
-    @om_expose(auth=False)
-    def get_metric(self):
-        return {'metric': self._metric}
-        
-    @om_metric_receive()
-    def set_metric(self, metric):
-        self._metric = metric
-        self._metric['foo'] = 'P1'
-""")
-            p2_md5, p2_data = PluginControllerTest._create_plugin_package('P2', """
-from plugins.base import *
-
-class P2(OMPluginBase):
-    name = 'P2'
-    version = '0.0.1'
-    interfaces = []
-    
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-        self._metric = None
-        
-    @om_expose(auth=False)
-    def get_metric(self):
-        return {'metric': self._metric}
-        
-    @om_metric_receive()
-    def set_metric(self, metric):
-        self._metric = metric
-        self._metric['foo'] = 'P2'
-""")
-
             controller = PluginControllerTest._get_controller()
             controller.start()
 
-            controller.install_plugin(p1_md5, p1_data)
-            controller.start_plugin('P1')
-            controller.install_plugin(p2_md5, p2_data)
-            controller.start_plugin('P2')
-
-            delivery_rate = controller.distribute_metrics([{'timestamp': 0,
-                                                            'source': 'test',
-                                                            'type': 'test',
-                                                            'tags': {},
-                                                            'values': {}}])
-            self.assertEqual({'total': 2,
-                              'test.test': 2}, delivery_rate)
-
-            start = time.time()
-            p1_metric = {'metric': None}
-            p2_metric = {'metric': None}
-            while time.time() - start < 2:
-                kwargs = {'plugin_web_request': PluginWebRequest(version=1).serialize()}
-                p1_metric = controller._request('P1', 'get_metric', kwargs=kwargs)
-                p1_metric = PluginWebResponse.deserialize(p1_metric).body
-                p2_metric = controller._request('P2', 'get_metric', kwargs=kwargs)
-                p2_metric = PluginWebResponse.deserialize(p2_metric).body
-                if p1_metric['metric'] is not None and p2_metric['metric'] is not None:
-                    break
-                time.sleep(0.1)
-
-            self.assertIsNotNone(p1_metric['metric'])
-            self.assertEqual('P1', p1_metric['metric'].get('foo'))
-            self.assertIsNotNone(p2_metric['metric'])
-            self.assertEqual('P2', p2_metric['metric'].get('foo'))
-            # Compare the addresses to make sure it's a different instance
-            self.assertNotEqual(id(p1_metric['metric']), id(p2_metric['metric']))
+            # Install first version
+            result = controller.install_plugin(test_1_md5, test_1_data)
+            self.assertEqual(result, 'Plugin successfully installed')
+            controller.start_plugin('Test')
+            self.assertEqual([r.name for r in controller.get_plugins()], ['Test'])
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='Test').one()
+                self.assertEqual('0.0.1', plugin.version)
 
+            # Update to version 2
+            result = controller.install_plugin(test_2_md5, test_2_data)
+            self.assertEqual(result, 'Plugin successfully installed')
+            self.assertEqual([r.name for r in controller.get_plugins()], ['Test'])
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='Test').one()
+                self.assertEqual('0.0.2', plugin.version)
         finally:
             if controller is not None:
                 controller.stop()
-            PluginControllerTest._destroy_plugin('P1')
-            PluginControllerTest._destroy_plugin('P2')
 
     def test_check_plugin(self):
         """ Test the exception that can occur when checking a plugin. """
@@ -678,243 +353,6 @@ class P2(OMPluginBase):
         except PluginException as exception:
             self.assertEqual('Plugin \'test\' has no method named \'html_index\'', str(exception))
 
-    @mark.slow
-    def test_om_expose_decorator(self):
-        """ Test the om_expose decorator. """
-        controller = None
-        try:
-            PluginControllerTest._create_plugin('P1', """
-import inspect
-import time
-from plugins.base import *
-
-class P1(OMPluginBase):
-    name = 'P1'
-    version = '0.1.0'
-    interfaces = []
-
-    def __init__(self, webservice, logger):
-        OMPluginBase.__init__(self, webservice, logger)
-        self.logger = logger
-        self.dummy_var = 37
-
-    def print_func_name(self):
-        self.logger('Calling func: {}'.format(inspect.stack()[1][3]))
-
-    # om_expose function naming convention:
-    # vX : version 1 or 2
-    # auth or nonauth
-    # return type
-    @om_expose(auth=True)
-    def v1_auth_string(self):
-        self.print_func_name()
-        return 'string'
-
-    @om_expose(auth=False)
-    def v1_nonauth_dict(self):
-        self.print_func_name()
-        return {'dummy_var': self.dummy_var}
-        
-    @om_expose
-    def v1_default_bytes(self):
-        self.print_func_name()
-        return b'someBytesString'
-        
-    @om_expose
-    def v1_default_param(self, param):
-        self.print_func_name()
-        self.logger('Received param: {} of type: {}'.format(param, type(param)))
-        return param
-        
-    @om_expose(version=2)
-    def v2_default_string(self):
-        self.print_func_name()
-        return 'someString'
-        
-    @om_expose(version=2)
-    def v2_default_param(self, param):
-        self.print_func_name()
-        self.logger('Received param: {} of type: {}'.format(param, type(param)))
-        return param
-        
-    @om_expose(version=2)
-    def v2_default_param_web_request(self, param, plugin_web_request):
-        self.print_func_name()
-        self.logger('Received param: {} of type: {}'.format(param, type(param)))
-        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
-        return param
-        
-    @om_expose(version=2)
-    def v2_default_dict(self, plugin_web_request):
-        self.print_func_name()
-        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
-        return {'response-data': 'response...'} 
-        
-    @om_expose(version=2)
-    def v2_default_param_web_request_web_response(self, param, plugin_web_request):
-        self.print_func_name()
-        self.logger('Received param: {} of type: {}'.format(param, type(param)))
-        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
-        response =PluginWebResponse(
-            status_code=201,
-            headers={'some-header': 'some-header-value'},
-            body=param,
-            path='somePath'
-        )
-        return response
-
-    @om_expose
-    def v1_body(self, request_body):
-        self.print_func_name()
-        self.logger('Received body: {}'.format(request_body))
-        return request_body
-
-    @om_expose(version=2)
-    def v2_body(self, request_body):
-        self.print_func_name()
-        self.logger('Received body: {}'.format(request_body))
-        return request_body
-""")
-
-            controller = PluginControllerTest._get_controller()
-            controller.start()
-
-            def do_request(func, plugin='P1', web_request=None, get_web_response=False, self=self):
-                if web_request is None:
-                    request = PluginWebRequest(version=1).serialize()
-                    version = 1
-                else:
-                    request = web_request.serialize()
-                    version = web_request.version
-
-                kwargs = {'plugin_web_request': request}
-                resp = controller._request(plugin, func, kwargs=kwargs)
-                if not get_web_response:
-                    plugin_response = PluginWebResponse.deserialize(resp)
-                    resp = plugin_response.body
-                    self.assertEqual(plugin_response.version, version)
-                else:
-                    resp = PluginWebResponse.deserialize(resp)
-                return resp
-
-            response = do_request('v1_auth_string')
-            self.assertEqual(response, 'string')
-
-            response = do_request('v1_nonauth_dict')
-            self.assertEqual(response, {'dummy_var': 37})
-
-            response = do_request('v1_default_bytes')
-            self.assertEqual(response, b'someBytesString')
-
-            response = do_request('v1_default_param',
-                                  web_request=PluginWebRequest(version=1, params={'param': 'some-param'}))
-            self.assertEqual(response, 'some-param')
-
-            response = do_request('v1_default_param',
-                                  web_request=PluginWebRequest(version=1, params={'param': {'test': 'test'}}))
-            self.assertEqual(response, {'test': 'test'})
-
-            try:
-                response = do_request('v1_default_param',
-                                      web_request=PluginWebRequest(version=1, params={}))
-                self.fail('There should be a missing parameter')
-            except Exception as ex:
-                pass
-
-            response = do_request('v2_default_string')
-            self.assertEqual(response, 'someString')
-
-            response = do_request('v2_default_param',
-                                  web_request=PluginWebRequest(version=2, params={'param': 'some-param'}))
-            self.assertEqual(response, 'some-param')
-
-            response = do_request('v2_default_param',
-                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}))
-            self.assertEqual(response, {'test': 'test'})
-
-            response = do_request('v2_default_param_web_request',
-                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}))
-            self.assertEqual(response, {'test': 'test'})
-
-            response = do_request('v2_default_dict',
-                                  web_request=PluginWebRequest(version=2, params={}),
-                                  get_web_response=True)
-            self.assertEqual(response.body, {'response-data': 'response...'})
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 200)
-
-            response = do_request('v2_default_param_web_request',
-                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}),
-                                  get_web_response=True)
-            self.assertEqual(response.body, {'test': 'test'})
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 200)
-
-            response = do_request('v2_default_param_web_request_web_response',
-                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}),
-                                  get_web_response=True)
-            self.assertEqual(response.body, {'test': 'test'})
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 201)
-            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
-
-            response = do_request('v2_default_param_web_request_web_response',
-                                  web_request=PluginWebRequest(version=2, params={'param': 'someString'}),
-                                  get_web_response=True)
-            self.assertEqual(response.body, 'someString')
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 201)
-            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
-
-            response = do_request('v2_default_param_web_request_web_response',
-                                  web_request=PluginWebRequest(version=2, params={'param': 'someString', 'param2': 'test'}),
-                                  get_web_response=True)
-            self.assertEqual(response.body, 'someString')
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 201)
-            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
-
-            for special_string in [
-                'someString/someOtherText!@#$%^&*()<>{}[]',
-                'basic_string',
-                u'test_unicode'
-            ]:
-                response = do_request('v2_default_param_web_request_web_response',
-                                      web_request=PluginWebRequest(version=2, params={'param': special_string, 'param2': 'test'}),
-                                      get_web_response=True)
-                self.assertEqual(response.body, special_string)
-                self.assertEqual(response.version, 2)
-                self.assertEqual(response.status_code, 201)
-                self.assertEqual(response.headers, {'some-header': 'some-header-value'})
-
-            try:
-                response = do_request('v2_default_param_web_request_web_response',
-                                      web_request=PluginWebRequest(version=2, params={}),
-                                      get_web_response=True)
-                self.fail('Request should not succeed due to parameter not filled in')
-            except Exception:
-                pass
-
-            response = do_request('v1_body',
-                                  web_request=PluginWebRequest(version=1, body='somebody'),
-                                  get_web_response=True)
-            self.assertEqual(response.body, 'somebody')
-            self.assertEqual(response.version, 1)
-            self.assertEqual(response.status_code, 200)
-
-            response = do_request('v2_body',
-                                  web_request=PluginWebRequest(version=2, body='somebody'),
-                                  get_web_response=True)
-            self.assertEqual(response.body, 'somebody')
-            self.assertEqual(response.version, 2)
-            self.assertEqual(response.status_code, 200)
-
-
-        finally:
-            if controller is not None:
-                controller.stop()
-            PluginControllerTest._destroy_plugin('P1')
-
 
 FULL_DESCR = [
     {'name': 'hostname', 'type': 'str', 'description': 'The hostname of the server.'},
@@ -1278,9 +716,9 @@ class PluginConfigCheckerTest(unittest.TestCase):
             path=None
         )
         try:
-            pwr_serial = pwr.serialize()
+            pwr.serialize()
             self.fail('It should not be possible to serialize web request with object as body')
-        except AttributeError as ex:
+        except AttributeError:
             pass
         except Exception as ex:
             self.fail('Wrong exception raised: {}'.format(ex))
diff --git a/testing/unittests/plugins_tests/connector_test.py b/testing/unittests/plugins_tests/connector_test.py
new file mode 100644
index 00000000..75026581
--- /dev/null
+++ b/testing/unittests/plugins_tests/connector_test.py
@@ -0,0 +1,1122 @@
+# Copyright (C) 2016 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+"""
+Tests for plugin connectors
+"""
+
+from __future__ import absolute_import
+
+import hashlib
+import logging
+import os
+import shutil
+import tempfile
+import time
+import unittest
+from subprocess import call
+
+import mock
+from pytest import mark
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.pool import StaticPool
+
+import plugin_runtime
+from gateway.dto import OutputStatusDTO, SourceDTO, PluginVentilationDTO, PluginSensorDTO
+from gateway.enums import ShutterEnums, VentilationEnums, Source, SensorEnums, NotificationEnums
+from gateway.exceptions import PluginException
+from gateway.events import GatewayEvent
+from gateway.models import Base, Database, Plugin
+from gateway.output_controller import OutputController
+from gateway.shutter_controller import ShutterController
+from ioc import SetTestMode, SetUpTestInjections
+from logs import Logs
+from plugin_runtime.base import PluginWebRequest, PluginWebResponse
+
+MODELS = [Plugin]
+
+
+class PluginConnectorTest(unittest.TestCase):
+    """ Tests for the plugin connectors. """
+
+    PLUGINS_PATH = None
+    PLUGIN_CONFIG_PATH = None
+    RUNTIME_PATH = os.path.dirname(plugin_runtime.__file__)
+
+    @classmethod
+    def setUpClass(cls):
+        SetTestMode()
+        cls.PLUGINS_PATH = tempfile.mkdtemp()
+        cls.PLUGIN_CONFIG_PATH = tempfile.mkdtemp()
+        logger = logging.getLogger('')
+        logger.setLevel(logging.DEBUG)
+        Logs.set_loglevel(logging.ERROR, namespace='sqlalchemy')
+
+    @classmethod
+    def tearDownClass(cls):
+        try:
+            if cls.PLUGINS_PATH is not None:
+                shutil.rmtree(cls.PLUGINS_PATH)
+            if cls.PLUGIN_CONFIG_PATH is not None:
+                shutil.rmtree(cls.PLUGIN_CONFIG_PATH)
+        except Exception:
+            pass
+
+    def setUp(self):
+        self.maxDiff = None
+        engine = create_engine(
+            'sqlite://', connect_args={'check_same_thread': False}, poolclass=StaticPool
+        )
+        Base.metadata.create_all(engine)
+        session_factory = sessionmaker(autocommit=False, autoflush=True, bind=engine)
+
+        self.session = session_factory()
+        session_mock = mock.patch.object(Database, 'get_session', return_value=self.session)
+        session_mock.start()
+        self.addCleanup(session_mock.stop)
+
+    @staticmethod
+    def _create_plugin(name, code, base_path=None):
+        """ Create a plugin with a given name and the provided code. """
+        if base_path is None:
+            base_path = PluginConnectorTest.PLUGINS_PATH
+        path = '{0}/{1}'.format(base_path, name)
+        os.makedirs(path)
+
+        with open('{0}/main.py'.format(path), 'w') as code_file:
+            code_file.write(code)
+
+        with open('{0}/__init__.py'.format(path), 'w'):
+            pass
+
+    @staticmethod
+    def _destroy_plugin(name):
+        """ Remove the code for a plugin created by _create_plugin. """
+        path = '{0}/{1}'.format(PluginConnectorTest.PLUGINS_PATH, name)
+        if os.path.exists(path):
+            shutil.rmtree(path)
+
+    @staticmethod
+    def _get_controller(output_controller=None, shutter_controller=None, screen_controller=None):
+        SetUpTestInjections(shutter_controller=shutter_controller,
+                            web_interface=None,
+                            configuration_controller=None,
+                            output_controller=output_controller,
+                            screen_controller=screen_controller)
+        from plugins.base import PluginController
+        PluginController.DEPENDENCIES_TIMER = 0.25
+        controller = PluginController(runtime_path=PluginConnectorTest.RUNTIME_PATH,
+                                      plugins_path=PluginConnectorTest.PLUGINS_PATH)
+        from gateway.metrics_caching import MetricsCacheController
+        from gateway.metrics_collector import MetricsCollector
+        metrics_cache_controller = mock.Mock(MetricsCacheController)
+        metrics_cache_controller.load_buffer.return_value = []
+        metrics_collector = mock.Mock(MetricsCollector)
+        metrics_collector.get_definitions.return_value = []
+        metrics_collector.set_plugin_intervals.return_value = None
+        SetUpTestInjections(plugin_controller=controller,
+                            metrics_collector=metrics_collector,
+                            metrics_cache_controller=metrics_cache_controller,
+                            cloud_api_client=None)
+        from gateway.metrics_controller import MetricsController
+        metric_controller = MetricsController()
+        controller.set_metrics_controller(metric_controller)
+        return controller
+
+    @staticmethod
+    def _create_plugin_package(name, code):
+        temp_directory = tempfile.mkdtemp()
+        try:
+            PluginConnectorTest._create_plugin(name, code, temp_directory)
+            call('cd {0}/{1}; tar -czf ../package.tgz .'.format(temp_directory, name), shell=True)
+            with open('{0}/package.tgz'.format(temp_directory), 'rb') as package_file:
+                package_data = package_file.read()
+            hasher = hashlib.md5()
+            hasher.update(package_data)
+            calculated_md5 = hasher.hexdigest()
+            return calculated_md5, package_data
+        finally:
+            shutil.rmtree(temp_directory)
+
+    @staticmethod
+    def _do_request(plugin_id, web_function, controller, params=None):
+        kwargs = {'plugin_web_request': PluginWebRequest(method='html_index', version=1, params=params).serialize()}
+        response = controller._request(plugin_id, web_function, kwargs=kwargs)
+        return PluginWebResponse.deserialize(response).body
+
+    @mark.slow
+    def test_input_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._input_data = None
+        self._input_data_version_2 = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'input_data': self._input_data,
+                'input_data_version_2': self._input_data_version_2}
+
+    @input_status
+    def input(self, input_status_inst):
+        self._input_data = input_status_inst
+
+    @input_status(version=2)
+    def input_version_2(self, input_status_inst):
+        self._input_data_version_2 = input_status_inst
+        
+    @input_status(version=3)
+    def input_with_unsupported_decorator(self, test_data):
+        pass
+""")
+
+            controller = PluginConnectorTest._get_controller()
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            rising_input_event = {'id': 1,
+                                  'status': True,
+                                  'location': {'room_id': 1}}
+            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.INPUT_CHANGE,
+                                                          data=rising_input_event))
+            falling_input_event = {'id': 2,
+                                   'status': False,
+                                   'location': {'room_id': 5}}
+            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.INPUT_CHANGE,
+                                                          data=falling_input_event))
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['input_data'], [1, None])  # only rising edges should be triggered
+            self.assertEqual(response['input_data_version_2'], {'input_id': 2, 'status': False})
+
+            plugin_logs = controller.get_logs()['P1']
+            self.assertIn('Decorator `input_status` version `3` is not supported', plugin_logs)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_output_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._output_data = None
+        self._output_data_version_2 = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'output_data': self._output_data,
+                'output_data_version_2': self._output_data_version_2}
+
+    @output_status
+    def output(self, output_status_inst):
+        self._output_data = output_status_inst
+
+    @output_status(version=2)
+    def output_version_2(self, output_status_inst):
+        self._output_data_version_2 = output_status_inst
+        
+    @output_status(version=3)
+    def output_with_unsupported_decorator(self, test_data):
+        pass
+""")
+
+            output_controller = mock.Mock(OutputController)
+            output_controller.get_output_statuses = lambda: [OutputStatusDTO(id=1, status=True, dimmer=5)]
+            controller = PluginConnectorTest._get_controller(output_controller=output_controller)
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            output_event = {'id': 1,
+                            'status': {'on': True,
+                                       'value': 5,
+                                       'locked': True},
+                            'location': {'room_id': 5}}
+            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.OUTPUT_CHANGE,
+                                                          data=output_event))
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['output_data'], [[1, 5]])
+            self.assertEqual(response['output_data_version_2'], output_event)
+
+            plugin_logs = controller.get_logs()['P1']
+            self.assertIn('Decorator `output_status` version `3` is not supported', plugin_logs)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_sensor_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, connector):
+        OMPluginBase.__init__(self, webinterface=webinterface, 
+                                    connector=connector)
+        self.connector.sensor.subscribe_status_event(self._handle_sensor_2, version=2)
+        self._sensor_data_1 = None
+        self._sensor_data_2 = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        sensor_data_2 = None
+        if self._sensor_data_2:
+            sensor_data_2 = {'type': self._sensor_data_2.type,
+                             'data': self._sensor_data_2.data}
+        return {'sensor_data_1': self._sensor_data_1,
+                'sensor_data_2': sensor_data_2} 
+
+    @sensor_status(version=1)
+    def sensor(self, sensor_status_inst):
+        self._sensor_data_1 = sensor_status_inst
+    
+    def _handle_sensor_2(self, event):
+        self._sensor_data_2 = event
+        
+    @om_expose(auth=False)
+    def register(self, external_id, physical_quantity, unit, name):
+        return self.connector.sensor.register(external_id=external_id,
+                                              physical_quantity=physical_quantity,
+                                              unit=unit,
+                                              name=name)
+    
+    @om_expose(auth=False)
+    def report_state(self, external_id, physical_quantity, unit, value):
+        sensor = self.connector.sensor.DTOs.SensorDTO(external_id=external_id,
+                                                      physical_quantity=physical_quantity,
+                                                      unit=unit)
+        return self.connector.sensor.report_state(sensor=sensor,
+                                                  value=value)
+""")
+
+            sensors = {}
+            sensor_states = {}
+            source_dto = None
+
+            def _plugin_sensor_callback_action(source, action, action_payload):
+                self.assertEqual(source, source_dto)
+                if action == SensorEnums.CallbackAction.REGISTER:
+                    self.assertTrue(isinstance(action_payload, PluginSensorDTO), 'Test handler: Payload is no PluginSensorDTO')
+                    sensors[action_payload.external_id] = action_payload
+                    return 'register_processed'
+                if action == SensorEnums.CallbackAction.REPORT_STATUS:
+                    self.assertTrue(isinstance(action_payload, dict), 'Test handler: Payload is no dict')
+                    self.assertIn(action_payload['sensor'].external_id, sensors)
+                    sensor_states[action_payload['sensor'].external_id] = action_payload
+                    return 'report_status_processed'
+
+            controller = PluginConnectorTest._get_controller()
+            controller.sensor_callback_action = _plugin_sensor_callback_action
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            source_dto = SourceDTO(source=Source.PLUGIN,
+                                   source_id=plugin.id)
+            with self.assertRaises(PluginException):
+                PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                web_function='register',
+                                                controller=controller,
+                                                params={'external_id': 'one',
+                                                        'name': 'sensor_one',
+                                                        'physical_quantity': 'foobar',
+                                                        'unit': 'watt'})
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='register',
+                                                       controller=controller,
+                                                       params={'external_id': 'one',
+                                                               'name': 'sensor_one',
+                                                               'physical_quantity': 'power',
+                                                               'unit': 'watt'})
+            self.assertEqual(sensors.get('one'),
+                             PluginSensorDTO(external_id='one',
+                                             name='sensor_one',
+                                             physical_quantity='power',
+                                             unit='watt'),
+                             response)
+            self.assertEqual('register_processed', response, response)
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='report_state',
+                                                       controller=controller,
+                                                       params={'external_id': 'one',
+                                                               'physical_quantity': 'power',
+                                                               'unit': 'watt',
+                                                               'value': 10})
+            self.assertEqual(sensor_states.get('one'),
+                             {'sensor': PluginSensorDTO(external_id='one',
+                                                        physical_quantity='power',
+                                                        unit='watt'),
+                              'value': 10},
+                             response)
+            self.assertEqual('report_status_processed', response, response)
+
+            sensor_event = {'id': 1,
+                            'value': 21.5,
+                            'timestamp': 164434668.79582}
+            controller.process_gateway_event(GatewayEvent(event_type=GatewayEvent.Types.SENSOR_CHANGE,
+                                                          data=sensor_event))
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['sensor_data_1'], sensor_event)
+            self.assertEqual(response['sensor_data_2'], {'type': GatewayEvent.Types.SENSOR_CHANGE,
+                                                         'data': sensor_event})
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_shutter_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+    
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._shutter_data_v1 = None
+        self._shutter_data_v1_detail = None
+        self._shutter_data_v2 = None
+        self._shutter_data_v3 = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'shutter_data_v1': self._shutter_data_v1,
+                'shutter_data_v1_detail': self._shutter_data_v1_detail,
+                'shutter_data_v2': self._shutter_data_v2,
+                'shutter_data_v3': self._shutter_data_v3}
+
+    @shutter_status
+    def shutter_v1(self, test_data):
+        self._shutter_data_v1 = test_data
+
+    @shutter_status
+    def shutter_v1_detail(self, test_data, detail):
+        self._shutter_data_v1_detail = (test_data, detail)
+
+    @shutter_status(version=2)
+    def shutter_v2(self, test_data, detail):
+        self._shutter_data_v2 = (test_data, detail)
+
+    @shutter_status(version=3)
+    def shutter_v3(self, shutter_event):
+        self._shutter_data_v3 = shutter_event
+""")
+
+            shutter_controller = mock.Mock(ShutterController)
+            shutter_status = [ShutterEnums.State.STOPPED]
+            detail_for_shutter = {'1': {'state': ShutterEnums.State.STOPPED,
+                                        'actual_position': None,
+                                        'desired_position': None,
+                                        'last_change': 1596787761.147892}}
+            shutter_controller.get_states = lambda: {'status': shutter_status,
+                                                     'detail': detail_for_shutter}
+            controller = PluginConnectorTest._get_controller(shutter_controller=shutter_controller)
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            shutter_event = GatewayEvent(event_type=GatewayEvent.Types.SHUTTER_CHANGE,
+                                         data={'some_random_key': 'some_random_value'})
+            controller.process_gateway_event(shutter_event)
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['shutter_data_v1'], shutter_status)
+            self.assertEqual(response['shutter_data_v1_detail'], [shutter_status, detail_for_shutter])
+            self.assertEqual(response['shutter_data_v2'], [shutter_status, detail_for_shutter])
+            self.assertEqual(response['shutter_data_v3'], shutter_event.data)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_ventilation_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+    
+    def __init__(self, webinterface, connector):
+        OMPluginBase.__init__(self, webinterface=webinterface, 
+                                    connector=connector)
+        self.connector.ventilation.attach_set_auto(handler=self.set_auto, 
+                                                   version=1)
+        self.connector.ventilation.attach_set_manual(handler=self.set_manual,
+                                                     version=1)
+        self._auto_data = None
+        self._manual_data = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'auto': self._auto_data,
+                'manual': self._manual_data}
+
+    def set_auto(self, external_id):
+        self._auto_data = external_id
+        return 'set_auto_processed'
+
+    def set_manual(self, external_id, level, timer):
+        self._manual_data = [external_id, level, timer]
+        return 'set_manual_processed'
+
+    @om_expose(auth=False)
+    def register(self, external_id, name, amount_of_levels, device_type, device_vendor, device_serial):
+        return self.connector.ventilation.register(external_id=external_id,
+                                                   name=name,
+                                                   amount_of_levels=amount_of_levels,
+                                                   device_type=device_type,
+                                                   device_vendor=device_vendor,
+                                                   device_serial=device_serial)
+    
+    @om_expose(auth=False)
+    def report_state(self, external_id, mode, level, remaining_time, last_seen=None):
+        return self.connector.ventilation.report_state(external_id=external_id,
+                                                       mode=mode,
+                                                       level=level,
+                                                       remaining_time=remaining_time,
+                                                       last_seen=last_seen)
+""")
+            ventilation_units = {}
+            ventilation_unit_states = {}
+            source_dto = None
+
+            def _plugin_ventilation_callback_action(source, action, action_payload):
+                self.assertEqual(source, source_dto)
+                if action == VentilationEnums.CallbackAction.REGISTER:
+                    self.assertTrue(isinstance(action_payload, PluginVentilationDTO))
+                    ventilation_units[action_payload.external_id] = action_payload
+                    return 'register_processed'
+                if action == VentilationEnums.CallbackAction.REPORT_STATUS:
+                    self.assertTrue(isinstance(action_payload, dict))
+                    self.assertIn(action_payload['external_id'], ventilation_units)
+                    ventilation_unit_states[action_payload['external_id']] = action_payload
+                    return 'report_status_processed'
+
+            controller = PluginConnectorTest._get_controller()
+            controller.ventilation_callback_action = _plugin_ventilation_callback_action
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            source_dto = SourceDTO(source=Source.PLUGIN,
+                                   source_id=plugin.id)
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='register',
+                                                       controller=controller,
+                                                       params={'external_id': 'one',
+                                                               'name': 'ventilation_one',
+                                                               'amount_of_levels': 2,
+                                                               'device_type': 'FooBar',
+                                                               'device_vendor': 'OpenMotics',
+                                                               'device_serial': '000-00000'})
+            self.assertEqual(ventilation_units.get('one'),
+                             PluginVentilationDTO(external_id='one',
+                                                  name='ventilation_one',
+                                                  amount_of_levels=2,
+                                                  device_type='FooBar',
+                                                  device_vendor='OpenMotics',
+                                                  device_serial='000-00000'),
+                             response)
+            self.assertEqual('register_processed', response, response)
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='report_state',
+                                                       controller=controller,
+                                                       params={'external_id': 'one',
+                                                               'mode': 'manual',
+                                                               'level': 0,
+                                                               'remaining_time': 50,
+                                                               'last_seen': 123})
+            self.assertEqual(ventilation_unit_states.get('one'),
+                             {'external_id': 'one',
+                              'mode': 'manual',
+                              'level': 0,
+                              'remaining_time': 50,
+                              'last_seen': 123},
+                             response)
+            self.assertEqual('report_status_processed', response, response)
+
+            response = controller.execute_ventilation_action(action=VentilationEnums.Action.SET_AUTO,
+                                                             action_payload={'external_id': ventilation_units['one'].external_id},
+                                                             destination=source_dto)
+            self.assertEqual('set_auto_processed', response, response)
+
+            response = controller.execute_ventilation_action(action=VentilationEnums.Action.SET_MANUAL,
+                                                             action_payload={'external_id': ventilation_units['one'].external_id,
+                                                                             'level': 0,
+                                                                             'timer': 10},
+                                                             destination=source_dto)
+            self.assertEqual('set_manual_processed', response, response)
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual({'auto': ventilation_units['one'].external_id,
+                              'manual': [ventilation_units['one'].external_id, 0, 10]},
+                             response,
+                             response)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_notification_connector(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, connector):
+        OMPluginBase.__init__(self, webinterface=webinterface, 
+                                    connector=connector)
+
+    @om_expose(auth=False)
+    def send(self, topic, message):
+        return self.connector.notification.send(topic=topic,
+                                                message=message)
+""")
+            notifications = []
+            source_dto = None
+
+            def _plugin_notification_callback_action(source, action, action_payload):
+                self.assertEqual(source, source_dto)
+                if action == NotificationEnums.CallbackAction.SEND:
+                    self.assertTrue(isinstance(action_payload, dict))
+                    notifications.append(action_payload)
+                    return 'send_processed'
+
+            controller = PluginConnectorTest._get_controller()
+            controller.notification_callback_action = _plugin_notification_callback_action
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            source_dto = SourceDTO(source=Source.PLUGIN,
+                                   source_id=plugin.id)
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='send',
+                                                       controller=controller,
+                                                       params={'topic': 'foo',
+                                                               'message': 'bar'})
+            self.assertEqual(1, len(notifications))
+            self.assertEqual(notifications[0],
+                             {'type': 'USER',
+                              'topic': 'foo',
+                              'message': 'bar'},
+                             response)
+            self.assertEqual('send_processed', response, response)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_background_task(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._bg_running = False
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'bg_running': self._bg_running}
+
+    @background_task
+    def run(self):
+        while True:
+            self._bg_running = True
+            time.sleep(1)
+""")
+
+            controller = PluginConnectorTest._get_controller()
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['bg_running'], True)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_legacy_ev_event(self):
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._event_data = None
+
+    @om_expose(auth=False)
+    def get_log(self):
+        return {'event_data': self._event_data}
+
+    @receive_events
+    def recv_events(self, code):
+        self._event_data = code
+""")
+
+            controller = PluginConnectorTest._get_controller()
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin = db.query(Plugin).filter_by(name='P1').one()
+
+            controller.process_event(1)
+
+            response = PluginConnectorTest._do_request(plugin_id=plugin.id,
+                                                       web_function='get_log',
+                                                       controller=controller)
+            self.assertEqual(response['event_data'], 1)
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+
+    @mark.slow
+    def test_plugin_metrics_connector(self):
+        """ Validates whether two plugins won't get the same metric instance """
+        controller = None
+        try:
+            p1_md5, p1_data = PluginConnectorTest._create_plugin_package('P1', """
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.0.1'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._metric = None
+
+    @om_expose(auth=False)
+    def get_metric(self):
+        return {'metric': self._metric}
+
+    @om_metric_receive()
+    def set_metric(self, metric):
+        self._metric = metric
+        self._metric['foo'] = 'P1'
+""")
+            p2_md5, p2_data = PluginConnectorTest._create_plugin_package('P2', """
+from plugins.base import *
+
+class P2(OMPluginBase):
+    name = 'P2'
+    version = '0.0.1'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self._metric = None
+
+    @om_expose(auth=False)
+    def get_metric(self):
+        return {'metric': self._metric}
+
+    @om_metric_receive()
+    def set_metric(self, metric):
+        self._metric = metric
+        self._metric['foo'] = 'P2'
+""")
+
+            controller = PluginConnectorTest._get_controller()
+            controller.start()
+
+            metrics_controller = controller._metrics_controller
+
+            controller.install_plugin(p1_md5, p1_data)
+            controller.start_plugin('P1')
+            controller.install_plugin(p2_md5, p2_data)
+            controller.start_plugin('P2')
+
+            with Database.get_session() as db:
+                plugin_1_id = db.query(Plugin).filter_by(name='P1').one().id
+                plugin_2_id = db.query(Plugin).filter_by(name='P2').one().id
+
+            metrics_controller.definitions['test'] = {'test': {'type': 'test',
+                                                               'tags': [],
+                                                               'metrics': []}}
+            metrics_controller.metrics_queue_plugins.append({'timestamp': 0,
+                                                             'source': 'test',
+                                                             'type': 'test',
+                                                             'tags': {},
+                                                             'values': {}})
+            metrics_controller._distribute_plugins()
+
+            self.assertEqual({'total': 2,
+                              'test.test': 2}, metrics_controller.outbound_rates)
+
+            start = time.time()
+            p1_metric = {'metric': None}
+            p2_metric = {'metric': None}
+            while time.time() - start < 6:
+                kwargs = {'plugin_web_request': PluginWebRequest(version=1).serialize()}
+                p1_metric = controller._request(plugin_1_id, 'get_metric', kwargs=kwargs)
+                p1_metric = PluginWebResponse.deserialize(p1_metric).body
+                p2_metric = controller._request(plugin_2_id, 'get_metric', kwargs=kwargs)
+                p2_metric = PluginWebResponse.deserialize(p2_metric).body
+                if p1_metric['metric'] is not None and p2_metric['metric'] is not None:
+                    break
+                time.sleep(0.1)
+
+            self.assertIsNotNone(p1_metric['metric'])
+            self.assertEqual('P1', p1_metric['metric'].get('foo'))
+            self.assertIsNotNone(p2_metric['metric'])
+            self.assertEqual('P2', p2_metric['metric'].get('foo'))
+            # Compare the addresses to make sure it's a different instance
+            self.assertNotEqual(id(p1_metric['metric']), id(p2_metric['metric']))
+
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
+            PluginConnectorTest._destroy_plugin('P2')
+
+    @mark.slow
+    def test_om_expose_decorator(self):
+        """ Test the om_expose decorator. """
+        controller = None
+        try:
+            PluginConnectorTest._create_plugin('P1', """
+import inspect
+import time
+from plugins.base import *
+
+class P1(OMPluginBase):
+    name = 'P1'
+    version = '0.1.0'
+    interfaces = []
+
+    def __init__(self, webinterface, logger):
+        OMPluginBase.__init__(self, webinterface, logger)
+        self.logger = logger
+        self.dummy_var = 37
+
+    def print_func_name(self):
+        self.logger('Calling func: {}'.format(inspect.stack()[1][3]))
+
+
+    @om_expose(auth=True)
+    def html_index(self):
+        return 'HTML'
+
+    @om_expose(auth=True)
+    def v1_auth_string(self):
+        self.print_func_name()
+        return 'string'
+
+    @om_expose(auth=False)
+    def v1_nonauth_dict(self):
+        self.print_func_name()
+        return {'dummy_var': self.dummy_var}
+
+    @om_expose
+    def v1_default_bytes(self):
+        self.print_func_name()
+        return b'someBytesString'
+
+    @om_expose
+    def v1_default_param(self, param):
+        self.print_func_name()
+        self.logger('Received param: {} of type: {}'.format(param, type(param)))
+        return param
+
+    @om_expose(version=2)
+    def v2_default_string(self):
+        self.print_func_name()
+        return 'someString'
+
+    @om_expose(version=2)
+    def v2_default_param(self, param):
+        self.print_func_name()
+        self.logger('Received param: {} of type: {}'.format(param, type(param)))
+        return param
+
+    @om_expose(version=2)
+    def v2_default_param_web_request(self, param, plugin_web_request):
+        self.print_func_name()
+        self.logger('Received param: {} of type: {}'.format(param, type(param)))
+        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
+        return param
+
+    @om_expose(version=2)
+    def v2_default_dict(self, plugin_web_request):
+        self.print_func_name()
+        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
+        return {'response-data': 'response...'} 
+
+    @om_expose(version=2)
+    def v2_default_param_web_request_web_response(self, param, plugin_web_request):
+        self.print_func_name()
+        self.logger('Received param: {} of type: {}'.format(param, type(param)))
+        self.logger('Received PluginWebRequest: {}'.format(plugin_web_request))
+        response =PluginWebResponse(
+            status_code=201,
+            headers={'some-header': 'some-header-value'},
+            body=param,
+            path='somePath'
+        )
+        return response
+
+    @om_expose
+    def v1_body(self, request_body):
+        self.print_func_name()
+        self.logger('Received body: {}'.format(request_body))
+        return request_body
+
+    @om_expose(version=2)
+    def v2_body(self, request_body):
+        self.print_func_name()
+        self.logger('Received body: {}'.format(request_body))
+        return request_body
+""")
+
+            controller = PluginConnectorTest._get_controller()
+            controller.start()
+
+            with Database.get_session() as db:
+                plugin_id = db.query(Plugin).filter_by(name='P1').one().id
+
+            def do_request(func, web_request=None, get_web_response=False, self=self):
+                if web_request is None:
+                    request = PluginWebRequest(version=1).serialize()
+                    version = 1
+                else:
+                    request = web_request.serialize()
+                    version = web_request.version
+
+                kwargs = {'plugin_web_request': request}
+                resp = controller._request(plugin_id, func, kwargs=kwargs)
+                if not get_web_response:
+                    plugin_response = PluginWebResponse.deserialize(resp)
+                    resp = plugin_response.body
+                    self.assertEqual(plugin_response.version, version)
+                else:
+                    resp = PluginWebResponse.deserialize(resp)
+                return resp
+
+            response = do_request('html_index')
+            self.assertEqual(response, 'HTML')
+
+            response = do_request('v1_auth_string')
+            self.assertEqual(response, 'string')
+
+            response = do_request('v1_nonauth_dict')
+            self.assertEqual(response, {'dummy_var': 37})
+
+            response = do_request('v1_default_bytes')
+            self.assertEqual(response, b'someBytesString')
+
+            response = do_request('v1_default_param',
+                                  web_request=PluginWebRequest(version=1, params={'param': 'some-param'}))
+            self.assertEqual(response, 'some-param')
+
+            response = do_request('v1_default_param',
+                                  web_request=PluginWebRequest(version=1, params={'param': {'test': 'test'}}))
+            self.assertEqual(response, {'test': 'test'})
+
+            try:
+                do_request('v1_default_param',
+                           web_request=PluginWebRequest(version=1, params={}))
+                self.fail('There should be a missing parameter')
+            except Exception:
+                pass
+
+            response = do_request('v2_default_string')
+            self.assertEqual(response, 'someString')
+
+            response = do_request('v2_default_param',
+                                  web_request=PluginWebRequest(version=2, params={'param': 'some-param'}))
+            self.assertEqual(response, 'some-param')
+
+            response = do_request('v2_default_param',
+                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}))
+            self.assertEqual(response, {'test': 'test'})
+
+            response = do_request('v2_default_param_web_request',
+                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}))
+            self.assertEqual(response, {'test': 'test'})
+
+            response = do_request('v2_default_dict',
+                                  web_request=PluginWebRequest(version=2, params={}),
+                                  get_web_response=True)
+            self.assertEqual(response.body, {'response-data': 'response...'})
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 200)
+
+            response = do_request('v2_default_param_web_request',
+                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}),
+                                  get_web_response=True)
+            self.assertEqual(response.body, {'test': 'test'})
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 200)
+
+            response = do_request('v2_default_param_web_request_web_response',
+                                  web_request=PluginWebRequest(version=2, params={'param': {'test': 'test'}}),
+                                  get_web_response=True)
+            self.assertEqual(response.body, {'test': 'test'})
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 201)
+            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
+
+            response = do_request('v2_default_param_web_request_web_response',
+                                  web_request=PluginWebRequest(version=2, params={'param': 'someString'}),
+                                  get_web_response=True)
+            self.assertEqual(response.body, 'someString')
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 201)
+            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
+
+            response = do_request('v2_default_param_web_request_web_response',
+                                  web_request=PluginWebRequest(version=2,
+                                                               params={'param': 'someString', 'param2': 'test'}),
+                                  get_web_response=True)
+            self.assertEqual(response.body, 'someString')
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 201)
+            self.assertEqual(response.headers, {'some-header': 'some-header-value'})
+
+            for special_string in [
+                'someString/someOtherText!@#$%^&*()<>{}[]',
+                'basic_string',
+                u'test_unicode'
+            ]:
+                response = do_request('v2_default_param_web_request_web_response',
+                                      web_request=PluginWebRequest(version=2,
+                                                                   params={'param': special_string, 'param2': 'test'}),
+                                      get_web_response=True)
+                self.assertEqual(response.body, special_string)
+                self.assertEqual(response.version, 2)
+                self.assertEqual(response.status_code, 201)
+                self.assertEqual(response.headers, {'some-header': 'some-header-value'})
+
+            try:
+                do_request('v2_default_param_web_request_web_response',
+                           web_request=PluginWebRequest(version=2, params={}),
+                           get_web_response=True)
+                self.fail('Request should not succeed due to parameter not filled in')
+            except Exception:
+                pass
+
+            response = do_request('v1_body',
+                                  web_request=PluginWebRequest(version=1, body='somebody'),
+                                  get_web_response=True)
+            self.assertEqual(response.body, 'somebody')
+            self.assertEqual(response.version, 1)
+            self.assertEqual(response.status_code, 200)
+
+            response = do_request('v2_body',
+                                  web_request=PluginWebRequest(version=2, body='somebody'),
+                                  get_web_response=True)
+            self.assertEqual(response.body, 'somebody')
+            self.assertEqual(response.version, 2)
+            self.assertEqual(response.status_code, 200)
+
+        finally:
+            if controller is not None:
+                controller.stop()
+            PluginConnectorTest._destroy_plugin('P1')
diff --git a/testing/unittests/plugins_tests/runner_test.py b/testing/unittests/plugins_tests/runner_test.py
index dd2b3e65..3b8eaf1c 100644
--- a/testing/unittests/plugins_tests/runner_test.py
+++ b/testing/unittests/plugins_tests/runner_test.py
@@ -24,6 +24,7 @@ import tempfile
 import unittest
 import mock
 from plugins.runner import PluginRunner, RunnerWatchdog
+from gateway.exceptions import PluginCommunicationTimeout
 
 
 class PluginRunnerTest(unittest.TestCase):
@@ -49,63 +50,56 @@ class PluginRunnerTest(unittest.TestCase):
         print(kwargs)
         _ = self, args, kwargs
 
-    def test_queue_length(self):
-        runner = PluginRunner(name='foo',
-                              runtime_path=self.RUNTIME_PATH,
-                              plugin_path=self.PLUGIN_PATH,
-                              logger=self._log)
-        self.assertEqual(runner.get_queue_length(), 0)
-
     def test_watchog_always_stops_runner(self):
 
         def _set_side_effects(effects):
-            error_score.side_effect = effects[0]
+            ping.side_effect = effects[0]
             start.side_effect = effects[1]
             stop.side_effect = effects[2]
             is_running.side_effect = effects[3]
 
         def _reset():
-            error_score.reset_mock()
+            ping.reset_mock()
             start.reset_mock()
             stop.reset_mock()
             is_running.reset_mock()
 
-        runner = PluginRunner(name='foo',
+        runner = PluginRunner(plugin_id=0,
+                              name='foo',
                               runtime_path=self.RUNTIME_PATH,
-                              plugin_path=self.PLUGIN_PATH,
-                              logger=self._log)
+                              plugin_path=self.PLUGIN_PATH)
         watchdog = RunnerWatchdog(plugin_runner=runner)
         watchdog.logger = self._log
-        with mock.patch.object(runner, 'error_score') as error_score, \
+        with mock.patch.object(runner, 'ping') as ping, \
                 mock.patch.object(runner, 'start') as start, \
                 mock.patch.object(runner, 'stop') as stop, \
                 mock.patch.object(runner, 'is_running') as is_running:
-            for scenario in [{'side_effects': [[0.0], [None], [None], [True]],  # Everything is good
+            for scenario in [{'side_effects': [[None], [None], [None], [True, True]],  # Everything is good
                               'result': True,
-                              'calls': [1, 0, 0, 1]},
-                             {'side_effects': [[0.0], [None], [None], [False]],  # The runner was not running and is started
+                              'calls': [1, 0, 0, 2]},
+                             {'side_effects': [[None], [None], [None], [False, False]],  # The runner was not running and is started
                               'result': True,
-                              'calls': [1, 1, 0, 1]},
-                             {'side_effects': [[1.0], [None], [None], [False]],  # The runner is unhealthy and is stopped, and then started again
+                              'calls': [0, 1, 0, 2]},
+                             {'side_effects': [[PluginCommunicationTimeout()], [None], [None], [True, False]],  # The runner is unhealthy and is stopped, and then started again
                               'result': True,
-                              'calls': [1, 1, 1, 1]},
-                             {'side_effects': [[RuntimeError()], [None], [None], [False]],  # Exception while requesting score, unhealthy runner is stopped
+                              'calls': [1, 1, 1, 2]},
+                             {'side_effects': [[RuntimeError()], [None], [None], [True, False]],  # Exception while pinging, unhealthy runner is stopped
                               'result': False,
-                              'calls': [1, 0, 1, 0]},
-                             {'side_effects': [[1.0], [None], [RuntimeError()], [False]],  # Exception while stopping unhealthy runner, failed runner is stopped
+                              'calls': [1, 0, 1, 1]},
+                             {'side_effects': [[PluginCommunicationTimeout()], [None], [RuntimeError()], [True, False]],  # Exception while stopping unhealthy runner, failed runner is stopped
                               'result': False,
-                              'calls': [1, 0, 2, 0]},
-                             {'side_effects': [[0.0], [RuntimeError()], [None], [False]],  # Exception while starting stopped runner, failed runner is stopped
+                              'calls': [1, 0, 2, 1]},
+                             {'side_effects': [[None], [RuntimeError()], [None], [False, False]],  # Exception while starting stopped runner, failed runner is stopped
                               'result': False,
-                              'calls': [1, 1, 1, 1]},
-                             {'side_effects': [[1.0], [None], [RuntimeError(), RuntimeError()], [False]],  # Exception while stopping unhealthy runner, failed runner is stopped. And that stop also fails
+                              'calls': [0, 1, 1, 2]},
+                             {'side_effects': [[PluginCommunicationTimeout()], [None], [RuntimeError(), RuntimeError()], [True, False]],  # Exception while stopping unhealthy runner, failed runner is stopped. And that stop also fails
                               'result': False,
-                              'calls': [1, 0, 2, 0]}]:
+                              'calls': [1, 0, 2, 1]}]:
                 _reset()
                 _set_side_effects(scenario['side_effects'])
                 result = watchdog._run()
-                self.assertEqual(scenario['result'], result)
-                for i, _mock in enumerate([error_score, start, stop, is_running]):
+                self.assertEqual(scenario['result'], result, scenario)
+                for i, _mock in enumerate([ping, start, stop, is_running]):
                     if scenario['calls'][i] == 0:
                         _mock.assert_not_called()
                     elif scenario['calls'][i] == 1:
diff --git a/testing/unittests/power_tests/module_helper_test.py b/testing/unittests/power_tests/module_helper_test.py
index 070ea64d..909a340e 100644
--- a/testing/unittests/power_tests/module_helper_test.py
+++ b/testing/unittests/power_tests/module_helper_test.py
@@ -45,7 +45,7 @@ class EnergyModuleHelperTest(unittest.TestCase):
         super(EnergyModuleHelperTest, cls).setUpClass()
         SetTestMode()
         Logs.set_loglevel(logging.DEBUG, namespace='gateway.energy_module_controller')
-        Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
+        # Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
 
     @classmethod
     def tearDownClass(cls):
@@ -88,6 +88,18 @@ class EnergyModuleHelperTest(unittest.TestCase):
             db.commit()
             return energy_module
 
+    def test_get_information(self):
+        energy_module = self._setup_module(version=EnergyEnums.Version.POWER_MODULE,
+                                           address='11')
+        with self.session as db, mock.patch.object(self.energy_communicator, 'do_command', return_value=(b'OMFPC_1_0_99', b'')) as cmd:
+            db.add(energy_module)  # this re-associates the existing object with the new session context
+
+            ok, version = self.helper.get_information(energy_module)
+            self.assertEqual([mock.call(11, EnergyCommand('G', 'FIV', '', '16s', module_type=bytearray(b'E')))],
+                             cmd.call_args_list)
+            self.assertTrue(ok)
+            self.assertEqual(version, '1.0.99')
+
     def test_get_currents(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.POWER_MODULE,
                                            address='11')
@@ -176,7 +188,7 @@ class EnergyModuleHelperTest(unittest.TestCase):
 
 
 class P1ControllerTest(unittest.TestCase):
-
+    maxDiff = None
     # TODO: Use more accurate payloads
 
     @classmethod
@@ -184,7 +196,7 @@ class P1ControllerTest(unittest.TestCase):
         super(P1ControllerTest, cls).setUpClass()
         SetTestMode()
         Logs.set_loglevel(logging.DEBUG, namespace='gateway.energy_module_controller')
-        Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
+        # Logs.set_loglevel(logging.DEBUG, namespace='sqlalchemy.engine')
 
     @classmethod
     def tearDownClass(cls):
@@ -226,102 +238,75 @@ class P1ControllerTest(unittest.TestCase):
             return energy_module
 
     def test_get_realtime_p1(self):
-        with mock.patch.object(self.helper, '_get_statuses',
-                               return_value=[
-                                   True, True, False, True,
-                                   False, False, False, False
-                               ]), \
-             mock.patch.object(self.helper, '_get_meter',
-                               side_effect=([
-                                   '1111111111111111111111111111',
-                                   '3333333333333333333333333333',
-                                   '                            ',
-                                   '                            '
-                               ], [
-                                   '2222222222222222222222222222',
-                                   '                            ',
-                                   '                            ',
-                                   '4444444444444444444444444444'
-                               ])), \
-             mock.patch.object(self.helper, '_get_timestamp',
-                               return_value=[1.0, 2.0, 0.0, 190527083152.0]), \
-             mock.patch.object(self.helper, '_get_gas_consumption',
-                               return_value=[1.0, 2.3, 0.0, 12.0]), \
-             mock.patch.object(self.helper, '_get_consumption_tariff',
-                               return_value=[1.0, 2.3, 0.0, 12.0]), \
-             mock.patch.object(self.helper, '_get_injection_tariff',
-                               return_value=[1.0, 2.3, 0.0, 12.0]), \
-             mock.patch.object(self.helper, '_get_tariff_indicator',
-                               return_value=[1.0, 2.0, 0.0, 12.0]), \
-             mock.patch.object(self.helper, '_get_phase_currents',
-                               return_value=[
-                                   {'phase1': 1.0, 'phase2': 1.0, 'phase3': 1.0},
-                                   {'phase1': 2.0, 'phase2': 2.0, 'phase3': 2.0},
-                                   {'phase1': 0.0, 'phase2': 0.0, 'phase3': 0.0},
-                                   {'phase1': 12.0, 'phase2': 12.0, 'phase3': 12.0},
-                               ]), \
-             mock.patch.object(self.helper, '_get_phase_voltages',
-                               return_value=[
-                                   {'phase1': 1.0, 'phase2': 1.0, 'phase3': 1.0},
-                                   {'phase1': 2.3, 'phase2': 2.3, 'phase3': 2.3},
-                                   {'phase1': 0.0, 'phase2': 0.0, 'phase3': 0.0},
-                                   {'phase1': 12.0, 'phase2': 12.0, 'phase3': 12.0},
-                               ]), \
-             mock.patch.object(self.helper, '_get_delivered_powers',
-                               return_value=[2.0, 3.0, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0]), \
-             mock.patch.object(self.helper, '_get_received_powers',
-                               return_value=[1.0, 3.0, 0.0, 12.0, 0.0, 0.0, 0.0, 0.0]):
-
-            energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR,
-                                               address=10)
-            with self.session as db:
-                db.add(energy_module)
-                result = self.helper.get_realtime_p1(energy_module)
-                self.assertEqual([
-                    {'electricity': {'current': {'phase1': 1.0, 'phase2': 1.0, 'phase3': 1.0},
-                                     'ean': '1111111111111111111111111111',
-                                     'tariff_indicator': 1.0,
-                                     'consumption_tariff1': 1.0,
-                                     'consumption_tariff2': 1.0,
-                                     'injection_tariff1': 1.0,
-                                     'injection_tariff2': 1.0,
-                                     'voltage': {'phase1': 1.0, 'phase2': 1.0, 'phase3': 1.0}},
-                     'gas': {'consumption': 1.0, 'ean': '2222222222222222222222222222'},
-                     'device_id': '10.0',
-                     'module_id': 1,
-                     'port_id': 0,
-                     'timestamp': 1.0},
-                    {'electricity': {'current': {'phase1': 2.0, 'phase2': 2.0, 'phase3': 2.0},
-                                     'ean': '3333333333333333333333333333',
-                                     'tariff_indicator': 2.0,
-                                     'consumption_tariff1': 2.3,
-                                     'consumption_tariff2': 2.3,
-                                     'injection_tariff1': 2.3,
-                                     'injection_tariff2': 2.3,
-                                     'voltage': {'phase1': 2.3, 'phase2': 2.3, 'phase3': 2.3}},
-                     'gas': {'consumption': 2.3, 'ean': ''},
-                     'device_id': '10.1',
-                     'module_id': 1,
-                     'port_id': 1,
-                     'timestamp': 2.0},
-                    {'electricity': {'current': {'phase1': 12.0,
-                                                 'phase2': 12.0,
-                                                 'phase3': 12.0},
-                                     'ean': '',
-                                     'tariff_indicator': 12.0,
-                                     'consumption_tariff1': 12.0,
-                                     'consumption_tariff2': 12.0,
-                                     'injection_tariff1': 12.0,
-                                     'injection_tariff2': 12.0,
-                                     'voltage': {'phase1': 12.0,
-                                                 'phase2': 12.0,
-                                                 'phase3': 12.0}},
-                     'gas': {'consumption': 12.0, 'ean': '4444444444444444444444444444'},
-                     'device_id': '10.3',
-                     'module_id': 1,
-                     'port_id': 3,
-                     'timestamp': 190527083152.0}
-                ], result)
+        energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR,
+                                           address=10)
+        def mock_command(addr, cmd):
+            if cmd.command.startswith(b'SP'):
+                return (0b00000011,)
+            if cmd.command.startswith(b'TS'):
+                return (b'000000000001S100000000000S                                                                              ',)
+            if cmd.command.startswith(b'M1'):
+                return (b'00000000000000000000000000013000000000000000000000000001                                                                                                                                                                         ',)
+            if cmd.command.startswith(b'M2'):
+                return (b'                            3000000000000000000000000002                                                                                                                                                                         ',)
+            if cmd.command.startswith(b'C1'):
+                return (b'002.0101.5                              ',)
+            if cmd.command.startswith(b'C2'):
+                return (b'     102.5                              ',)
+            if cmd.command.startswith(b'C3'):
+                return (b'     103.5                              ',)
+            if cmd.command.startswith(b'V1'):
+                return (b'230.0*V231.5*V                                          ',)
+            if cmd.command.startswith(b'V2'):
+                return (b'       232.5*V                                          ',)
+            if cmd.command.startswith(b'V3'):
+                return (b'       233.5*V                                          ',)
+            if cmd.command.startswith(b'c1'):
+                return (b'000000.000*kWh100001.005*kWh                                                                                    ',)
+            if cmd.command.startswith(b'c2'):
+                return (b'000000.000*kWh100002.005*kWh                                                                                    ',)
+            if cmd.command.startswith(b'i1'):
+                return (b'              100001.005*kWh                                                                                    ',)
+            if cmd.command.startswith(b'i2'):
+                return (b'              100002.005*kWh                                                                                    ',)
+            if cmd.command.startswith(b'ti'):
+                return (b'00011000                        ',)
+            if cmd.command.startswith(b'cG'):
+                return (b'            10000.005*m3                                                                                        ',)
+            return ()
+        self.energy_communicator.do_command.side_effect = mock_command
+        with self.session as db:
+            db.add(energy_module)
+            result = self.helper.get_realtime_p1(energy_module)
+            self.assertEqual([
+                {'electricity': {'ean': '0000000000000000000000000001',
+                                 'tariff_indicator': 1.0,
+                                 'consumption_tariff1': 0.0,
+                                 'consumption_tariff2': 0.0,
+                                 'injection_tariff1': None,
+                                 'injection_tariff2': None,
+                                 'current': {'phase1': 2.0, 'phase2': None, 'phase3': None},
+                                 'voltage': {'phase1': 230.0, 'phase2': None, 'phase3': None}},
+                 'gas': {'ean': None, 'consumption': None},
+                 'device_id': '10.0',
+                 'module_id': 1,
+                 'port_id': 0,
+                 'timestamp': 1.0},
+                {'electricity': {'ean': '3000000000000000000000000001',
+                                 'tariff_indicator': 1000.0,
+                                 'consumption_tariff1': 100001.005,
+                                 'consumption_tariff2': 100002.005,
+                                 'injection_tariff1': 100001.005,
+                                 'injection_tariff2': 100002.005,
+                                 'current': {'phase1': 101.0, 'phase2': 102.0, 'phase3': 103.0},  # FIXME: incorrect parsing!
+                                 'voltage': {'phase1': 231.5, 'phase2': 232.5, 'phase3': 233.5}},
+                 'gas': {'ean': '3000000000000000000000000002',
+                         'consumption': 10000.005},
+                 'device_id': '10.1',
+                 'module_id': 1,
+                 'port_id': 1,
+                 'timestamp': 100000000000.0},
+            ], result)
 
     def test_get_module_status(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
@@ -339,16 +324,16 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_meter(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '11111111111111111111111111112222222222222222222222222222                            4444444444444444444444444444'
+        payload = b'11111111111111111111111111112222222222222222222222222222                            4444444444444444444444444444'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command', return_value=[payload]) as cmd:
             db.add(energy_module)
             meters = self.helper._get_meter(energy_module, meter_type=1)
             self.assertEqual([
                 '1111111111111111111111111111',
                 '2222222222222222222222222222',
-                '                            ',
+                None,
                 '4444444444444444444444444444',
-                '', '', '', '',
+                None, None, None, None,
             ], meters)
             self.assertEqual([
                 mock.call(11, EnergyCommand('G', 'M1\x00', '', '224s', module_type=bytearray(b'C')))
@@ -357,7 +342,7 @@ class P1ControllerTest(unittest.TestCase):
     def test_get_module_timestamp(self):
         # TODO confirm this is correct
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000000000001S000000000002              000000000012S000000000013S'
+        payload = b'000000000001S000000000002              000000000012S000000000013S'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -370,7 +355,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_gas(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000000001*m300002.300*m3            00012.000*m300013.000*m3'
+        payload = b'000000001*m300002.300*m3            00012.000*m300013.000*m3'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -383,7 +368,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_consumption_tariff(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '0000000001*kWh000002.300*kWh              000012.000*kWh000013.000*kWh'
+        payload = b'0000000001*kWh000002.300*kWh              000012.000*kWh000013.000*kWh'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -396,7 +381,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_injection_tariff(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '0000000001*kWh000002.300*kWh              000012.000*kWh000013.000*kWh'
+        payload = b'0000000001*kWh000002.300*kWh              000012.000*kWh000013.000*kWh'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -410,7 +395,7 @@ class P1ControllerTest(unittest.TestCase):
     def test_get_module_tariff_indicator(self):
         # TODO confirm this is correct
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '00010002    00120013'
+        payload = b'00010002    00120013'
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -423,8 +408,8 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_current(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload1 = '001  002  !42  012  013  '
-        payload2 = '002  003  !43  013  014  '
+        payload1 = b'001  002  !42  012  013  '
+        payload2 = b'002  003  !43  013  014  '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload1],
@@ -452,8 +437,8 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_voltage(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload1 = '00001  002.3  !@#42  00012  00013  '
-        payload2 = '00002  003.4  !@#43  00013  00014  '
+        payload1 = b'00001  002.3  !@#42  00012  00013  '
+        payload2 = b'00002  003.4  !@#43  00013  00014  '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload1],
@@ -481,7 +466,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_delivered_power(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000001   000002   !@#$42   000012   000013   '
+        payload = b'000001   000002   !@#$42   000012   000013   '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -494,7 +479,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_received_power(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000001   000002   !@#$42   000012   000013   '
+        payload = b'000001   000002   !@#$42   000012   000013   '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -507,7 +492,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_day_energy(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000000.001    000000.002    !@#$%^&*42    000000.012    000000.013    '
+        payload = b'000000.001    000000.002    !@#$%^&*42    000000.012    000000.013    '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
@@ -520,7 +505,7 @@ class P1ControllerTest(unittest.TestCase):
 
     def test_get_module_night_energy(self):
         energy_module = self._setup_module(version=EnergyEnums.Version.P1_CONCENTRATOR, address=11)
-        payload = '000000.001    000000.002    !@#$%^&*42    000000.012    000000.013    '
+        payload = b'000000.001    000000.002    !@#$%^&*42    000000.012    000000.013    '
         with self.session as db, mock.patch.object(self.energy_communicator, 'do_command') as cmd:
             db.add(energy_module)
             cmd.side_effect = [[0b00001011], [payload]]
diff --git a/tools/update_gateway.py b/tools/update_gateway.py
new file mode 100644
index 00000000..2cb1b801
--- /dev/null
+++ b/tools/update_gateway.py
@@ -0,0 +1,62 @@
+# Copyright (C) 2021 OpenMotics BV
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Affero General Public License as
+# published by the Free Software Foundation, either version 3 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import hashlib
+import json
+from argparse import ArgumentParser
+
+if __name__ == '__main__':
+    """
+    This tool allows a developer to quickly generate update metadata that can be used in a manual API call
+    to the gateway, for example using postman.
+    
+    Steps to use:
+    1. Copy a tgz for the interpreter, dependencies and gateway service to the gateway
+    2. Put the files under the /opt/openmotics/static/ folder
+    3. Copy this tool to the gateway
+    4. Run this tool with parameters:
+       * `--i /opt/openmotics/static/<interpreter package>.tgz` 
+       * `--iv <interpreter version>`
+       * Same for --d and --dv for the dependencies package/version
+       * Same for --s and --sv for the gateway service package/version
+    5. The tool will spit out a json string, copy as metadata in the API call
+    """
+
+    parser = ArgumentParser(description='Manually fake a gateway update')
+    for component in ['i', 'd', 's']:
+        parser.add_argument('--{0}'.format(component), required=True,
+                            dest='{0}'.format(component))
+        parser.add_argument('--{0}v'.format(component), required=True,
+                            dest='{0}v'.format(component))
+    args = parser.parse_args()
+
+    type_mapping = {'i': 'python_interpreter',
+                    'd': 'python_dependencies',
+                    's': 'gateway_service'}
+    metadata = {'version': '0.0.1',
+                'firmwares': []}
+    for component in ['i', 'd', 's']:
+        file_path = getattr(args, component)
+        file_name = file_path.split('/')[-1]
+        with open(file_path, 'rb') as f:
+            content = f.read()
+            checksum = hashlib.sha256(content).hexdigest()
+        firmware = {'type': type_mapping[component],
+                    'version': getattr(args, '{0}v'.format(component)),
+                    'dependencies': [],
+                    'sha256': checksum,
+                    'url': 'http://localhost/static/{0}'.format(file_name)}
+        metadata['firmwares'].append(firmware)
+    print(json.dumps(metadata, indent=4))
